# Адекватная архитектура

Эта концепция находится в разработке, поэтому в ней есть белые пятна, и само слово "архитектура" в её названии не самое удачное и возможно будет изменено. В этой концепции я хочу представить один из вариантов концептуального устройства (стратегию) ПО и ряд практик программирования (тактику), призванных обезопасить это устройство от скатывания в больше месиво в результате ежедневной работы.

## Мотивация

## Релейтед ворк

В адекватной архитектуре нет ничего принципиально нового и она по сути основывается на идеях из следующих следующих хорошо известных (в узких кругах) докладах и статьях:
1) Simple Made Easy
2) Layered architecture
3) Functional core, imperative shell
4) Clean architecture
5) Hexagonal architecture
6) Railway oriented programming
7) Data, Context, interaction architecture

### Simple Made Easy
[Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/), ([краткий пересказ на русском](https://tonsky.livejournal.com/243192.html)).

Из этого доклада я взял то, что "просто" != "легко" и что простые вещи выгоднее в длительной перспективе.

Например, для того чтобы сбросить весь надо следовать двум простым правилам - "меньше жрать", "больше двигаться". Выполнять эти правила сложно, но если сумеете, то решите проблему с весом на всегда. Есть простой путь - липоскакция. Но этот путь даёт временный результат и не решает прочих проблем вызванных "легким" образом жизни.

Не взял я из этого доклада clojure, ядрёную функциональщину; идею того, что типы и тесты не особо уменьшают количество багов; и полный отказ от ОРМов.

### Layered architecture
[Layered architecture](https://dzone.com/articles/layered-architecture-is-good), [слоистая архитектура](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0) - на самом деле никогда не занимался изучением этого вопроса, поэтому взял две первые ссылки в гугле, если подскажите ссылку на хорошую статью посвщяённую этой теме - буду очень благодарен.

Адекватная архитектура в принципе является вариантом слоистой, за исключением того, что убирает зависимость слоя бизнес логики от слоя инфраструктуры/персистанса и поднимает этот слой на один уровень со слоем бизнес логики.

### Functional core, imperative shell (FCIS)
[Boundaries](https://www.youtube.com/watch?v=yTkzNHF6rMs), версии на русском я не нашёл.

Из этого доклада я взял всё. А именно - идеи разделения логики и ввода вывода и использования структур данных в качестве интерфейса между этими частями.

### Clean architecture
[Оригинальная статья](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html), [хорошее пояснение на русском](https://habr.com/ru/company/mobileup/blog/335382/), [оригинальная книга](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164), [книга на русском](https://www.ozon.ru/context/detail/id/144499396/).

Наверное самая известная из идей. Из чистой архитектуры я взял идеи того, что зависимости должны быть направлены в строну более стабильных модулейш; доменная модель и бизнеслогика не должны зависеть ни от чего; фреймворк является деталью, которая должна быть задвинута на задворки. Так же, в том числе и от сюда, я взял понятие юз кейса (интерактора).

Не стал я брать из чистой архитектуры границы в виде интерфейсов между всеми слоями по дефолту и утверждение, что база данных и тип гуя являются незначительными деталями.

Так же дядюшке Бобу над отдать должное за [Screaming architecture](https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html). На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы.

### Hexagonal (Ports&Adapters) architecture
[Оригинальная статья 2005 года](http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm), [описание на русском](https://habr.com/ru/post/267125/).

Я думаю это первая публикация из серии архитектур крайне схожих архитектур - hexagonal, clean & onion (да FCIS, тоже примерно про тоже). По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.

Отсюда (помимо общей идеи) я позаимствовал термины Порт и Адаптер. Но я их использую в другом смысле:) А до идеи событий приходящих из внешнего мира я додумался сам, когда уже забыл детали этой статьи:)

Не взял я из Hexagonal architecture церемонии с набором порт-интерфейс-адаптер на каждое взаимодействие с платформой и идею о том, что логика приложения окружена "однотипными" портами.

### Railway oriented programming  
[Оригинальная статья](https://fsharpforfunandprofit.com/rop/)

Серия статей о функциональном подходе к обработке ошибок.

Взял идею параллельных рельс для "основного" пути и "ошибочного экспресса". Суть в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса. Плюс за то, чтобы заменять исключения на возвращаемые значения, там где это уместно.

Не стал брать, монады и весь абстрактный ад второго порядка с ними связанный.

### Data, Context, interaction architecture
[Оригинальная статья](https://www.artima.com/articles/dci_vision.html).

На эту идею я наткнулся не давно и ещё её изучаю. Суть в том, чтобы объединять "тупые" доменные объекты с поведением по юз кейсно, с помощью трейтов и тайп классов. Если язык не поддерживает тайп классы и трейты, но поддерживает экстеншн функции, то на них, я думаю, можно будет смастерить чё-нить юзабельное. Я думаю это может стать хорошей техникой реализации юз кейсов и логики.

## Адекватная архитектура

В адекватной архитектуре программа рассматривается как набор юз кейсов, которые состоят из следующих частей:
1) Платформа
2) Порты
3) Адаптеры
4) Юз кейс
5) Логика

![Устройство юз кейса](images/aa-use-case.JPG)

### Платформа

В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт.

### Порты

Порт является точкой входа в функцию системы. Его задача - принять вызов, при необходимости сконвертировать входные данные, при необходимости, создать юз кейс, передать в него управление и вернуть результат, при необходимости снова сконвертировав его. В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.

В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат. При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции). Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.

В некоторых случая на один юз кейс может быть несколько портов, которые переводят управление на разные этапы юзкейса.

### Юз кейсы

Главной задачей юз кейса явлется предельно ясное описание юз кейса, без низкоуровневых деталей и сложной логики. Объекты юз кейсов хранят необходимое состояние и связывают адаптеры с логикой. В юз кейсах так же запрещено использование иф-ов и прочих конструкций управления потоком выполнения, за исключением RO - конструкции вида `if (error) return ErrorData` допустимы. Для обхода этого ограничения можно использовать DSLи:) Так же юз кейсы могут обращаться к другим юз кейсам.

Для многошаговых юз кейсов с несколькими портами, мне кажется, может быть возможность их красиво и читаемо оформить в последовательность шагов в одном блоке. Но эту идею я ещё не изучал.

#### Персистентные юз кейсы

В случае когда юз кейс состоит из нескольких шагов, которые инициируются различными событиями во внешней среде, юз кейс может быть сохранён в кэше или в некотором постоянном хранилище в случае распределённой среде. В этом случае порты юз кейса должны будут создавать, сохранять и загружать объекты юз кейсов. Так же в этом случае стоит подумать о синхронизации доступа к объектам юз кейсов.

#### Взаимодействующие с гуём (диалог подтверждения операции)
To do

### Адаптеры

Единственной задачей адаптеров является инкапсуляция ввода-вывода. Эти единственные компоненты, которым разрешено обращаться к платформе (порты вызываются платформой и ничего о ней не знают). В адаптерах так же как и в портах и из кейсах запрещено использовать управляющие конструкции. Если атомарная с точки зрения операция ввода-вывода требует логики, то эту логику можно либо завернуть в DSL или оформить её как отдельный юз кейс, но это уже будет юз кейс платформы, а не вашей системы.

Наконец поясню смысл запрета на логику в потрах, юз кейсах и адаптерах. Дело в том что все они транзитивно зависят от платформы и ввода-вывода.

Ввод-вывод, в принципе, можно замокать, но я считаю моки плохой практикой. В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга. Плюс они совершенно ничего не говорят о работоспособности вашего кода в реальных условиях.

Так вот если порты, юз кейсы и адаптеры будут простые, то их достаточно будет покрыть минимальным набором интеграционных тестов, для того чтобы быть в них уверенными.

### Логика

Наконец Логика. Она же Бизнес-Логика, она же домен, она же бизнес-правила. Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения. Но тут есть другое ограничение - логика должны быть чистой в функциональном плане, то есть не иметь наблюдаемых сайд эффектов.

Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д. Нет, всего этого не надо. Любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за. Да же исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них. Ну и да логгирование тоже можно, если оно не является публичной функцией вашей системы. Вобщем, одно правило - каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.

Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами. Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его нельзя, поэтому единственный вариант - исключить его.

Так же для организации реализации логики я советую присмотреться к идеи DCI. Но сам я ещё не опробовал этот подход в боевых условиях.

### Общие правила

#### У класса может быть не более 3 зависимостей
Ну максимум 5:) Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию). Обращение к синглтонам откуда-либо помимо платформы запрещено категорически. Если вашему классу требуется более 3 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.

## Послабления

Ни одно из приведённых правил не является догмой и не приведёт к концу света в случае нарушения. Но правила лучше нарушать осознанно - понимая почему в это делаете и к каким последствиям приведёт (или не приведёт) нарушение.

## Применимость
To do
 - ГУЙ
 - Низкоуровневое прграммирование
 - Встраиваемая БД
 - микросервисы
 - консольный уй
 - рекативность
 - Плагины билд систем
 - Распределённые кластеры
 - Отчёты тредс
 - Факторизация кубита

## Заключение
