# Чистые и грязные функции, эффекты и обработка сигналов, сайдэффекты: эффекты и сигналы

*Привет!*
*Сегодня подготовил вам лонгрид на 1.5К слов*
*Если вы думаете, что его будет долго читать, то представьте, сколько его было писать:) 6 часов, я замерял:)*
*Пока не уверен, но возможно это потому, что в этом посте изложен Самый Главный Принцип [Эргономичного Подхода](https://github.com/d-r-q/developing-ergonomic-code/blob/master/book-rus/developing-ergonomic-code.adoc), и на данный момент если бы меня спросили какой один пост из канала прочитать - я бы назвал этот:)*
*Поэтому прошу вас найти силы и время на то, чтобы его осилить и дать обратную связь:) - в этот раз она особенно важна для меня*

Начало [здесь](https://telegra.ph/CHistye-funkcii-ehffekty-i-sajdehffekty-01-05) и [здесь](https://telegra.ph/CHistye-i-gryaznye-funkcii-ehffekty-i-obrabotka-signalov-sajdehffekty-chistye-funkcii-01-12).

Сегодня расскажу о том, что я понимаю под эффектами и обработкой сигналов.

## Что я понимаю под сигналами и эффектами

Сейчас у меня и терминология, и определения кривоватые, но кажется суть передают и у меня в голове укладываются в более-менее стройную картину:)
Что не понятно - спрашивайте в комментах, постараюсь понятнее/точнее объяснить.

**Обработка сигнала** - акт чтения глобальной изменяемой памяти.

**Отправка сигнала** - акт записи глобальной изменяемой памяти.

**Глобальная изменяемая память** - область памяти, на которую в момент чтения/записи замаплено изменяемое поле объекта или структуры, достижимого из GC root.

**Эффект** - операция отправки или обработки сигнала.
Является подмножеством понятия побочный эффект, часто встречаемого в литературе.

> Примечание
>
> Термин обработка/отправка сигнала мне самому не очень нравится, но он не лишён смысла.
Если рассматривать ввод/вывод, то даже то, что на поверхности выглядит синхронным, на деле асинхронное и внутри вызова read содержит обработка сигнала (прерывания) "данные готовы".
А вызов write - это собственно отправка сигнала на запись устройству вывода.
Глобальные переменные тоже можно за уши натянуть на эту терминологию - если вы читаете изменяемую переменную, то ожидаете, что кто-то её предварительно записал, тем самым послав вам сигнал.

Проще говоря обработка/отправка сигнала - это чтение/запись переменной объявленной вне области видимости текущей функции.
Подчеркну, что в этом смысле буфферы ввода/вывода так же являются изменяемыми переменными.

## Это всё ради эффектов

А теперь сюрприз-сюрприз - мы пишем программы ради эффектов.
Конечному пользователю (в лице QA и продакта:) ) пофиг на технологии, архитектуру, крутые алгоритмы и стиль кода.
Всё что он может сделать - это отправить сигнал (который будет обработан программой) и обработать сигнал (отправленный программой) полученный в ответ.
Т.е. какие-бы то ни было суждения о программе пользователь может делать только на основании эффектов её исполнения.

И в тест-планах - всегда есть шаги (набор сигналов для отправки) и ожидаемый результат (набор сигналов для проверки).
А в случае информационных систем 90-99% тест кейсов не содержат сложных правил по проверке ожидаемого результата, ожидаемый результат бинарный - логин удался или нет, введёная строка появилась в нужном месте или нет.

То есть именно на основании эффектов конечный пользователь (в лице QA или продакта:) ) будет принимать решение о том сделал программист свою работу или "всё говно, переделывай".

И при такой критичной важности Эффектов для работы программиста, абсолютно во всех проектах, которые я видел за 16 лет карьеры, они находятся в слепой зоне и мало кто осознано подходит к управлению ими.
Жирновато конечно, на скажу: это можно переиначить как "ни разу не видел осознанного подхода к своей работе".
Чёт написал и сам охерел от такой предъявы, так что малёха снижу градус: сам я тоже не будда просветлённый и осознанным подходом пока не отличаюсь:)
И теперь можно ещё пожестить: игнорирование эффектов - это игнорирование интересов конечного пользователя:)

Осознанное управление эффектами, это когда программист пишущий условный `print` или `db.save` держит в голове "а сейчас я программирую вот такой-то эффект, в ответ на получение вот такого сигнала для удовлетворения пункта 5.2.52 требований".

Управление эффектами - неотъемлемая часть [моего Эргономичного Подхода](https://github.com/d-r-q/developing-ergonomic-code/blob/master/book-rus/developing-ergonomic-code.adoc) и обязательная характеристика эргономичного кода.

А неосознанная генерация эффектов налево и направо ведёт к куче проблем, которые я видел абсолютно во всех проектах за 16 лет карьеры (пока не начал разрабатывать Эргономичный Подход:) ).

## Это всё из-за эффектов

### ВременнАя связность

> Примечание
>
> Это капец, товарищи!
> На это понятие на русском ваще ничего нагуглить не могу, в русской вики его вообще нет, а в английской, он упоминается мелким пунктом где-то в середине.
> При том что сама википедия ставит его на второе место по "плохости".

Эффекты могут обладать неявной временнОй связностью (temporal coupling) между собой.
Это не в том смысле, что связность пропадает со временем, а в том смысле что, результат выполнения двух эффектов зависит от очерёдности их исполнения.
Например, рассмотрим такую программу:
![эффективный код](channel/ergo/drafts/210119-effects/img-1-mutable-buffer.png)
```kotlin
val buffer = StringBuilder()
buffer.append("a")
buffer.deleteCharAt(0)  
```
В этой программе вызов `deleteCharAt` зависит от вызова `append` и если их переупорядочить, то программа закрешится.
Здесь связь очевидна, но эти вызовы могут быть спрятаны внутри разных функций, внутри разных классов, внутри разных модулей.
И если вы их случайно переупорядочите во время рефакторинга в таких обстоятельствах - могу лишь пожелать удачи в ~бою~ дебаге.
Ну и чтобы баг нашли тесты, или хотя бы QA, а не пользователи.

Чистая же версия этого кода такая:
![чистый код](channel/ergo/drafts/210119-effects/img-2-immutable-buffer.png)
```kotlin
val emptyString = ""
val aString = emptyString + "a"
val clearedString = aString.substring(0, aString.length)
```
И здесь компилятор махом вам даст по рукам, если вы случайно поменяете эти строки руками.
В этой версии связь вызовов очевидна.

Речь тут идёт не только о памяти - работа с любым изменяемым хранилищем, вроде диска, СУБД, REST API, создаёт временнУю связность между кусками кода.

### Нелокальность рассуждений
Из-за временнОй связности теряется локальность рассуждений о программе.

Если вы работаете с кодом "неосознанного" проекта, то у вас объекты будут мутабельными.
И вы больше не можете свободно вызывать какие-либо методы передавая свой объект в качестве параметра, потому как в таком проекте с высокой долей вероятности вызываемой код так или иначе изменит ваш объект и далеко не факт, что так, как вам надо, а не иначе.

В результате передавая объект в чужой метод вы вынуждены "покинуть" метод над которым работаете, и пройтись по стэку вызовов, чтобы удостовериться, что там никто вам не изгадит ваш объект.
И дай вам бог, чтобы на вашем пути не встретились ~драконы~ полиморфные и рефлексивные вызовы:)
Наконец, если сейчас передача объекта безопасна, то не значит что завтра ваш коллега или вы сами не подложите себе свинью.

### Регрессии

Но положа руку на сердце, вы меняя код задумываетесь о том, как эти изменения повлияют на порядок эффектов, на какое состояние эти эффекты направлены, и какие ещё эффекты направлены на это состояние?
Прям каждый раз и прям тщательно всё изучая?
Я - нет.

В итоге я регулярно меняя одно место, ломаю другое.
Это ведёт к страху рефакторинга.
Это ведёт к загниваюнию кодовой базы и превращению её в [Big Ball of Mud](https://www.researchgate.net/publication/2938621_Big_Ball_of_Mud/link/54d4eb900cf2970e4e63e44d/download).

### Тестирование

С тестированием изменяемых объектов особых проблем не припоминаю.
Ну ток что с изменяемыми объектами зачастую идёт ток конструктор без параметров и пачка сеттеров - это не удобно, но можно полечить просто добавив конструктор.

А вот тестирования ввода-вывода - это да, беда.
Тестировать ио больно потому что такие тесты:
1. могут потребовать запуска внешнего сервиса (СУБД, например)
2. на [три-семь порядков](https://formulusblack.com/blog/compute-performance-distance-of-data-as-a-measure-of-latency/) медленнее тестов только в памяти
3. намного менее стабильны
4. вообще непонятно как писать для устройств отличных от диска и сетевой карты

Отсюда началась движуха про [тестовую пирамиду](https://martinfowler.com/articles/practical-test-pyramid.html) с тем, что львиная доля тестов должна быть юнит-тестами и про "давайте замочим всю систему".

Только оби этих практики ведут к тестам, которые ломаются при любом мало мальском рефакторинге.
Это ведёт к страху рефакторинга.
Это ведёт к загниванию кодовой базы и преваращению её в Big Ball of Mud (ссылка выше:) ).

И не понятно как это поможет ловить баги в системах ориентированных на ввод-вывод, где из логики ток валидация.

Но чёт я отвлёкся от темы, про тесты будет своя серия постов.

### Производительность

Опять же это касается только эффектов ио, т.к. они существенно медленнее работы с памятью.

Если у вас эффекты раскиданы по коду произвольным образом, вы можете засунуть чтение одних и тех же данны с диска в цикл на 1000 итераций.

Или словить печально известную [проблему N+1](https://habr.com/ru/company/otus/blog/529692/) и даже не заметить этого, пока количество таких проблем не станет столь большим, что у вас вся система начнёт еле ворочиться.

Или случайно через полиморфный вызов засунуть сетевой вызов внутрь транзакции БД.
После того как уже захватили пачку локов.

Все эти проблемы опять же вызваны нелокальностью рассуждений, если в кодовой базе нет дисциплины в работе с эффектами, то они могут стрельнуть где угодно.
А просматривать стэк каждого вызова - замучаешься.
Да и если сегодня вызов чистый, без дисциплины нет гарантий, что завтра он не станет эффективным.

### Конкурентное программирование

Если у вас есть эффекты, то их надо упорядочивать, а для этого надо идти в конкурентное программирование.
А это очень сложно, поверьте мне на слово, если ещё сами не убедились в этом на своём опыте:)

Чистый же код можно спокойно параллелить как угодно и вообще не греть голову об этом.

### Кэширование

Ну и опять же с эффектами [появляется одна из двух самых сложных задач в программировании](https://martinfowler.com/bliki/TwoHardThings.html).
После конкурентности, конечно :)

---

В итоге мы пришли к Дилемме Эффеков - без эффектов никак, а с эффектами ещё хуже.
Как же быть?
Для начала, надо присмотреться к эффектам поближе.

## Эффекты бывают разные

Из списка проблем вызываемых эффектами видно, что есть два типа эффектов:
1. работа с глобальным изменяемыми состоянием (измененяемым переменными)
2. ввод/вывод

На самом деле, это одно и тоже, потому что ввод/вывод начинается с работы с изменяемыми блоками памяти и в конечном итоге заканчивается там же, но между ними есть существенная разница - минимизировать ио без минимизации функциональности системы для конечного пользователя - нельзя, а вот минимизировать изменяемое состояние без потерь для конечного пользователя - можно.

В программах ориентированных на вычисления (компиляторы, например) количество изменяемого состояния можно свести к нулю.

В программах ориентированных на хранение данных (90% бэков) в принципе можно свести изменяемое состояние к одной переменной (ссылке на неизменяемую структуру данных)- см. [Redux](https://redux.js.org/) и [Datomic](https://www.datomic.com/). И [qbit](https://github.com/d-r-q/qbit/) - примажусь к известным и популярным:)

## Разрешение Дилеммы Эффектов

Для разрешения Дилеммы Эффектов Эргономичный Подход Сводит К Минимуму Количество Эффектов В Программе За Счёт (*ой, что-то я с Очень Важными Словами переборщил:)*) минимизации изменяемого состояния, а оставшиеся эффекты берёт под контроль за счёт дисциплины и ряда других техник, о которых я напишу позже.

Если же вы не берёте контроль над эффектами, то в вашем коде начинают появляться грязные и побочные функции - идеальная среда для багов - и это тема нашего следующего поста:)
