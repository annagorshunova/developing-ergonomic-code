# Чистые и грязные функции, эффекты и обработка сигналов, сайдэффекты: эффекты и сигналы

*Привет!*
*Сегодня подготовил вам лонгрид на 1.5К строк*
*Если вы думаете, что его будет долго читать, то представьте, сколько его было писать:) 6 часов, я замерял:)*
*Пока не уверен, но возможно это потому, что в этом посте изложен Самый Главный Принцип [Эргономичного Подхода](https://github.com/d-r-q/developing-ergonomic-code/), и на данный момент если бы меня спросили какой один пост из канала прочитать - я бы назвал этот:)*
*Поэтому прошу вас найти силы и время на то, чтобы его осилить и дать обратную связь:)*

Сегодня расскажу о том, что я понимаю под эффектами и обработкой сигналов.

## Что я понимаю под сигналами и эффектами

Сейчас у меня и терминология, и определения кривоватые, но кажется суть передают и у меня в голове укладываются в более-менее стройную картину:)
Что не понятно - спрашивайте в комментах, постараюсь понятнее/точнее объяснить.

**Обработка сигнала** - акт чтения глобальной изменяемой памяти.

**Отправка сигнала** - акт записи локальной изменяемой памяти.

**Глобальная изменяемая память** - область памяти, на которую в момент чтения/записи замаплено изменяемое поле объекта или структуры, достижимого из GC root.

**Эффект** - операция отправки или обработки сигнала.

> Примечание
>
> Термин обработка/отправка сигнала мне самому не очень нравится, но он не лишён смысла.
Если рассматривать ввод/вывод, то даже то, что на поверхности выглядит синхронным, на деле асинхронное и внутри вызова read есть обработка сигнала "данные готовы".
А вызов write - это собственно отправка сигнала на запись устройству вывода.
Глобальные переменные тоже можно за уши натянуть на эту терминологию - если вы читаете изменяемую переменную, то ожидаете, что кто-то её предварительно записал, тем самым послав вам сигнал.

Проще говоря обработка/отправка сигнала - это чтение/запись переменной объявленной вне области видимости текущей функции.
Подчеркну, что в этом смысле буфферы ввода/вывода так же являются изменяемыми переменными.

## Это всё ради эффектов

А теперь сюрприз-сюрприз - мы пишем программы ради эффектов.
Конечному пользователю (в лице QA и продакта:) ) пофиг на технологии, архитектуру, крутые алгоритмы и стиль кода.
Всё что он может сделать - это отправить сигнал (который будет обработан программой) и обработать сигнал (отправленный программой) полученный в ответ.
Т.е. какие-бы то ни было суждения о программе пользователь может делать только на основании эффектов её исполнения.

И в тест-планах - всегда есть шаги (набор сигналов для отправки) и ожидаемый результат (набор сигналов для проверки).
А в случае информационных систем процентов 90-99 тест кейсов не содержат сложных правил по проверке ожидаемого результата, ожидаемый результат бинарный - логин удался или нет, введёная строка появилась в нужном месте или нет.

То есть именно на основании эффектов конечный пользователь (в лице QA или продакта:) ) будет принимать решение о том сделал программист свою работу или "всё говно, переделывай".

И при такой фатальной для работы программиста важности Эффектов, в мейнстримном программировании они находятся в слепой зоне и мало кто осознано подходить к управлению ими.
Жирновато конечно, на скажу: это можно переиначить как "мало кто подходит осознано к своей работе".
Чёт написал и сам охерел от такой предъявы, так что малёха снижу градус: себя я пока что не причисляю к "осознанным" программистам:)
И теперь можно ещё пожестить: игнорирование эффектов - это игнорирование интересов конечного пользователя:)

Осознанное управление эффектами, это когда программист пишущий условный `print` или `db.save` держит в голове "а сейчас я программирую вот такой-то эффект, в ответ на получение вот такого сигнала для удовлетворения пункта 5.2.52 требований

Управление эффектами - неотъемлемая часть Эргономичного подхода и обязательная характеристика эргономичного кода.

А неосознанная генерация эффектов на лево и на право ведёт к куче проблем, которые я встречал во всех проектах за 16 лет карьеры (пока не начал разрабатывать Эргономичный подход:) ).

## Это всё из-за эффектов

### ВременнАя связность

> Примечание
>
> Это капец, товарищи!
> На это понятие на русском ваще ничего нагуглить не могу, в русской вики его вообще нет, а в английской, он упоминается мелким пунктом где-то в середине.
> При том что сама википедия ставит его на второе место по "плохости".

Эффекты могут обладать неявной временнОй связностью (temporal coupling) между собой.
Это не в том смысле, что связность пропадает со временем, а в том смысле что, результат выполнения двух эффектов зависит от очерёдности их исполнения.
Например, рассмотрим такую программу:
![эффективный код](channel/ergo/drafts/210119-effects/img-1-mutable-buffer.png)
```kotlin
val buffer = StringBuilder()
buffer.append("a")
buffer.deleteCharAt(0)  
```
В этой программе вызов `deleteCharAt` зависит от вызова `append` и если их переупорядочить, то программа закрешится.
Здесь связь очевидна, но эти вызовы могут быть спрятаны внутри других функций, внутри других классов, внутри других модулей.
И если вы их во время случайного рефакторинга переупорядочите в этом случае - могу лишь пожелать удачи в ~бою~ дебаге.

Чистая же версия этого кода такая:
![чистый код](channel/ergo/drafts/210119-effects/img-2-immutable-buffer.png)
```kotlin
val emptyString = ""
val aString = emptyString + "a"
val clearedString = aString.substring(0, aString.length)
```
И здесь компилятор махом вам даст по рукам, если вы случайно поменяете эти строки руками.
В этой версии связь вызовов очевидна.

### Нелокальность рассуждений
Из-за временнОй связности теряется локальность рассуждений о программе.

Если вы работаете с кодом "неосознанного" проекта, то у вас объекты будут мутабельными.
И вы больше не можете свободно вызывать какие-либо методы передавая свой объект в качестве параметра, потому как в таком проекте с высокой долей вероятности вызываемой код так или иначе изменит ваш объект и далеко не факт, что так, как вам надо, а не иначе.

В результате передавая объект в другой метод вы вынуждены "покинуть" метод над которым работаете, и пройтись по стэку вызовов, чтобы удоствериться, что там никто вам не изгадит ваш объект.
И дай вам бог, чтобы на вашем пути не встретились ~драконы~ полиморфные и рефлексивные вызовы:)

### Регрессии

Но положа руку на сердце, вы меняя код задумываетесь о том, как эти изменения повлияют на порядок эффектов, на какое состояние эти эффекты направлены, и какие ещё эффекты направлены на это состояние? Прям каждый раз и прям тщятельно всё изучая? Я - нет.

В итоге я регулярно меняя одно место, ломаю другое.
Это ведёт к страху рефакторинга.
Это ведёт к загниваюнию кодовой базы и превращения её в [Big Ball of Mud](https://www.researchgate.net/publication/2938621_Big_Ball_of_Mud/link/54d4eb900cf2970e4e63e44d/download).

### Тестирование

С тестированием изменяемых объектов особых проблем не припоминаю.
Ну ток что с изменяемыми объектами зачастую идёт ток конструктор без параметров и пачка сеттеров - это не удобно, но можно полечить ток добавив конструктор.

А вот тестирования ввода-вывода - это да.
Тестировать ио больно потому что такие тесты:
1. могут потребовать запуска внешнего сервиса (СУБД, например)
2. на несколько медленнее тестов только в памяти
3. намного менее стабильны
4. вообще непонятно как писать для устройств отличных от диска и сетевой карты

Отсюда началась движуха про [тестовую пирамиду](https://martinfowler.com/articles/practical-test-pyramid.html) с тем, что львиная доля тестов должна быть юнит-тестами и про "давайте замочим всю систему".

Только оби этих практики ведут к тестам, которые ломаются при любом мало мальском рефакторинге.
Это ведёт к страху рефакторинга.
Это ведёт к загниванию кодовой базы и преваращению её в Big Ball of Mud (ссылка выше:) ).

Но чёт я отвлёкся от темы, про тесты будет своя серия постов.

### Производительность

Опять же это касается только эффектов ио, т.к. они на [три-семь](https://formulusblack.com/blog/compute-performance-distance-of-data-as-a-measure-of-latency/) порядков медленее работы с памятью.

И если у вас эффекты раскиданы рандомно по коду, вы можете засунуть чтение одних и тех же данны с диска в цикле.

Или словить печально известную [проблему N+1](https://habr.com/ru/company/otus/blog/529692/) и даже не заметить этого, пока количество таких проблем не станет столь большим, что у вас вся система начнёт еле ворочиться.

Или случайно через полиморфный вызов засунуть сетевой вызов внутрь транзакции БД.

Все эти проблемы опять же вызваны нелокальностью рассуждений, если в кодовой базе нет дисциплины в работе с эффектами, то они могут стрельнуть где угодно.
А просматривать стэк каждого вызова - замучаешься.
Да и если сегодня вызов чистый, без дисцпилины нет гарантий, что завтра он не станет эффективным.

### Конкаренси

Если у вас есть эффекты, то их надо упорядочивать, а для этого надо идти в конкуррентное программирование.
А это очень сложно, поверьте мне на слово, если ещё не убедились в этом на своём опыте:)

А чистый код можно спокойно параллелить как угодно и вообще не греть голову об этом.

### Кэширование

Ну и опять же с эффектами [появляется одна из двух самых сложных задач в программировании](https://martinfowler.com/bliki/TwoHardThings.html).
После канкаренси, конечно :)

---

В итоге мы пришли к Дилемме Эффеков - без эффектов никак, а с эффектами ещё хуже.
Как же быть?
Для начала, надо присмотреться к эффектам поближе.

## Эффекты бывают разные

Из списка проблем вызываемых эффектами, видно, что есть два типа эффектов:
1. Работа с глобальным изменяемыми состоянием (измененяемым переменными);
2. Ввод/вывод.

На самом деле, это одно и тоже, потому что ввод/вывод начинается с работы с изменяемыми блоками памяти и в конечно итоге заканчивается там же, но есть существенная деталь - минимизировать ио без минимизации функциональности системы - нельзя, а вот минимизировать изменяемое состояние - можно.

В программах ориентированных на вычисления (компиляторы, например) количество таких эффектов можно свести к нулю.

В программах ориентированных на хранение данных (90% бэков) в принципе можно свести изменяемое состояние к одной переменной (ссылке на не изменяемую структуру данных)- см. [Redux](https://redux.js.org/) и [Datomic](https://www.datomic.com/).

## Разрешение Дилеммы Эффектов

Для разрешения Дилеммы Эффектов, Эргономичный Подход сводит к минимуму количество эффектов в программе за счёт минимизации изменяемого состояния, а оставшиеся эффекты берёт под контроль за счёт дисциплины и ряда других техник, о которых я напишу позже.
