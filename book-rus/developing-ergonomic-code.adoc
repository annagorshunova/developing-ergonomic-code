= Разработка эргономичного кода (Черновик)
Алексей Жидков
Версия 0.0.1, 2020-02-29
:doctype: book
:toc:
:source-highlighter: pygments

toc::[]

= Техническая глава

== Работа не завершена

Этот материал, который пока что скорее является серией статей и заметок находится в разработке.
Я надеюсь, что со временем, он превратится в книгу о том, как разрабатывать "сатисфактори" проекты - проекты которые и разрабатывать приятно и использовать.
Разделы, которые я планирую включить в книгу, я пишу в "совершённом" времени - как будто они часть уже написанной книги.

На момент написания этого материала, я большую часть времени занимаю разработкой бэка на спринге, поэтому есть некоторый перекос в эту сторону.
Но за свою карьеру я участвовал в разработке проектов самых разных типов и изложенные идеи должны быть применимы в целом к разработке софта.
Со временем я обобщу изложенные идеи и приведу примеры их реализации в различных контекстах.

== To do

. Вставить диаграмму кубита, в качестве иллюстрации подхода к разбиению на пакеты
. Разобрать пример с отображением списка (списков дел), либо сообщение о пустом списке
.. Где должен быть этот иф? В юз кейсе или во вью?
.. Что вообще делать с этим ифом? Тащить его отдельно в логику кажется перебором.
. Выброс исключения - это эффект?
. Разбиение цикла между вью и юз кейсом
.. Забить
.. Обсёрвер
.. Возврат экшена в onXXX. Но что делать, если требуется возаимодействие - onDelete -> askConfirmation -> delete. Отдельные эвенты? Корутины?
... Примерно туда же - где должна быть логика запроса подтверждения удаления? В принципе её можно целиком во вью оставить, дёргая юз кейс только при подтверждении. Но Очевидно ли это?
. threads#bd5d4a4e, MessageServiceImpl#setMessageChannel
. Эвент != юз кейс. Эвент - атомарное действие вызываемое обычным событием (сообщением в традиционном ООП), юз кейс - сценарий достижения определённой цели, продвигаемый одним или более событием <<apx_talk_dci>>
. Habits <<apx_talk_dci>>
. Инклуды юз кейсов вредные, потому что теряют цель <<apx_talk_dci>>
. Дизайн - разделение стабильных и изменяющихся частей <<apx_talk_dci>>, <<apx_peop_uncle_bob>>
. Доменная модель должна быть стабильной <<apx_talk_dci>>, <<apx_peop_uncle_bob>>
. Традиционные сервисы - жирные DCI Roles?
. Peter Coad, object modelling in code (https://www.infoq.com/articles/domain-color-modeling/)
. Юз кейсы - идеально место для осмысленных комментов. Сейчас стандартный бэк - это в основном набор структур данных и пакетов процедур для манипуляции ими и логику описывать не где. Юз кейсы же кодом описывают связанные куски логики и этот код можно сдобрить хорошим комментом.
. Комменты и коммит мессаджи на русском. Глухой телефон в КБ информ. На английском в опенсорсе, забугорных заказчиках, между народных коммандах.
. Временные таблицы (таблицы с данными не входящими в доменную модель и из которых данные постоянно удаляются) - потенциально скрытые юз кейсы
. Юз кейсы - настоящие объекты, с настоящим состоянием и настоящей логикой и настоящей инкапсуляцией.
. Коплейн <<apx_peop_coplien>>: юнит тесты снижают качество кода
. Изучение домена: <<apx_peop_coplien>>, <<apx_book_ddd>>, <<apx_book_object_thinking>>
. Большинство ошибок находятся во взаимо действии <<apx_artc_seg>>
. "Чем раньше обнаружена ошибка, тем дешевле её исправить" - миф? <<apx_artc_seg>>
. "A proper book isn't just a collection of facts, it reflects cause and mission" <<apx_book_lean_arch>>
. "If we reflect the end user mental model in the code, we are more likely to have working software" <<apx_book_lean_arch>>
. Высокое качество достигается в первую очередь Очевидностью эффектов кода и во вторую покрытием тестами
. Динамическая вс статическая типизация
.. Типы Очевидны
.. Код проще исследовать
.. Типы исключат целый пласт ошибок
.. Юнит тесты не могут исключить те ошибки, которые исключают типы
. Архитекутра ОО-сиситема - протоптанные пути сообщений между объектами, <<apx_talk_dci_glimpse_of_rygve>>, 12:00
. Архитектура - результат дизайна. Дизайн - акт решения проблемы Проблема - разници между имеющимся положением дел и желаемым <<apx_book_lean_arch>>
. Сервисы в ДДД - это роли в ДэЦэИ. "Some of these are intrinsically activities or actions, not things, but since our modeling paradigm is objects, we try to fit them into objects anyway..." <<apx_book_ddd>>
. Инфраструктурные, доменные и прикладные сервисы из ддд - это адаптеры, бизнес-логика и юзкейсы из эрго.
. https://www.ozon.ru/context/detail/id/5430638/
. http://se.ethz.ch/~meyer/publications/functional/meyer_functional_oo.pdf
. https://github.com/jcoplien/trygve
. http://fulloo.info/Documents/trygve/trygve1.html
. Определение хорошейго описания проблемы <<apx_book_lean_arch>>, p. 70
. Добавить вставки с техниками как в <<apx_book_lean_arch>>?
. "Localizing change lowers cost and makes programming more fun", <<apx_book_lean_arch>>, p. 102
. "while modules have a necessary relationship to business semantics", <<apx_book_lean_arch>>, p. xxx
. "Architecture is more art than sience", <<apx_book_lean_arch>>, p. 117
. https://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697
. https://www.youtube.com/watch?v=Nsjsiz2A9mg
.. Arch is about intent, 10:30
. Софт общего назначения не должен зависить от софта спец назначения <<apx_book_lean_arch>>, p. 176
. Habits из <<apx_book_lean_arch>> - юз кейсы подсистем?
.. "Habits tend to be partial orderings of steps, and can represent business rules, algorithms, or steps in a use case" <<apx_book_lean_arch>>, p. 184
.. "Habits should not have variations" <<apx_book_lean_arch>>, p. 184
. "It's common to separate out business rules and other supporting details from use case descriptions", <<apx_book_lean_arch>>, p. 183
. Эффекты можно описывать пост-условиями
. if considered harmful
. В случае гуя юз кесйы должны быть в гуе? Что делать с многопользовательскими юзкейсами (Запрос/апрув блокировки)?
. Переходы между разделами/главами
. Баги видны только через эффекты
. алиасы + персональные менеджеры
. Patterns of Software - habitability


= Введение

== Мотивация

Начинается новый рабочий день.
Вы приходите на работу или натягиваете рабочие штаны, если повезло работать из дома.
В багтрекере на вас назначена новая задача.
Или эта задача висит уже несколько дней или даже недель.
Её надо делать, но тут вы понимаете, что ещё важнее налить кофе.
Идёте наливать кофе, если вам "повезло" курить, то заодно можно и покурить.
Если вам "повезло" работать в офисе, то в курилке цепляетесь языками с коллегой.
Так прошёл час и вы возвращаетесь к компьютеру.
Но вспоминаете, что не проверили почту!
Идём проверять почту.
Так почта, проверена, но чего-то ещё не хватает.
А, точно, новости!
Ну и кофе кончился, да и час прошёл, покурить ещё раз можно.
Обязательно индустриальные, не шоубиз или политика какая.
Прошёл ещё час.
В принципе уже и пообедать можно.
А после обеда покурить - святое дело.
Да и кофе остыл, надо новый налить.
Ещё час.
Скоро стендап, там надо будет что-то говорить, надо уже таки наконец пытаться начинать пытаться что-то как-то делать...

Знакомая ситуация?
Мне - да.
У меня так бывает когда я боюсь делать задачу, потому что практика показывает, что любая правка вносит два бага в самых разных и неожиданных местах.
Или второй вариант - не понятно даже не то, как работает тот код куда, надо вносить правки, непонятно даже где этот самый код и как его искать.
А единственный человек который это знал уволился пару месяцев назад.

Я профессионально занимаюсь программированием с 2004 года.
За это время я поработал в пятнадцати командах и больше двадцати проектах.
Это были очень разные проекты - от встроенных систем до биг даты, с командой от одного до двадцати пяти человек, гринфилд проекты и проекты корнями уходящие в 80-ые годы.
Одно объединяло все эти проекты - в каждом из них хотя бы раз был день из первого абзаца.

Для меня разработка софта это не способ поменять N единиц времени на K единиц денег.
Для меня разработка софта явлется основной областью интересов.
Поэтому я много часов (возможно те самые десять тысяч) провёл в поисках ответов на вопросы "Почему весь нетривиальный софт так сложно понимать и так страшно менять?" и "Как делать софт, котрый легко понимать и безопасно менять?".

И в результате я пришёл к выводу, что все эти проекты объединяли скрытые связи в коде.
Именно скрытые связи делают код и хрупким и сложным для понимания.
Скрытые связи невозможно исключить полностью, поэтому "эти дни" - я это часть нашей профессии, а умение работать в такие дни - часть профессионализма.
Но скрытые связи можно максимально проявить и свести количество "этих дней" к минимуму.

В этой книге я привожу концептуальную модель софта и набор практик разработки, которые:
. Делают Очевидным то, какие функции выполняет софт
. Делает Очевидным то, что является входом и выходом каждой функции, выполняемой софтом
. Делает Тестируемым то, что невозможно сделать Очевидным в силу его естественной сложности

Благодаря этому, становится намного проще понять, куда именно необходимо вносить те или иные правки и каковы будут их последствия.
А для сложных частей кода можно быть уверенным в тестах.

Главной мотивацией к написанию этой книги было структурирование собственных мыслей о том, как писать эргономичный код.
Кроме того, мне требовалось руководство разработчика в командах, которыми управляю я сам, и как референсный (#todo: корректное слово#) материал в предложениях по улучшению кода и архитектуры в командах, в которых политику разработки определяют другие люди.

Кроме того я уже много лет преподаю различные курсы по программированию и просто довольно много взаимодействую с молодыми программистами.
И в последнее время я начал уставать от пересказа одних и тех же идей по нескольку раз в год и с этой книгой у меня есть единое и "консистентное" (#todo: перевести на русский#) место, куда можно отсылать учеников.

Я пишу эту книгу с очень амбициозной целью - создать новый стандарт де факто разработки коммерческих приложений.
Стандарт, который сделает софт эргономичным не только для конченого пользователя, но я для разработчика.

== Что такое эргономичный код?

(#todo: попровить шрифт цитат#)

Что же такое эргономичный код?
Для начала рассмотрим несколько определений термина "эргономичность" в общем смысле, а потом адаптируем их к коду:
[quote, Большой толковый словарь русского языка]
____
Эргономичность - наличие условий, возможностей для лёгкого, приятного, необременительного пользования чем-либо или удовлетворения каких-либо нужд, потребностей
____

[quote, ISO/IEC 25010]
____
Эргономичность - способность продукта быть понимаемым, изучаемым, используемым и привлекательным для пользователя в заданных условиях
____

[quote, Краткий толковый словарь по полиграфии]
____
Эргономичность - дизайн оборудования, учитывающий взаимодействие человек/машина, позволяющий снизить вероятность ошибки оператора, повысить комфортность условий его работы.
____

[quote, dic.academic.ru]
____
Эргономичность - в изначальном смысле это эффективность инструмента производства или системы в эргономике. Под эффективностью при этом понимается наибольшая производительность при наименьшей вероятности ошибки (пользователя но не устройства). Ныне термин употребляется в более широком смысле, обозначая общую степень удобства предмета (не обязательно средства производства), экономию времени и энергии при использовании предмета. Например: «эргономичный токарный станок», «эргономичный электромобиль» или даже «эргономичный стул».
____

В нашем случае, понятно, пользователем/оператором/человеком будет программист, чем-либо/продуктом/оборудованием/инструментом производства будет код, а пользованием/использованием будет внесение модификаций (включая добавление нового кода) в существующий код.
В первой цитате, мне (как "пользователю" кода) нравятся характеристики "лёгкий и приятный в использовании";
В второй цитате, мне нравятся характеристики "понимаемый и изучаемый";
В третьей цитате, мне нравится характеристика "снижающий вероятность ошибки";
Наконец, в четвёртой цитате (помимо уже упомянутой вероятности ошибки) мне нравится характеристика "наибольшая производительность".

Объединив все эти характеристики, получаем следующее определение:
[quote, Алексей Жидков, Разработка эргономичного кода]
____
Эргономичный код - это код, обеспечивающий наибольшую производительность программиста, за счёт простоты понимания и изучения, снижения вероятности внесения ошибки при модификации. Понятный и защищённый от внесения ошибок код, в свою очередь становится лёгким и приятным для внесения изменений.
____

Важно понимать, что создание эргономичной вещи требует намного больше усилий, чем создание просто вещи.
Поэтому эта книга не о том, как сделать вашу жизнь лёгкой сегодня, эта книга о том, какие усилия надо приложить сегодня, чтобы сделать вашу жизнь лёгкой завтра.

Что же делает код эргономичным?
Явность (#todo: перевести на русский#) связей и надёжный набор автоматизированных тестов.
Тому что это значит и как этого достичь посвящена вся оставшаяся часть книги.

== Как появляются скрытые связи?

Скрытые связи появляются в коде всякий раз, когда вы обращаетесь к куче (глобальной памяти).
(#todo: исключения записать в эффекты?#)
(#todo: менеджед языки уменьшают кол-во скрытых связей?#)

// В этом разделе на потребуется понятие побочного эффекта (далее просто Эффект):
// [quote, https://ru.wikipedia.org]
// ____
// Любые действия работающей программы, изменяющие среду выполнения.
// ____
//
// Наиболее простым и понятным примером Эффекта является запись в файл.
// Немного более сложным для признания примером является чтение из файла.
//
// Единственным (#todo: точно?#) источником скрытых связей являются побочные эффекты (далее просто эффекты).


(#todo: втф в секунду#)

== Базовые идеи

(#todo: сделать факт-чекинг#)

Принципиально новых идей в эргономичном подходе нет и его главной контрибуией (#todo: перевод#) является сбор в одном месте и подгонка друг к другу идей из различных сообществ - в первую очередь объектно-ориентированного и функционального.

. Layered architecture
. Hexagonal/Onion/Clean architecture
. Data, Context, interaction architecture
. Domain Driven Design
. Simple Made Easy
. Functional core, imperative shell
. Railway oriented programming

Давайте бегло рассмотрим эти идеи подчеркнув что роднит эргономичный подход с ними, а что отличает (#todo: поправить стиль#).
Начнём с идей из ОО-лагеря, потому что эргономичный подход это скорее ОО-подход с элементами ФП, нежели наоборот.

=== Layered architecture
https://dzone.com/articles/layered-architecture-is-good[Layered architecture], https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0[слоистая архитектура]. (#todo: найти хоршие ссылки#)

(#todo: привести 100500ое описание слоёной архитектуры?#)

Эргономичный код нарезан в том числе и на слои.
Но в отличие от традиционной слоёной архитектуры, слои являются предпоследней гранулярностью (#todo: перевод#) нарезки, зачастую вырождающейся в нарезку на классы/объекты.
Плюс в отличие от многих версий слоёной архитектуры, слой доступа к данным (ввод-вывод) поднят на один уровень с бизнес-логикой.
Это сделано во имя "Очевидности и тестируемости":
- Благодаря обращению к инфраструктурному слою напрямую из слоя приложения, становится Очевидно какие эффекты имеет функция
- Благодаря удалению зависимости слоя бизнес-логики (где обычно находится вся сложность приложения) от слоя ввода-вывода, бизнес-логика становится Тестируемой.

=== Hexagonal (Ports&Adapters) architecture, Clean architecture, Onion architecture
- http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm[Оригинальная статья 2005 года о Hexagonal Architecture]
- https://habr.com/ru/post/267125/[описание на русском Hexagonal Architecture].
- https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/[Оригинальная серия статей об Onion Architecture]
- https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Оригинальная статья о Clean Architecture]
- https://habr.com/ru/company/mobileup/blog/335382/[Хорошее пояснение Clean Architecture на русском]
- https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164[Оригинальная книга о Clean Architecture]
- https://www.ozon.ru/context/detail/id/144499396/[Книга на русском о Clean Architecture]

Все эти три архитектуры (HOCA), на мой взгляд, являются вариациями разных авторов на одну и ту же тему.
По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.
И это основное что роднит эргономичный подход с HOCA.
Но способы достижения целей у нас разные.
HOCA предлагает вводить интерфейсы между логикой и вводом-выводом, что подразумевает активное использование моков в тестах.
А тестирование с моками - это тестирование реализации, а не контракта и оно ничего не говорит о поведении кода в бою.
Эргономичный же стиль предлагает реализовывать логику ввиде чистых функций, что, во-первых, делает невозможным сокрытие эффектов в дебрях логики и, во-вторых, позволяет тестировать контракт, а не реализацию и именно тот код, который будет работать в бою.

Так же HOCA утверждает, что способы взаимодействия с пользователем и хранения данных являются незначительными деталями.
Для того чтобы обеспечить лёгкость замены этих деталек, они предлагают по дефолту вводить интерфейсы между всеми слоями.
Я не разделяю мнение, что эти части являются незначительными деталями, поэтому в эргономичном подходе предлагаю не вводить лишних интерфейсов без реальной необходимости, потому что эти интерфейсы не бесплатны.

В целом, я разделяю идею HOCA о том, что фреймворки должны быть задвинуты на задворки приложения (на самый внешний слой).
Но если использование той или иной фичи фреймворка делает жизнь проще и не наносит ущерб Очевидности и Тестируемости, то я не вижу большого криминала в зависиомсти от фреймворка.
Например, я считаю необоснованной технику, по абстрагированию логики транзакций в шлюзе вместо использования спрингового @Transactional (#todo: ссылка на статю Маритна с примером#).

Наконец дядюшке Бобу над отдать должное за https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[Screaming architecture].
На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы.

=== Data, Context, Interaction Architecture
https://www.artima.com/articles/dci_vision.html[Оригинальная статья].

Эргономичный подход включает в себя DCI целиком в качестве устройства юз кейса по дефолту.
Но так же как и в случае HOCA, эргономичный подход делает акцент на вынесении эффектов в юз кейс (контекст в терминах DCI) и как следствие на чистоте бизнес-логики (ролей в терминах DCI).

В чём эргономичный подход слегка расходится с DCI, так это в вопросе логики в объектах доменной модели.
По DCI объекты должны быть "dumb, dumb, dumb", т.е. просто структурами данных.
В эргономичном же подходе, доменные объекты во-первых, должны быть иммутабельными, и, во-вторых, должны защищать свои инварианты.

=== Domain Driven Desing

У эргономичного подхода много общего с DDD.
Например сервисы приложений, домена и инфраструктуры из DDD ответствуют юз кейсам, бизнес логике и адаптерам из эргономичного подхода.

Но в отличие от DDD, в эргономичном подходе большая часть поведения уносится в роли DCI.
Это сделано потому что подход DDD (помещения максимальной части бизнес-логики в сущности) плохо масшатабируется - у одной сущности может быть много ролей, и если все их засунуть в один класс, то он станет слишком большим.
Кроме того анемичная модель является стандартом де факто в индустрии.

И так же как и в случае со всеми предыдущими идеями из ОО-сообщества, эргономичный подход в отличие от DDD делает акцент на чистых функциях.

На этом идеи ОО-лагеря закончены и переходим к ФП лагерю.

=== Simple Made Easy

https://www.infoq.com/presentations/Simple-Made-Easy/[Simple Made Easy], (https://tonsky.livejournal.com/243192.html[краткий пересказ на русском]).

На мой взгляд, Рич Хики - один из самых крутых чуваков в индустрии в наши дни.
А этот доклад - один из самых крутых докладов Рича Хики.

Именно этот доклад первым навёл меня на ключевую мысль эргономичного подхода - разделение эффектов и логики.
Кроме того в нём есть синхрония ((#todo: нормальное слово#)) в с DCI касательно, разделения структур данных и поведения.

Но я не разделяю мнение Хики о том, что типы бесполезны.
На мой взгляд, типы снимают целый класс проблем при модификации кода, и, что ещё важнее, делают существенный вклад в Очевидность кода.
Дополнительным плюсом является возможность создания эргономичных ИДЕ, что прекрасно ложиться на идею эргономичного кода.

Так же я не сторонник ядрёной функциональщины с абстракциями ультра высокого уровня.
Во-первых их сложно интернализировать ((#todo: перевод#)) до того уровня, чтобы код написанный с их помощью был Очевидным.
Во-вторых, они плохо поддерживаются большинством языков на которых пишется большинство программ.
В-третьих, они редко точно ложатся на предметную область.
В-четвёртых, многие из них созданы для обхода ограничений чистых функциональных языков, и этих ограничений нет в целевых языках эргономичного подхода.

=== Functional core, imperative shell (FCIS)
https://www.youtube.com/watch?v=yTkzNHF6rMs[Boundaries], версии на русском я не нашёл.

Идеи изложенные в этом докладе являются вторым краеугольным камнем эргономичного подхода.
Пересмотр этого доклада привёл меня к концептуальной модели эргономичного юз кейса, которая в итоге вылилась в данную книгу.
В эргономичный подход включены обе ключевые идеи этого доклада - разделение логики и эффектов и использование структур данных, передаваемых юз кейсами, в качестве интерфейса между логикой и адаптерами.

Эргономичный подход является надмножеством FCIS и дополняет его как более высокоуровневыми политиками, так и более низкоуровневыми механизмами.

=== Railway oriented programming
https://fsharpforfunandprofit.com/rop/[Оригинальная статья]

Серия статей о функциональном подходе к обработке ошибок.
Суть идеи в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса.

Это наиболее низкоуровневая из базовых идей, которая применяется на уровне конкретных методов.
Но её вклад в Очевидность настолько важен, что я включил её и в список базовых идей и концептуальную модель юз кейса.

Так же эргономичный подход включает идею того, что ошибки которые предполагают обработку лучше передавать в качестве возможного результата выполнения функции.
Исключения же лучше оставить для ошибок программирования и фатальных ошибок в адаптерах и платформе.

Но в отличие от чисто функционального подхода на монадах, предлагаемого в этой серии статей, я за использование банальных ифов раннего возврата там, где они работают хорошо.
А они работают хорошо в большинстве случаев.
Я выбираю ифы, потому что условие и действие явно прописанные в коде более Очевидные, тем map, который может отработать или нет в зависимости от типа ресивера (#todo: переписать по русски#).

На этом рассмотрение базовых идей завершено и можно переходить к сути книги.
Как я уже говорил, в основе эргономичного подхода лежит концептуальная модель и набор практик.
Концептуальная модель описана в главе "Проектирование".
Набор практик разделён на практики кодирования и тестирования, и каждый вид практик выделен в отдельную главу.
Так же, в приложении приведено множество примеров различных типов приложений в различных предметных областях, которые призваны помочь читателю связать изложенные идеи с каждодневными проблемами, возникающими при написании кода.

= Проектирование

[quote,]
[quote, IEEE1471 2007]
____
\... The fundamental organiztion of a system embodien in its components, their relationships to each oterh, and to the environment and the principles guiding its design and evolution
____

[quote, Booch 2006]
____
Architecture represents the significant design decisioins that shape a system, where significiant is measured by cost of change
____
[quote, Coplien, Lean Architecture]
____
the form of a system, where the word form has a special meainign that we'll explore a bit later. (p. 2)
____

[quote, Uncle Bob]
____
(#todo:#)
____
(#todo: <<apx_book_lean_arch>>, p. 80#)

== Анатомия системы? (#todo#)

== Анатомия приложения (#todo#)

== Анатомия юз кейса

(#todo: сделать подводку, что все беды от смешения логики и эффетов. Её видимо надо делать во введении#)

Самое важное, что необходимо сделать для Очевидизации (#todo: перевести на русский#) связей в приложении - это разделить нетривиальную логику и эффекты.
Для достижения этой цели, эргономичный подход рассматривает программу как набор юз кейсов, каждый из которых состоит из следующих частей:

- Платформа - базовый код обеспечивающий общение с внешним миром и универсальные сервисы;
- Порты - обработчики событий во внешнем, вызываемые платформой;
- Адаптеры - точки "выхода" из приложения, в которых сконцентирированы эффекты;
- Логика - "мозг" приложения, в котором содержится вся сложная логика;
- Юз кейс - "обединятор" (#todo: перевести на русский#) приложения, который отвечает за организацию потока данных между адаптерами и логикой.

image::images/aa-use-case.JPG[Устройство юз кейса]

=== Платформа

В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт с каким-то железом.

Если в вашем инфраструктуром коде есть какая-то логика, то ещё раз подумайте, там ли ей место.
Если место всё-таки там, то инфраструктур можно рассматривать как отдельную программу так же состоящую из юз кейсов и при менять к ней те же принципы, что и к верхне-уровневой программе, которая решает проблемы конечных пользователей.

=== Порты

Порт является точкой входа в функцию системы.
Его задача - принять вызов, сконвертировать входные данные и создать объекта юз кейса, передать в него управление и вернуть результат, снова сконвертировав его.
Конвертация входов/выходов и создание объектов юз кейсов опциональны - конвертацией может заниматься платформа, а юз кейс может быть инжектирован в порт, если у него нет состояния.
В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.
Порты инкапсулируют в себе логику регистрации методов в платформе и могут иметь аннотации специфичные для платформы и принимать на вход объекты классов, определённых в платформе.
Но обращение к методам платформы настоятельно не рекомендуется, а обращение к методам платформы, которые ведут к изменению состояния внешней среды запрещено.

[Note]
====
Далее для простоты я буду называть событиями все вызовы из платформы методов портов.
Так, в случае веб приложения вызов метода, назначенного на обработку запроса определённого URL будет событием "Поступление HTTP-запроса XXX", а вызов метода назначенного на исполнение с определённой периодичностью или в определённый момент времени будет событием "Срабатывание расписания (таймера) ХХХ".
События асинхронного ввода-вывода и события тулкита пользовательского интерфейса укладываются в этот термин естественным образом.
====

В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат.
При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции).
Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.

Порт может вызвать только один юз кейс.
Если вам надо вызвать два юз кейса, значит у вас есть составной юз кейс.

Зачастую у одного нетривиального юз кейса может быть несколько портов, которые переводят управление на разные этапы юз кейса.
Может быть и наоборот, несколько портов вызывают один и тот же юз кейс.
В этом случае, желательно, объединять их в одном классе.

(#todo: обобщить на случай юз кейсов подсистем, вызываемых из юз кейсов первичной системы#)

=== Адаптеры

Адаптеры делают программу живой для внешнего наблюдателя.
Сделать программу без адаптеров можно, но это будет чёрная дыра, которая просто всасывает ресурсы и ничего не выдаёт взамен.

Главной задачей адаптеров является исполнение Эффектов.
Поэтому это единственные компоненты, которым разрешено обращаться к Платформе.
Но как я писал ранее, разрешение на исполнение эффектов исключает сложную логику (#todo: стиль#)(#todo: привести критерии определения сложности логики#).

Именно в адаптерах берёт своё начало запрет на сложную логику, который транзитивно распространяется на юз кейсы и порты.
Дело в том, что уверенность при внесении изменений в сложную логику требует набора надёжных тестов.
А все эти компоненты транзитивно зависят от платформы и ввода-вывода, которые сложно привести к пред определённому состоянию и которые работают на порядки медленнее чистых функций.
Создать набор исчерпывающих тестов в таких условиях наверное возможно, теоретически, но на практике я ни разу такого не видел.

Что я часто видел на практике, так это замокивание ввода-вывода, но я считаю моки плохой практикой.
В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга.
Плюс тесты с использованием моков совершенно ничего не говорят о работоспособности вашего кода в бою.
Это приводит к тому, что либо эта логика не покрыта тестами которым можно доверять и её страшно менять, либо любое изменение этой логики требует существенно больших усилий на исправление тестов, которые сложно, скучно и не приятно делать.

Если же порты, юз кейсы и адаптеры простые, то их достаточно покрыть минимальным набором интеграционных и приёмочных тестов, для того чтобы быть уверенным в том, что система работает.

Но бывает так, что атомарная с точки зрения юз кейса операция требует логики. В этом случае эта операция является юз кейсом более низкоуровневой подсистемы, которая должна быть выявлена, названа, ограничена и оформлена в соответствии с правилами эргономичного подхода.

=== Логика

Логика. Она же предметная область, она же домен, она же Бизнес-Логика, она же бизнес-правила, она же домен.
Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения в остальных компонентах.
Но тут есть другое ограничение - логика должна быть чистой в функциональном смысле, то есть не иметь наблюдаемых сайд эффектов.

Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д.
Более того, я против того, чтобы все эти абстрактные термины фигурировали в коде.
Это детали реализации и они снижают отношение сигнал/шум и путают неинициированных, коих пока что большинство.
Поэтому если любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за.
Даже исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них.
Ну и да логгирование тоже можно, при условии, что оно не является функцией вашей системы, значимой для конечного пользователя.
Вобщем, при реализации логики надо следовать двум правилам:

. каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.
. функции и методы не должны менять глобальное состояние в ходе своей работы.
  Тут не много сложнее, поэтому поясню.
  Результат работы Логики должен быть целиком заключён в значении возвращаемом вызванной функции.
  Никаких записей на диск (по крайней мере значимых для пользователя и/или влияющих на дальнейшее функционирование системы), ни каких отправок пакетов по сети, никаких отображений чего либо на экране, никаких воспроизведений звуков, ни каких присваиваний в глобальные переменные, никакого вывода в консоль.
  Ничего что можно заметить, помимо результата вызова функции.

Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами.
Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его и сложно и бессмысленно, поэтому единственный вариант - исключить его из кода требующего исчерпывающего покрытия тестами.

Так же хочу отметить, что фигура изображающая логику на иллюстрации эргономичного юз кейса, не просто так больше по размеру всех прочих компонент и имеет самые толстые границы.
В идеальной реализации эргономичного подхода именно в логике содержится большая часть кода, и защите логике от внешней среды уделяется особое внимание.

Технически, логику следует помещать либо в сущности предметной области, либо в DCI роли, в зависимости от контекста.

=== Юз кейсы

Главной задачей кода реализации юз кейса явлется предельно ясное, декларативное описание юз кейса с точки зрения пользователя, а так же входных данных юз кейса и видимых эффектов, к которым приводит его выполнение.
В идеале должно быть как в старых добрых книгах по XP и DDD - вы показываете код юзкейса заказчику и он его понимает в общих чертах.
Для того чтобы код юз кейса был максимально приближен к языку пользователя, он не должен содержать низкоуровневых деталей и сложной логики.

С технической же точки зрения, юз кейс является центральным связующим звеном между Портами, Адаптерами и Логикой.
Юз кейс определяет верхнеуровневую структуру потоков управления и данных.

Юз кейс может быть простым и много шаговым.
Юз кейс является простым, если его цель может быть достигнута в результате обработки одного события.
Для этого необходимо чтобы все требуемые данные были доступны в момент обработки этого события и чтобы все эффекты могли быть выполнены в процессе обработки.
Юз кейс является много шаговым, если для достижения цели юз кейса требуется факт возникновения нескольких событий или части входных данных становятся доступны в разные моменты времени или эффекты могут быть выполнены в разные моменты времени

Технически, юз кейс может быть представлен объектом без состояния, объектом с состоянием только в памяти, и объектом с состоянием во внешнем хранилище.

Первый тип наиболее простой и распространенный и подходит в случаях, когда всё состояние юз кейса хранится в объектах предметной области.
В этом случае, единственный объект юз кейса создаётся платформой или приложением и инжектируется в порт.
Затем порт может либо самостоятельно получить объекты предметной области и передать их в юз кейс, либо передать в юз кейс идентификаторы этих объектов (которые содержатся в событиях).
Какой вариант лучше выбрать, зависит от конкретного случая.

Если же юз кейсу требуется какое-то состояние, которое не укладывается естественным образом в модель предметной области (#todo: например?#), то необходимо создать репозиторий юз кейсов, к которому будет обращаться порт, для получения объекта юз кейса.
Репозиторий может быть как ин-мемори, так и персистентный.
Ин-мемори вариант проще и быстрее, но персистентый позволяет юз кейсам переживать шатдауны и работать в много-нодовой среде.
В случае персистентного юз кейса, можно состояние юз кейса выделить в отдельный объект и сохранять только его.
Наконец, объекты юз кейсов с состоянием должны быть синхронизированы должным образом.

Несколько тривиальных одно шаговых юз кейсов можно группировать в один класс (без приватных методов).
Составной же юз кейс, должен целиком содержаться в одном отдельном классе и быть единственным содержимым этого класса.
Допустимо, чтобы несколько разных портов вызывали один и тот же юз кейс.

Я настоятельно рекомендую не использовать в юз кейсах какие-либо управляющие конструкции (#todo: уточнить термин#) за исключеним ROP-конструкций (конструкции вида `if (error) return ErrorData`) и условий отражающих описание юз кейса на естественном языке.
В юз кейсах недопустимо использование блоков с уровнем вложенности более двух и вызов приватных методов (#todo: стиль#).
Если в вашем описании юз кейса на естественном языке есть уровень вложенности больше двух - пересмотрите его.

(#todo: изучить возможность использования корутин для описания много шаговых юз кейсов одним методом#)

(#todo: ROP вместо исключений отделяет ошибки предметной области от ошибок программирования#)

==== Взаимодействующие с гуём (диалог подтверждения операции)
To do

На этом мы завершаем рассмотрение концептуальной модели софта и начинаем потихоньку двигаться в сторону практики.

== Декомпозиция приложения

=== Разбиение по видам классов

У меня нет однозначного и универсального рецепта разбиения классов по пакетам заранее.
Но я точно могу сказать, что не надо разбивать проект по видам классов - entities, services, controllers.
В особо одиозных случаях заводят пакеты exceptions, enums и annotations.
Пакетов classes и interfaces почему-то ни разу не видел:) В плюсы такого подхода можно попытаться записать только то, что при его использовании не надо думать.
Но, во-первых, в нашей работе это минус, а во-вторых, думать всё-таки надо - либо как привести класс к одному из существующих видов, либо придумать новый вид.
К дизайну ни та ни другая деятельность отношения не имеет и я считаю, что время лучше посвящать продумыванию дизайна системы.

Проблемы пакетирования по видам классов:

. Не все классы однозначно относятся к одному виду
. Плохо масштабируется
. Скрывает описание архитектуры за деталями реализации
. Изменения одной фичи, как правило затрагивают несколько модулей
. #todo: сложнее рулить логами через стандартные тулы#
. #todo: проблемы с вайлдкард импортами apx_talk_clean_coders_hate, apx_books_clean_code:Chapter 17, J1#
. Все выше перечисленное - это мелкие не приятности.
  Действительным же аргументом против такого стиля пакетирования, является то, что он исключает использование ограниченных модификаторов доступа (package private в Java, internal в Kotlin) и вынуждает весь код делать публичным.
  В итоге границы отсутсвуют в принципе - есть только соглашение о том что из более низких слоёв нельзя обращаться к более высоким.
  А внутри слоёв и от более высоких к более низким слоям даже никаких соглашений о границах нет.
  В итоге получается мегамесиво, слегка напоминающие очертаниями снеговик.
  Это ещё больше усугубляется при использовании спригового компонент скана и иньекции зависимостей на полях.

=== Другие идеи к разбиению классов

Что касается правильного разбиения с самого начала проекта, то за вдохновением советую обратиться к:

- https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33[статье "Four Strategies for Organizing Code"]
- https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[статье "Screaming architecture"]
- и к главе "34 THE MISSING CHAPTER" из книги "Clean Architecture".

=== Мой подход к разбиению классов

[start=0]
. По началу я складываю все классы в один модуль пакет, потому как моя методика требует некоторой критической массы классов, для того чтобы сработать.
. Мою методику можно применять, когда:
** Набралось хотя бы 10, а лучше 20 классов. Но я обычно на интуитивном уровне, чувствую, что пора навести порядок в этом бардаке.
** Когда целиком реализовано 3-5 юз кейсов, среди которых есть и однотипные и ортогональные
. После того как набирается достаточное количество классов, я строю для них https://www.ndepend.com/docs/dependency-structure-matrix-dsm[матрицу зависимостей]. И разбиваю все циклы в зависимостях. Это бывает очень сложно, но многие из лучших своих решений я нашёл именно разбивая циклы.
. После того, как все циклы разбиты, классы должны разбиться на три вида кластеров:
** кластеры классов, от которых ничего не зависит, но которые зависят от почти всех остальных классов (это будут порты и код сборки и инициализации графа объектов вашего приложения, при запуске)
** кластеры классов, которые сами ни от чего не зависят, но от которых зависит почти всё (это будет домен/логика)
** кластеры классов, от которых и зависят и другие классы и которые сами зависят от других классов (это будут порты, юз кейсы и адаптеры). Кластеры должны быть высоко связные (highly cohesive, много связей между классами внутри кластера) и слабо связанные (loosely coupled, мало связей с классами из других кластеров). Вот эти кластеры я и делаю пакетами/модулями.
. Если после разбиения циклов кластеры не выявились, то тут уже надо смотреть каждый конкретный случай и универсального рецепта у меня нет.

= Кодирование

== Конструкторы должно создавать валидные объекты

== У класса может быть не более 5 зависимостей

Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию).
Обращение к синглтонам откуда-либо помимо платформы запрещено категорически.
У этого правила несколько оснований:

Если вашему классу требуется более 5 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.

== Наследование (#todo#)

=== Открытые иерархии

=== Закрытые иерархии

== Избегайте интерфейсов с единственной реализацией (#todo#)
Потому что они создают только видимость барьера и усложняют код. Невозможно сделать настоящий интерфейс по единственной реализации. Интерфейсы в АПИ лучше делать абстракными классами с закрытой реализацией, чтобы клиенты не могли их реализовывать. Интерфейсы в SPI - норм.

== Иммутабельность по дефолту (#todo:#)

Защита от случайного внесения эффекта

== Domain Specific Languages (#todo#)

== Типизированные ИДы (#todo:#)
Типобезопасность и проще грепать логи

== CQRS (#todo:#)

== Обработка ошибок (#todo:#)

= Тестирование (#todo#)

== Моки (#todo#)
Использование моков для подсовывание входных данных - зло.
Моки можно использовать для верификации эффектов юз кейсов, но по возможности лучше всё-таки отдавать предпочтение аксептанс/интеграционным тестам.

== TDD? (#todo#)

== Ассерты (#todo:#)

== Контракты (#todo:#)

= Заключение

Эргономичный подход рассматривает систему как набор юз кейсов.
Каждый юз кейс реализуются набором компонент различных типов: платформа, порты, юз кейсы, адаптеры и логика.
Каждый из типов может содержать либо Эффекты, либо Логику.

Эргономичный подход делает два акцента:

. Описание всех Эффектов юз кейса должно содержаться в одном месте
. Необходимо разделять Логику и Эффекты

Первый акцент упрощает понимание системы и то, как та или иная доработка повлияет на видимые Эффекты, что способствует уменьшению количества ошибок, допускаемых в ходе модификации системы.
Второй акцент позволяет покрыть систему надёжным набором тестов, что так же способствует и простоте понимания системы (за счёт документирования системы по средствам тестов) и уменьшению количества ошибок.

В итоге стоимость разработки системы уменьшается, а её качество увеличивается.

[appendix]
= Примеры (#todo#)

 * ГУЙ
 * Низкоуровневое программирование
 * микросервисы
 * консольный уй
 * рекативность
 * Плагины билд систем
 * Распределённые кластеры

=== qbit (#todo#)
 * Факторизация кубита
 * Б+Дерево с кэшем нод в памяти и ленивой загрузкой нод с диска
 * WebDavStorage

=== Q5 (#todo#)

=== Удобно (#todo#)

=== Проект ТруСтори
Это вымышленный проект с примерами по мотивам проблем, с которыми я столкнулся у различных заказчиков.

==== Юз кейс: КПИ сотрудников
(#todo: добавить пролонгацию, при быстром логине, чтобы когда в рассчёте кпи начал бы учитываться финиш тайм, то оно бы не сломалось#)

В этом примере ТруСтори является стандартным бэком на Java/Spring/JPA с веб-фронтом с полнодуплексным соединением (#todo: проверить термин#).

Одной из фич ТруСтори является подсчёт КПИ сотрудников, среди которых есть длительность текущей смены.
Это значение сохраняется при перерыве в работе менее часа.

В реальной системе фича реализована так:

. Доменному классу юзера было добавлено поле со временем начала работы.
. Была переиспользована существующая таблица таймаутов, для того чтобы хранить момент сброса времени начала работы сотрудника.
. При логине, проверяется наличие таймаута сброса,
.. если он есть (что подразумевает, что время логаута не превысило час, т.е. продолжается текущая смена), то подсчитывается обновлённый КПИ и отправляется в браузер
.. в противном случае, обновляется значение времени начала работы
. При логауте, заводится таймер сброса времени начала работы.
. Отдельный тред в фоне удаляет протухшие таймауты из базы.

В этой функциональности зарылся неожиданный баг.
Некоторые новые (ниразу не логинвшиеся) сотрудники не могли подключиться, потому что каким-то образом у них был заведён таймаут на сброс времени начала работы (что происходит только при логауте), но при этом не было времени начала работы (т.е. не было логина).
В процессе расследования выяснилось, что одно из вспомогательных приложений, вело себя не совсем корректно и через АПИ звало логаут этим сотрудникам, что заводило им таймаут, но из-за того что они ни разу не логинились, им ни разу не проставлялось время начала работы и логика подсчёта КПИ крэшилась, из-за чего ломался логин (п. 3а).

Теперь давайте реализуем этот юз кейс в эргономичном стиле и увидим, как он помог бы избежать подобной проблемы и какие дополнительные преимущества принёс бы.

Начнём с того, что сформулируем сам юз кейс (#todo: разботанить как составлять толковые юз кейсы#).

*Цель:* Я как сотрудник хочу видеть длительность своей рабочей смены.

*Рабочая смена*: Один или более подряд идущих периодов времени нахождения сотрудника онлайн, с перерывами не более 60 минут.

*События*:

. Логин сотрудника
. Запрос КПИ
. Штатный логаут сотрудника
. Нештатный логаут сотрудника (закрытие вкладки)

*Эффекты*:

. Отображение текущих показателей сотрудника в браузере по запросу и при начале нового периода в рамках одной смены.

*Технические эффекты*: #todo: оно надо?#

. Пачка всякий загрузок из БД
. Отправление сообщения в браузер
. Сохранение чего-то в БД?

*Алгоритм*:

. При логине сотрудника
.. Если нет существующей смены (первый логин сотрудника в системе), то начать рабочую смену, и зафиксировать время её начала
.. Если существующая смена есть и время логаута менее часа назад (возврат сотрудника с обеда), то отправить сотрудника его текущие показатели КПИ.
.. Если существующая смена есть, и время логаута более часа назад (начало новой смены), то зафиксировать начало новой смены
. При логауте и закрытии вкладки, зафиксировать время события, в качестве потенциального времени окончания смены
. При запросе КПИ сотрудника, вычислить текущие показатели КПИ и отправить в браузер.

Глядя на этот юз кейс, лично у меня появляется одно желание - завести класс рабочей смены. Давайте так и поступим:

.WorkShift.java
[source,java]
----
public class WorkShift {

    private final @Nonnull WebSocket webSocket;

    private final @Nonnull User user;

    private final @Nonnull Duration maxInterruptionLen;

    private Instant @Nonnull startTime;

    private Instant @Nullable finishTime;

    public WorkShift(@Nonnull WebSocket webSocket, @Nonnull User user, @Nonnull Instant startTime, @Nonnull Duration maxInterruptionLen) {
        this.webSocket = webSocket;
        this.user = user;
        this.startTime = startTime;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (finishTime == null) {
            // Первый логин, ничего не делаем
            return;
        }
        final Duration interruptionLen = Duration.between(finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            webSocket.sendKpi(user);
        } else {
            // Начало новой смены
            startTime = Instant.now();
        }
    }

    public void sendKpi() {
        webSocket.sendKpi(user);
    }

    public void onLogout() {
        finishTime = Instant.now();
    }

}
----

Этот класс является не плохим объектом в классическом ООП - у него есть настоящее состояние и настоящее поведение.
К тому же теперь есть место где можно заэнфорсить инвариант, что время начала смены не налл.
Но у него есть и ряд проблем:

. Этот объект мутабельный и может быть использован в разных тредах, поэтому его надо синхронизировать.
. У него нет однозначной идентичности - это объект текущей рабочей смены и в разные моменты времени он соотвествует разным объектам реального мира.
. В него зашита логика определённого юз кейса.
Если появятся новые требования, связанные с рабочей сменой, например ограничение длительности рабочей смены, то эту логику также придётся добавить в этот объект, что снизит его связность (cohesion).
. Он нарушает принцип трёх зависимостей.

Для решения этих проблем воспользуемся принципами DCI и неизменяемости:

. Оставим WorkShift простым доменным объектом и сделаем его неизменяемым
. Логику вынесем в роль KpiTracker

[Note]
====
Удивительно, как DCI всё ставит на свои места. Я долгое время руководствовался эвристикой, что класс с именем заканчивающимся на *er (все возможные Controllers, Managers, Drivers, Updaters и т.д.) указывает на проблемы в дизайне, потому что как правило это были пакеты процедур управляющие структурами данных.

Роль же с именем *er является вполне логичной и является одним из аспектов поведения объекта, который манипулирует состоянием того же объекта.
====

(#todo: чёт с KpiTracker-ом в итоге концептуальное месиво какое-то вышло - он и роль, и юз кейс и контекст, надо выяснить норм ли это#)

.WorkShift.java
[source,java]
----
public class WorkShift {

    @Nonnull Instant startTime;

    @Nullable Instant finishTime;

    public WorkShift(@Nonnull Instant startTime) {
        this.startTime = startTime;
    }

    public WorkShift(@Nonnull Instant startTime, @Nonnull Instant finishTime) {
        this.startTime = startTime;
        this.finishTime = finishTime;
    }

    public WorkShift finish(Instant finishTime) {
        return new WorkShift(startTime, finishTime);
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    private final User user;

    private final WebSocket webSocket;

    private final Duration maxInterruptionLen;

    private WorkShift workShift;

    public KpiTracker(User user, WorkShift prev, WebSocket webSocket, Duration maxInterruptionLen) {
        this.user = user;
        this.workShift = prev;
        this.webSocket = webSocket;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (workShift == null) {
            // Первый логин сотрудника, ничего не делаем
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        if (workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        final Duration interruptionLen = Duration.between(workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            webSocket.sendKpi(user);
        } else {
            // Начало новой смены
            workShift = new WorkShift(user, Instant.now());
        }
    }

    public void sendKpi() {
        webSocket.sendKpi(user);
    }

    public void onLogout() {
        workShift = workShift.finish(Instant.now());
    }

}
----

Рассмотрим, как новая версия решает обозначенные выше проблемы:

. Синхронизация: теперь `WorkShift` иммутабельный, а `KpiTracker` создаётся для каждого треда по отдельности - ни тот ни другой класс синхронизации больше не требуют.
. Идентичность: рабочая смена стала вэлью объектом и больше не имеет идентичности.
Эта версия кода подсветила новый объект - рабочая смена сотрудника.
У него уже вполне понятная идентичность, которая определяется ключём `(user, startTime)`.
Следующим шагом выделим класс `UserWorkShift`.
. Теперь логика юз кейса находится в отдельном классе.
Если потребуется добавить логику ограничения смены, то она так же пойдёт в отдельный класс `TimeShiftLimiter`.
Каждый из этих классов будет описывать отдельный юз кейс и будет иметь высокую связность (cohesion).
. Принцип трёх зависимостей остался нарушен, но мы это исправим, создав класс `UserWorkShift`.

Кроме того, в новой версии стала Очевидна вероятность возникновения ошибочной ситуации повторного логина без предварительного логаута - в первой версии он была скрыта обработкой первого логина сотрудника в системе.

Теперь давайте выделим `UserWorkShift`.
При попытке выделить `UserWorkShift` обнаружится проблема: при создании `KpiTracker` ещё не понятно, есть ли у сотрудинка активная текущая смена.
Можно попробовать сделать этот параметр нуллабельным, но мы тогда потеряем инфу о сотруднике, и не сможем начать рабочую смену при логине.
Поэтому в конструктор надо передавать сотрудника, для которого будем отслеживать рабочую смену и репозиторий рабочих смен, из-за чего мы снова нарушим правило трёх зависимостей.
Для того чтобы окончательно решить проблему с зависимостями, мы пойдём другим путём - вместо передачи репозитория рабочих смен, воспользуемся техникой шлюза из чистой архитектуры и все нужные зависимости скроем за одним интерфейсом.

.UserWorkShiftRepository.java
[source,java]
----
// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс
new UserWorkShift(user, Instant.now());
public class UserWorkShiftRepository {

    @Nullable
    public UserWorkShift getByUserId(Long userId) {
        return null;
    }

}
----
.KpiGateway.java
[source,java]
----
public class KpiGateway {

    private final UserWorkShiftRepository userWorkShiftRepository;

    private final Duration maxInterruptionLen;

    public KpiGateway(UserWorkShiftRepository userWorkShiftRepository, Duration maxInterruptionLen) {
        this.userWorkShiftRepository = userWorkShiftRepository;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    @Nullable
    public UserWorkShift getByUser(User user) {
        return userWorkShiftRepository.getByUserId(user.getId());
    }

    public void sendKpi(@Nonnull UserWorkShift userWorkShift) {
        // sendKpi
    }

    public Duration getMaxInterruptionLen() {
        return maxInterruptionLen;
    }

}

----
.UserWorkShift.java
[source,java]
----
public class UserWorkShift {

    @Nonnull public final User user;

    @Nonnull public final Instant startTime;

    @Nullable public final Instant finishTime;

    public UserWorkShift(@Nonnull User user, @Nonnull Instant startTime) {
        this(user, startTime, null);
    }

    public UserWorkShift(@Nonnull User user, @Nonnull Instant startTime, @Nullable Instant finishTime) {
        this.user = user;
        this.startTime = startTime;
        this.finishTime = finishTime;
    }

    public UserWorkShift finish(Instant finishTime) {
        return new UserWorkShift(user, startTime, finishTime);
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final User user;

    @Nonnull private final KpiGateway kpiGateway;

    @Nullable private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull User user, @Nonnull KpiGateway kpiGateway) {
        this.user = user;
        this.kpiGateway = kpiGateway;
        userWorkShift = kpiGateway.getByUser(user);
    }

    public void onLogin() {
        if (userWorkShift == null) {
            // Первый логин сотрудника, ничего не делаем
            userWorkShift = new UserWorkShift(user, Instant.now());
            return;
        }

        if (userWorkShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = new UserWorkShift(user, Instant.now());
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < kpiGateway.getMaxInterruptionLen().toMillis()) {
            // Продолжение смены
            kpiGateway.sendKpi(userWorkShift);
        } else {
            // Начало новой смены
            userWorkShift =  new UserWorkShift(user, Instant.now());
        }
    }

    public void sendKpi() {
        if (userWorkShift == null) {
            // Ошибка - запрос на отравку КПИ для ни разу не логиневшегося сотрудника
            return;
        }
        kpiGateway.sendKpi(userWorkShift);
    }

    public void onLogout() {
        if (userWorkShift == null) {
            // Ошибка - логаут ни разу не логиневшегося сотрудника
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
    }

}
----

Так же этот рефакторинг, по мимо решения проблем с идентичностью и зависимостями, сделал Очевидным то, что в нашей системе есть потенциальная возможность позвать логаут сотруднику, который ни разу не логинился.

Внимательный читатель, наверное заметил, что мы сейчас только загружаем смены из репозитория, но никогда их не сохраняем.
Давайте добавим в репозиторий возможность сохранения смен и сделаем эффекты по загрузке и сохранению рабочих расписаний симметричными и Очевидными:

.UserWorkShiftRepository.java
[source,java]
----
// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс
public class UserWorkShiftRepository {

    // ...

    public UserWorkShift save(@Nonnull UserWorkShift userWorkShift) {
        // ...
    }

    // ...

}
----
.KpiGateway.java
[source,java]
----
public class KpiGateway {

    // ...

    public UserWorkShift save(UserWorkShift userWorkShift) {
        return userWorkShiftRepository.save(userWorkShift);
    }

    // ...
}
----
.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final User user;

    @Nonnull private final KpiGateway kpiGateway;

    @Nullable private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull User user, @Nonnull KpiGateway kpiGateway) {
        this.user = user;
        this.kpiGateway = kpiGateway;
        userWorkShift = kpiGateway.getByUser(user);
    }

    public void onLogin() {
        if (userWorkShift.workShift == null) {
            // Первый логин сотрудника, ничего не делаем
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
            return;
        }

        if (userWorkShift.workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            kpiGateway.sendKpi(userWorkShift.user);
        } else {
            // Начало новой смены
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
        }
    }

    // ...

    public void onLogout() {
        if (userWorkShift == null) {
            // Ошибка - логаут ни разу не логиневшегося сотрудника
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
        kpiGateway.save(userWorkShift);
    }

}
----

В этой реализации есть две новые проблемы:

. При логине сохранение рабочей смены дублируется 3 раза
. Метод логина начал нарушать правило логики или эффектов - логика определения начала смены не совсем тривиальная и её хочется покрыть тестами, но это невозможно не замокав `kpiGateway`.

Для решения этих проблем вынесем бизнес правило определения начала рабочей смены в чистую функцию предметной области в классе `KpiRules`.

.KpiRules.java
[source,java]
----
public class KpiRules {

    public boolean shouldStartNewWorkShift(UserWorkShift currentWorkShift, Duration maxInterruptionLen, Instant now) {
        if (currentWorkShift == null) {
            // Первый логин сотрудника, ничего не делаем
            return true;
        }

        if (currentWorkShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            return true;
        }

        final Duration interruptionLen = Duration.between(currentWorkShift.finishTime, now);
        return interruptionLen.toMillis() >= maxInterruptionLen.toMillis();
    }

}
----
.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final KpiGateway kpiGateway;

    @Nonnull private final KpiRules kpiRules;

    @Nonnull private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull Long userId, @Nonnull KpiGateway kpiGateway, @Nonnull KpiRules kpiRules) {
        this.kpiGateway = kpiGateway;
        this.kpiRules = kpiRules;
        this.userWorkShift = kpiGateway.getByUserId(userId);
    }

    public void onLogin() {
        UserWorkShift currentWorkShift = userWorkShift();

        boolean shouldStartNewWorkShift = kpiRules.shouldStartNewWorkShift(currentWorkShift, kpiGateway.getMaxInterruptionLen(), Instant.now());
        Assert.isTrue(currentWorkShift != null || shouldStartNewWorkShift, "KPI rules has decided to not start new work shift on login of user without active work shift");

        if (shouldStartNewWorkShift) {
            currentWorkShift = new UserWorkShift(user, Instant.now());
            kpiGateway.save(currentWorkShift);
        } else {
            kpiGateway.sendKpi(currentWorkShift);

    }

    // ...

}
----

Отлично, теперь нам не хватает только лишь Порта, для того чтобы получить канонический эргономичный юз кейс, давайте добавим его:

.KpiTracker.java
[source,java]
----
@RestController
public class KpiPort {

    private final AuthService authService;

    private final UserService userService;

    private final KpiGateway kpiGateway;

    public KpiPort(AuthService authService, UserService userService, KpiGateway kpiGateway) {
        this.authService = authService;
        this.userService = userService;
        this.kpiGateway = kpiGateway;
    }

    @EventListener
    public void onLogin(UserLoginEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogin();
    }

    @PutMapping(value = "/kpi")
    public void sendKpi() {
        final KpiTracker kpiTracker = new KpiTracker(authService.getCurrentUser(), kpiGateway, new KpiRules());
        kpiTracker.sendKpi();
    }

    @EventListener
    public void onDisconnect(UserDisconnectEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }

    @EventListener
    public void onLogout(UserLogoutEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }


}
----

Порт вышел тривиальным - таким каким и должен быть.

(#todo: диаграмма#)

Вот чего мы добились применив эргономичный подход:

. Обнаружили и сделали Очевидной ранее скрытую сущность предметной области - рабочая смена сотрудника
. Замкнули на один класс все входы и выходы юз кейса - теперь очевидно куда добавлять новую функциональность (этого юз кейса конечно же, другие юз кейсы пойдут в другие классы), когда она появится, и при каких событиях она должна и будет вызываться и какие эффекты будет иметь
. Описали юз кейс в одном месте и сделали его Очевидным (в оригинальной версии, юз кейс раскидан по четырём разным классам в трёх разных модулях)
. Описали правило начала новой рабочей смены (в оригинальном коде, начало смены определялось по наличию записи в таблице таймаутов, которая записывалась в двух разных классах, а удалялась в третьем)

Оригинальная ошибка в эргономичной версии практически исключена - из-за того что языком реализации является Java, приходится рассчитывать на аннотации и подскзки Идеи, в Kotlin'е эта ошибка была бы исключена на уровне типов.

Единственное что меня не много смущает в итоговой версии - объединение отслеживания рабочих смен и отправку КПИ в одном классе.
Но пока что рабочая смена является нужна только в юз кейсе КПИ, поэтому я думаю эту связность пока можно оставить.
Когда рабочая смена потребуется в другом юз кейсе, её надо будет выделить в отдельный модуль.
Наконец, это объясняет все наши мучения с принципом трёх зависимостей - `KpiTracker` действительно делает слишком много.
И он и рабочие расписания отслеживает, и определяет правило продления смены (вообще надо было изначально длительность перерыва перенести в `KpiRules`, но оставим так) и КПИ отправляет.

==== Модель состояний сотрудника (#todo#)

==== Отчёты

=== Todos (#todo#)

[appendix]
= Дальнейшее чтение (#todo#)

=== Люди

[#apx_peop_uncle_bob]
==== Анкл Боб (#todo:#)

==== Эрик Майер (#todo#)

[#apx_peop_coplien]
==== Джеймс Коплейн (James Coplien)

=== Книги

[#apx_book_ddd]
==== DDD (#todo#)

[#apx_book_object_thinking]
==== Object Thinking (#todo#)

[#apx_book_lean_arch]
==== Lean Architecture for Agile Software Development

[#apx_book_clean_code]
==== Clean Code

=== Научные статьи

=== Публицистические статьи

[#apx_artc_seg]
Segue

=== Доклады

[#apx_talk_dci]
==== DCI: Practical Tips and Lessons for Nerds

Ссылка: https://www.youtube.com/watch?v=SxHqhDT9WGI

[#apx_talk_dci_glimpse_of_rygve]
==== A Glimpse of Trygve: From Class-oriented Programming to Real OO

Ссылка: https://www.youtube.com/watch?v=lQQ_CahFVzw

[#apx_talk_clean_coders_hate]
==== Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks

Ссылка: https://www.youtube.com/watch?v=FyCYva9DhsI

[appendix]
= Spring

=== Не использовать компонент скан (#todo:#)
Заметает бардак в зависимостях под ковёр
Проблемы с циклическими зависимости проявляются ток в рантайме
