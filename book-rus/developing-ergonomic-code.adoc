= Разработка эргономичного кода (Черновик)
Алексей Жидков
Версия 0.0.1, 2020-02-29
:doctype: book
:toc:
:source-highlighter: pygments

toc::[]

= Техническая глава

== Работа не завершена

Этот материал, который пока что скорее является серией статей и заметок находится в разработке.
Я надеюсь, что со временем, он превратится в книгу о том, как разрабатывать "сатисфактори" проекты - проекты которые и разрабатывать приятно и использовать.
Разделы, которые я планирую включить в книгу, я пишу в "совершённом" времени - как будто они часть уже написанной книги.

На момент написания этого материала, я большую часть времени занимаю разработкой бэка на спринге, поэтому есть некоторый перекос в эту сторону.
Но за свою карьеру я участвовал в разработке проектов самых разных типов и изложенные идеи должны быть применимы в целом к разработке софта.
Со временем я обобщу изложенные идеи и приведу примеры их реализации в различных контекстах.

== To do

. Вставить диаграмму кубита, в качестве иллюстрации подхода к разбиению на пакеты
. Разобрать пример с отображением списка (списков дел), либо сообщение о пустом списке
.. Где должен быть этот иф? В юз кейсе или во вью?
.. Что вообще делать с этим ифом? Тащить его отдельно в логику кажется перебором.
. Выброс исключения - это эффект?
. Разбиение цикла между вью и юз кейсом
.. Забить
.. Обсёрвер
.. Возврат экшена в onXXX. Но что делать, если требуется возаимодействие - onDelete -> askConfirmation -> delete. Отдельные эвенты? Корутины?
... Примерно туда же - где должна быть логика запроса подтверждения удаления? В принципе её можно целиком во вью оставить, дёргая юз кейс только при подтверждении. Но Очевидно ли это?
. threads#bd5d4a4e, MessageServiceImpl#setMessageChannel
. Эвент != юз кейс. Эвент - атомарное действие вызываемое обычным событием (сообщением в традиционном ООП), юз кейс - сценарий достижения определённой цели, продвигаемый одним или более событием <<apx_talks_dci>>
. Habits <<apx_talks_dci>>
. Инклуды юз кейсов вредные, потому что теряют цель <<apx_talks_dci>>
. Дизайн - разделение стабильных и изменяющихся частей <<apx_talks_dci>>, <<apx_peop_uncle_bob>>
. Доменная модель должна быть стабильной <<apx_talks_dci>>, <<apx_peop_uncle_bob>>
. Традиционные сервисы - жирные DCI Roles?
. Peter Coad, object modelling in code (https://www.infoq.com/articles/domain-color-modeling/)
. Юз кейсы - идеально место для осмысленных комментов. Сейчас стандартный бэк - это в основном набор структур данных и пакетов процедур для манипуляции ими и логику описывать не где. Юз кейсы же кодом описывают связанные куски логики и этот код можно сдобрить хорошим комментом.
. Комменты и коммит мессаджи на русском. Глухой телефон в КБ информ. На английском в опенсорсе, забугорных заказчиках, между народных коммандах.
. Временные таблицы (таблицы с данными не входящими в доменную модель и из которых данные постоянно удаляются) - потенциально скрытые юз кейсы
. Юз кейсы - настоящие объекты, с настоящим состоянием и настоящей логикой и настоящей инкапсуляцией.
. Коплейн <<apx_peop_coplien>>: юнит тесты снижают качество кода
. Изучение домена: <<apx_peop_coplien>>, <<apx_book_ddd>>, <<apx_book_object_thinking>>
. Большинство ошибок находятся во взаимо действии <<apx_artc_seg>>
. "Чем раньше обнаружена ошибка, тем дешевле её исправить" - миф? <<apx_artc_seg>>
. "A proper book isn't just a collection of facts, it reflects cause and mission" <<apx_book_lean_arch>>
. "If we reflect the end user mental model in the code, we are more likely to have working software" <<apx_book_lean_arch>>

= Введение

== Мотивация

Главной мотивацией к написанию этой книги является структурирование собственных мыслей о том как писать эргономичный код.
Кроме того, я использую эту книгу как руководство разработчика в командах, которыми управляю я сам, и как референсный (#todo: корректное слово#) материал в командах под руководством других людей.

Кроме того я уже много лет преподаю различные курсы по программированию и просто довольно много взаимодействую с молодыми программистами.
И в последнее время я начал уставать от пересказа одних и тех же идей по нескольку раз в год и с этой книгой у меня есть единое и "консистентное" (#todo: перевести на русский#) место, куда можно отсылать учеников.

Наконец, опытные разработчики могут найти в этой книге классные, но мало известные идеи, такие как "Data, Context, Interaction Architecture" (#todo: больше жемчужин#).

== Что такое эргономичный код?

(#todo: попровить шрифт цитат#)

Что же такое эргономичный код?
Для начала рассмотрим несколько определений термина "эргономичность" в общем смысле, а потом адаптируем их к коду:
[quote, Большой толковый словарь русского языка]
____
Эргономичность - наличие условий, возможностей для лёгкого, приятного, необременительного пользования чем-либо или удовлетворения каких-либо нужд, потребностей
____

[quote, ISO/IEC 25010]
____
Эргономичность - способность продукта быть понимаемым, изучаемым, используемым и привлекательным для пользователя в заданных условиях
____

[quote, Краткий толковый словарь по полиграфии]
____
Эргономичность - дизайн оборудования, учитывающий взаимодействие человек/машина, позволяющий снизить вероятность ошибки оператора, повысить комфортность условий его работы.
____

[quote, dic.academic.ru]
____
Эргономичность - в изначальном смысле это эффективность инструмента производства или системы в эргономике. Под эффективностью при этом понимается наибольшая производительность при наименьшей вероятности ошибки (пользователя но не устройства). Ныне термин употребляется в более широком смысле, обозначая общую степень удобства предмета (не обязательно средства производства), экономию времени и энергии при использовании предмета. Например: «эргономичный токарный станок», «эргономичный электромобиль» или даже «эргономичный стул».
____

В нашем случае, понятно, пользователем/оператором/человеком будет программист, чем-либо/продуктом/оборудованием/инструментом производства будет код, а пользованием/использованием будет внесение модификаций в код.
В первой цитате, мне нравятся характеристики "лёгкий и приятный в использовании";
В второй цитате, мне нравятся характеристики "понимаемый и изучаемый";
В третьей цитате, мне нравится характеристика "снижающий вероятность ошибки";
Наконец, в четвёртой цитате (помимо уже упомянутой вероятности ошибки) мне нравится характеристика "наибольшая производительность".

Объединив все эти характеристики, получаем следующее определение:
[quote, Алексей Жидков, Разработка эргономичного кода]
____
Эргономичный код - это код, обеспечивающий наибольшую производительность программиста, за счёт простоты понимания и изучения, снижения вероятности внесения ошибки при модификации. Понятный и защищённый от внесения ошибок код, в свою очередь становится лёгким и приятным для внесения изменений.
____

Что же делает код эргономичным? Исчерпывающие автоматизированные тесты (в первую очередь) и очевидность эффектов. Тому что это такое и как этого достичь посвящена вся оставшаяся часть книги.

== Базовые идеи

В адекватной архитектуре нет ничего принципиально нового и она по сути основывается на идеях из следующих следующих хорошо известных (в узких кругах) докладах и статьях:

. Simple Made Easy
. Layered architecture
. Functional core, imperative shell
. Hexagonal architecture
. Onion & Clean architecture
. Railway oriented programming
. Data, Context, interaction architecture

=== Simple Made Easy
https://www.infoq.com/presentations/Simple-Made-Easy/[Simple Made Easy], (https://tonsky.livejournal.com/243192.html[краткий пересказ на русском]).

Из этого доклада я взял то, что "просто" != "легко" и что простые вещи выгоднее в длительной перспективе.

Например, для того чтобы сбросить весь надо следовать двум простым правилам - "меньше жрать", "больше двигаться". Выполнять эти правила сложно, но если сумеете, то решите проблему с весом на всегда. Есть простой путь - липоскакция. Но этот путь даёт временный результат и не решает прочих проблем вызванных "легким" образом жизни.

Не взял я из этого доклада clojure, ядрёную функциональщину; идею того, что типы и тесты не особо уменьшают количество багов; и полный отказ от ОРМов.

=== Layered architecture
https://dzone.com/articles/layered-architecture-is-good[Layered architecture], https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0[слоистая архитектура] - на самом деле никогда не занимался изучением этого вопроса, поэтому взял две первые ссылки в гугле, если подскажите ссылку на хорошую статью посвщяённую этой теме - буду очень благодарен.

Адекватная архитектура в принципе является вариантом слоистой, за исключением того, что убирает зависимость слоя бизнес логики от слоя инфраструктуры/персистанса и поднимает этот слой на один уровень со слоем бизнес логики.

=== Functional core, imperative shell (FCIS)
https://www.youtube.com/watch?v=yTkzNHF6rMs[Boundaries], версии на русском я не нашёл.

Из этого доклада я взял всё. А именно - идеи разделения логики и ввода вывода и использования структур данных в качестве интерфейса между этими частями.

=== Hexagonal (Ports&Adapters) architecture
http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm[Оригинальная статья 2005 года], https://habr.com/ru/post/267125/[описание на русском].

Это первая публикация из серии крайне схожих архитектур - hexagonal, onion и clean (да и FCIS, тоже примерно про тоже, на самом деле). По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.

Отсюда (помимо общей идеи) я позаимствовал термины Порт и Адаптер. Но я их использую в другом смысле:) А до идеи событий приходящих из внешнего мира я додумался сам, когда уже забыл детали этой статьи:)

Не взял я из Hexagonal architecture церемонии с набором порт-интерфейс-адаптер на каждое взаимодействие с платформой и идею о том, что логика приложения окружена "однотипными" портами.

=== Clean architecture, Onion architecture
- https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/[Оригинальная серия статей об Onion Architecture]
- https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Оригинальная статья о Clean Architecture]
- https://habr.com/ru/company/mobileup/blog/335382/[хорошее пояснение Clean Architecture на русском]
- https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164[оригинальная книга о Clean Architecture]
- https://www.ozon.ru/context/detail/id/144499396/[книга на русском о Clean Architecture]

Хотя Onion Architecture появилась раньше, чем Clean (2008 и 2012) и я не вижу совершенно никакой разницы между ними, по моим ощущением более известной стала Clean Architecture и она, пожалуй, самая известная и распространённая из всех базовых идей адекватной архитектуры.

Из этих двух архитектур я взял идеи того, что зависимости должны быть направлены в строну более стабильных модулей; доменная модель и бизнес-логика не должны зависеть ни от чего; фреймворк является деталью, которая должна быть задвинута на задворки. Так же, в том числе и от сюда, я взял понятие юз кейса (интерактора).

Не стал я брать границы в виде интерфейсов между всеми слоями по дефолту и утверждение, что база данных и тип гуя являются незначительными деталями.

Так же дядюшке Бобу над отдать должное за https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[Screaming architecture]. На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы (см из чистой архитектуры).

=== Railway oriented programming
https://fsharpforfunandprofit.com/rop/[Оригинальная статья]

Серия статей о функциональном подходе к обработке ошибок.

Взял идею параллельных рельс для "основного" пути и "ошибочного экспресса". Суть в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса. Плюс за то, чтобы заменять исключения на возвращаемые значения, там где это уместно.

Не стал брать, монады и весь абстрактный ад второго порядка с ними связанный.

=== Data, Context, interaction architecture
https://www.artima.com/articles/dci_vision.html[Оригинальная статья].

На эту идею я наткнулся не давно и ещё её изучаю. Суть в том, чтобы объединять "тупые" доменные объекты с поведением по юз кейсно, с помощью трейтов и тайп классов. Если язык не поддерживает тайп классы и трейты, но поддерживает экстеншн функции, то на них, я думаю, можно будет смастерить чё-нить юзабельное. Я думаю это может стать хорошей техникой реализации юз кейсов и логики.

= Проектирование

[quote,]
[quote, IEEE1471 2007]
____
... The fundamental organiztion of a system embodien in its components, their relationships to each oterh, and to the environment and the principles guiding its design and evolution
____

[quote, Booch 2006]
____
Architecture represents the significant design decisioins that shape a system, where significiant is measured by cost of change
____
[quote, Coplien, Lean Architecture]
____
the form of a system, where the word form has a special meainign that we'll explore a bit later. (p. 2)
____

[quote, Uncle Bob]
____
(#todo:#)
____

== Анатомия системы? (#todo#)

== Анатомия приложения (#todo#)

== Анатомия юз кейса

В адекватной архитектуре программа рассматривается как набор юз кейсов, которые состоят из следующих частей:

- Платформа
- Порты
- Адаптеры
- Юз кейс
- Логика

image::images/aa-use-case.JPG[Устройство юз кейса]

=== Платформа

В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт.

=== Порты

Порт является точкой входа в функцию системы. Его задача - принять вызов, при необходимости сконвертировать входные данные, при необходимости, создать юз кейс, передать в него управление и вернуть результат, при необходимости снова сконвертировав его. В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.

В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат. При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции). Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.

Порт может вызвать только один юз кейс. Если вам надо вызвать два юз кейса, значит у вас есть составной юз кейс.

В некоторых случая на один юз кейс может быть несколько портов, которые переводят управление на разные этапы юзкейса. Может быть и наоборот, несколько портов вызывают один и тот же юз кейс. В этом случае, желательно, но не обязательно, объединять их в одном классе.

=== Юз кейсы

**Todo: акцент на эффектах**


Главной задачей кода реализации юз кейса явлется предельно ясное, декларативное описание юз кейса с точки зрения пользователя и видимых эффектов, к которым приводит его выполнение. В идеале должно быть как в старых добрых книгах по XP и DDD - вы показываете код юзкейса заказчику и он его понимает в общих чертах. Для того чтобы код юз кейса был максимально приближен к языку пользователя, он не должен содержать низкоуровневых деталей и сложной логики. Вся логика юз кейса должна содержаться в одном методе.

Юз кейс может быть как простой (все необходимые данные приходят одним событием), так и составной (для того что бы выполнить юз кейс целиком, необходимо получить несколько связанных событий). Несколько простых юзкейсов можно группировать в один класс (без приватных методов). Составной же юз кейс, должен целиком содержаться в одном отдельном классе и быть единственным содержимым этого класса. Допустимо, чтобы несколько разных портов вызывали один и тот же юз кейс.

Объекты юз кейсов хранят необходимое состояние и связывают адаптеры с логикой. В юз кейсах так же запрещено использование иф-ов и прочих конструкций управления потоком выполнения, за исключением ROP - конструкции вида `if (error) return ErrorData` допустимы. Для обхода этого ограничения можно использовать DSLи:) Так же юз кейсы могут обращаться к юз кейсам более низкого уровня.

Для многошаговых юз кейсов с несколькими портами, мне кажется, может быть возможность их красиво и читаемо оформить в последовательность шагов в одном блоке. Но эту идею я ещё не изучал.

==== Персистентные юз кейсы

В случае когда юз кейс состоит из нескольких шагов, которые инициируются различными событиями во внешней среде, юз кейс может быть сохранён в кэше или в некотором постоянном хранилище в случае распределённой среде. В этом случае порты юз кейса должны будут создавать, сохранять и загружать объекты юз кейсов. Так же в этом случае стоит подумать о синхронизации доступа к объектам юз кейсов.

==== Взаимодействующие с гуём (диалог подтверждения операции)
To do

=== Адаптеры

Единственной задачей адаптеров является инкапсуляция ввода-вывода. Эти единственные компоненты, которым разрешено обращаться к платформе (порты вызываются платформой и ничего о ней не знают). В адаптерах так же как и в портах и из кейсах запрещено использовать управляющие конструкции. Если атомарная с точки зрения операция ввода-вывода требует логики, то эту логику можно либо завернуть в DSL или оформить её как отдельный юз кейс, но это уже будет юз кейс платформы, а не вашей системы.

Наконец поясню смысл запрета на логику в потрах, юз кейсах и адаптерах. Дело в том что все они транзитивно зависят от платформы и ввода-вывода.

Ввод-вывод, в принципе, можно замокать, но я считаю моки плохой практикой. В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга. Плюс они совершенно ничего не говорят о работоспособности вашего кода в реальных условиях.

Так вот если порты, юз кейсы и адаптеры будут простые, то их достаточно будет покрыть минимальным набором интеграционных тестов, для того чтобы быть в них уверенными.

=== Логика

Наконец Логика. Она же Бизнес-Логика, она же домен, она же бизнес-правила. Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения. Но тут есть другое ограничение - логика должны быть чистой в функциональном плане, то есть не иметь наблюдаемых сайд эффектов.

Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д. Нет, всего этого не надо. Любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за. Да же исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них. Ну и да логгирование тоже можно, если оно не является публичной функцией вашей системы. Вобщем, одно правило - каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.

Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами. Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его и сложно и бессмысленно, поэтому единственный вариант - исключить его.

Логика на иллюстрации не просто так больше по размеру всех прочих компонент и имеет самые толстые границы. В идеально реализации адекватной архитектуры именно в логике содержится большая часть кода, и защите логике от внешней среды уделяется особое внимание.

Так же для организации реализации логики я советую присмотреться к идеи DCI. Но сам я ещё не опробовал этот подход в боевых условиях.

== Декомпозиция приложения

=== Разбиение по видам классов

У меня нет однозначного и универсального рецепта разбиения классов по пакетам заранее. Но я точно могу сказать, что не надо разбивать проект по видам классов - entities, services, controllers. В особо одиозных случаях заводят пакеты exceptions, enums и annotations. Пакетов classes и interfaces почему-то ни разу не видел:) В плюсы такого подхода можно попытаться записать только то, что при его использовании не надо думать. Но, во-первых, в нашей работе это минус, а во-вторых, думать всё-таки надо - либо как привести класс к одному из существующих видов, либо придумать новый вид. К дизайну ни та ни другая деятельность отношения не имеет и я считаю, что время лучше посвящать продумыванию дизайна системы.

Проблемы пакетирования по видам классов:

. Не все классы однозначно относятся к одному виду
. Плохо масштабируется
. Скрывает описание архитектуры за деталями реализации
. Изменения одной фичи, как правило затрагивают несколько модулей
. #todo: сложнее рулить логами через стандартные тулы#
. Все више перечисленное - это мелкие не приятности. Действительным же аргументом против такого стиля пакетирования, является то, что он исключает использование ограниченных модификаторов доступа (package private в Java, internal в Kotlin) и вынуждает весь код делать публичным. В итоге границы отсутсвуют в принципе - есть только соглашение о том что из более низких слоёв нельзя обращаться к более высоким. А внутри слоёв и от более высоких к более низким слоям даже никаких соглашений о границах нет. В итоге получается мегамесиво, слегка напоминающие очертаниями снеговик. Это ещё больше усугубляется при использовании спригового компонент скана и иньекции зависимостей на полях.

=== Другие идеи к разбиению классов

Что касается правильного разбиения с самого начала проекта, то за вдохновением советую обратиться к:

- https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33[статье "Four Strategies for Organizing Code"]
- https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[статье "Screaming architecture"]
- и к главе "34 THE MISSING CHAPTER" из книги "Clean Architecture".

=== Мой подход к разбиению классов

[start=0]
. По началу я складываю все классы в один модуль пакет, потому как моя методика требует некоторой критической массы классов, для того чтобы сработать.
. Мою методику можно применять, когда:
** Набралось хотя бы 10, а лучше 20 классов. Но я обычно на интуитивном уровне, чувствую, что пора навести порядок в этом бардаке.
** Когда целиком реализовано 3-5 юз кейсов, среди которых есть и однотипные и ортогональные
. После того как набирается достаточное количество классов, я строю для них https://www.ndepend.com/docs/dependency-structure-matrix-dsm[матрицу зависимостей]. И разбиваю все циклы в зависимостях. Это бывает очень сложно, но многие из лучших своих решений я нашёл именно разбивая циклы.
. После того, как все циклы разбиты, классы должны разбиться на три вида кластеров:
** кластеры классов, от которых ничего не зависит, но которые зависят от почти всех остальных классов (это будут порты и код сборки и инициализации графа объектов вашего приложения, при запуске)
** кластеры классов, которые сами ни от чего не зависят, но от которых зависит почти всё (это будет домен/логика)
** кластеры классов, от которых и зависят и другие классы и которые сами зависят от других классов (это будут порты, юз кейсы и адаптеры). Кластеры должны быть высоко связные (highly cohesive, много связей между классами внутри кластера) и слабо связанные (loosely coupled, мало связей с классами из других кластеров). Вот эти кластеры я и делаю пакетами/модулями.
. Если после разбиения циклов кластеры не выявились, то тут уже надо смотреть каждый конкретный случай и универсального рецепта у меня нет.

= Кодирование

== У класса может быть не более 3 зависимостей

Ну максимум 5:) Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию). Обращение к синглтонам откуда-либо помимо платформы запрещено категорически. Если вашему классу требуется более 3 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.

== Наследование (#todo#)

=== Открытые иерархии

=== Закрытые иерархии

== Избегайте интерфейсов с единственной реализацией (#todo#)
Потому что они создают только видимость барьера и усложняют код. Невозможно сделать настоящий интерфейс по единственной реализации. Интерфейсы в АПИ лучше делать абстракными классами с закрытой реализацией, чтобы клиенты не могли их реализовывать. Интерфейсы в SPI - норм.

== Иммутабельность по дефолту (#todo:#)

== Domain Specific Languages (#todo#)

== Типизированные ИДы (#todo:#)
Типобезопасность и проще грепать логи

= Тестирование (#todo#)

== TDD? (#todo#)

= Заключение

Адекватная архитектура рассматривает систему как набор юз кейсов. Каждый юз кейс реализуются набором компонент различных типов: платформа, порты, юз кейсы, адаптеры и логика. Каждый из типов может содержать либо ввод-вывод, либо логику.

Адекватная архитектура делает два акцента:

. Описание всех эффектов юз кейса должно содержаться в одном месте
. Необходимо разделять логику и ввод-вывод

Первый акцент упрощает понимание системы и то, как та или иная доработка повлияет на видимые эффекты, что способствует уменьшению количества ошибок, допускаемых в ходе модификации системы. Второй акцент позволяет покрыть систему надёжным набором тестов, что так же способствует и простоте понимания системы (за счёт документирования системы по средствам тестов) и уменьшению количества ошибок.

В итоге стоимость разработки системы уменьшается, а её качество увеличивается.

[appendix]
= Примеры (#todo#)

 * ГУЙ
 * Низкоуровневое программирование
 * микросервисы
 * консольный уй
 * рекативность
 * Плагины билд систем
 * Распределённые кластеры

=== qbit (#todo#)
 * Факторизация кубита

=== Q5 (#todo#)
 * Отчёты тредс

=== Удобно (#todo#)

=== Курилка (#todo#)
"Курилка - это бизнес чат.
Это реальный проприетарный проект, поэтому все не значащие в контексте данной книги части закупюрины либо изменены.
Суть проекта - есть фронт сайт, которым пользуются клиенты компании, на фронт сайте есть виджет чата, с другой стороны есть бэк сайт, которым пользуются операторы.
Есть бэк, который связывает виджет на фронт сайте и бэк сайт.
Есть бэк фронт сайта, который реализует основной бизнес компании.

Система реализована на Java/Spring/JPA, с типовой слоёной архитектурой.
Между бэк сайтом и бэком установлено веб-сокетное соединение.

У "Курилки", есть АПИ, позволяющее выполнять некоторые действия напрямую, в обход бэк сайта.

==== Юз кейс: КПИ операторов
Одной из фич "Курилки" является подсчёт КПИ операторов, среди которых есть длительность текущей схемы.
Это значение сохраняется при перерыве в работе менее часа.

В реальной системе фича реализована так:

. Доменному классу юзера добавили поле со временем начала работы.
. Переиспользовали существующую таблицу таймаутов, куда начали складывать, момент сброса времени начала работы оператора.
. При логине (подключении по веб сокету), проверялось наличие таймаута сброса,
.. если он был, то подсчитывался обновлённый КПИ и отправлялся на фронт
.. в противном случае, обновлялось значение времени начала работы
. При логауте (отключении от веб сокета), заводился таймер сброса времени начала работы.

В этой функциональности зарылся неожиданный баг.
Некоторые новые (ни разу не логинвшиеся) операторы не могли подключиться, потому что каким-то образом у них был заведён таймаут на сброс времени начала работы (что происходит только при логауте), но при этом не было времени начала работы.
Позже выяснилось, что одно из вспомогательных приложений, через АПИ звало логаут этим юзерам, что заводило им таймаут, но из-за того что они ни разу не логинились, им ни разу не простовлялось время начала работы и логика подсчёта КПИ крэшилась, из-за чего ломался логин (п. 3а).

Теперь давайте реализуем этот юз кейс в эргономичном стиле и увидим, как он помог бы избежать этой проблемы и какие дополнительные преимущества принёс бы.

Начнём с того, что сформулируем сам юз кейс (#todo: разботанить как составлять толковые юз кейсы#).

*Цель:* Я как оператор хочу видеть длительность своей рабочей смены.

*Рабочая смена*: Один или более подряд идущих периодов времени нахождения оператора онлайн, с перерывами не более 60 минут.

*События*:

. Логин оператора
. Запрос КПИ
. Логаут оператора
. Разрыв соединения

*Эффекты*:

. Отображение текущих показателей оператора в браузере по запросу и при начале нового периода в рамках одной смены.

*Технические эффекты*: #todo: оно надо?#

. Пачка всякий загрузок из БД
. Отправление сообщения по сокету
. Сохранение чего-то в БД?

*Алгоритм*:

. При логине оператора
.. Если нет существующей смены (первый логин оператора в системе), то начать рабочую смену, и зафиксировать время её начала
.. Если существующая смена есть и время логаута менее часа назад (возврат оператора с обеда), то отправить агенту его текщие показатели КПИ.
.. Если существующая смена есть, и время логаута более часа назад (начало новой смены), то зафиксировать начало новой смены
. При логауте и разрыве соединения, зафиксировать время события
. При запросе КПИ оператора, вычислить текущие показатели КПИ и отправить в браузер.

Глядя на этот юз кейс, лично у меня появляется одно желание - завести класс рабочей смены. Давайте так и поступим:
.WorkShift.java
[source,java]
----
public class WorkShift {

    private final @Nonnull UserApiService userApiService;

    private final @Nonnull User user;

    private final @Nonnull Duration maxInterruptionLen;

    private Instant @Nonnull startTime;

    private Instant finishTime;

    public WorkShift(@Nonnull KWebSocket kWebSocket, @Nonnull User user, @Nonnull Instant startTime, @Nonnull Duration maxInterruptionLen) {
        this.userApiService = userApiService;
        this.user = user;
        this.startTime = startTime;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (finishTime == null) {
            // Первый логин, ничего не делаем
            return;
        }
        final Duration interruptionLen = Duration.between(finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            userApiService.sendKpi(user);
        } else {
            // Начало новой смены
            startTime = Instant.now();
        }
    }

    public void sendKpi() {
        userApiService.sendKpi(user);
    }

    public void onLogout() {
        finishTime = Instant.now();
    }

}
----

Этот класс является добротным объектом в классическом ООП - у него есть настоящее состояние и поведение.
К тому же теперь есть место где можно заэнфорсить инвариант, что время начала смены не налл.
Но у него есть и ряд проблем:

. Этот объект мутабельный и может быть использован в разных тредах, поэтому его надо синхронизировать.
. У него нет однозначной идентичности - это объект текущей рабочей смены и в разные моменты времени он соотвествует разным объектам реального мира.
. В него зашита логика определённого юз кейса.
Если появятся новые требования, связанные с рабочей сменой, например ограничение длительности рабочей смены, то эту логику также придётся добавить в этот объект, что снизит его связность (cohesion).
. Он нарушает принцип трёх зависимостей.

Для решения этих проблем воспользуемся принципами DCI и неизменяемости:

. Оставим WorkShift простым доменным объектом и сделаем его неизменяемым
. Логику вынесем в роль KpiTracker
.
[Note]
====
Удивительно, как DCI всё ставит на свои места. Я долгое время руководствовался эвристикой, что класс с именем заканчивающимся на *er (все возможные Controllers, Managers, Drivers, Updaters и т.д.) указывает на проблемы в дизайне, потому что как правило это были пакеты процедур управляющие структурами данных.

Роль же с именем *er является вполне логичной и является одним из аспектов поведения объекта, который манипулирует состоянием того же объекта.
====

.WorkShift.java
[source,java]
----
public class WorkShift {

    @Nonnull Instant startTime;

    @Nullable Instant finishTime;

    public WorkShift(@Nonnull Instant startTime) {
        this.startTime = startTime;
    }

    public WorkShift(@Nonnull Instant startTime, @Nonnull Instant finishTime) {
        this.startTime = startTime;
        this.finishTime = finishTime;
    }

    public WorkShift finish(Instant finishTime) {
        return new WorkShift(startTime, finishTime);
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    private final User user;

    private final KWebSocket kWebSocket;

    private final Duration maxInterruptionLen;

    private WorkShift workShift;

    public KpiTracker(User user, WorkShift prev, KWebSocket kWebSocket, Duration maxInterruptionLen) {
        this.user = user;
        this.workShift = prev;
        this.kWebSocket = kWebSocket;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (workShift == null) {
            // Первый логин оператора, ничего не делаем
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        if (workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        final Duration interruptionLen = Duration.between(workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            kWebSocket.sendKpi(user);
        } else {
            // Начало новой смены
            workShift = new WorkShift(user, Instant.now());
        }
    }

    public void sendKpi() {
        kWebSocket.sendKpi(user);
    }

    public void onLogout() {
        workShift = workShift.finish(Instant.now());
    }

}
----

Рассмотрим, как новая версия решает обозначенные выше проблемы:

. Синхрозицаия: теперь WorkShift иммутабельный, а KpiTracker создаётся для каждого треда по отдельности
. Идентичность: рабочая смена стала вэлью объектом и больше не имеет идентичности.
Эта версия кода подсветила новый объект - рабочая смена оператора.
У него уже вполне понятная идентичность, которая определяется ключём (user, workShift.startTime).
Следующим шагом выделим этот класс.
. Теперь логика юз кейса находится в отдельном классе.
Если потребуется добавить логику ограничения смены, то она пойдёт в отдельный класс TimeShiftLimiter.
Каждый из этих классов будет описывать отдельный юз кейс и будет иметь высокую связность (cohesion).
. Принцип трёх зависимостей остался нарушен, но мы это исправим, создав класс `UserWorkShift`.

Кроме того, в новой версии стала Очевидна вероятность возникновения ошибочной ситуации повторного логина без предварительного логаута - в первой версии они была скрыта обработкой первого логина оператора в системе.

Теперь давайте выделим `UserWorkShift`:
.UserWorkShift.java
[source,java]
----
public class UserWorkShift {

    @Nonnull public final User user;

    @Nullable public final WorkShift workShift;

    public UserWorkShift(@Nonnull User user, @Nullable WorkShift workShift) {
        this.user = user;
        this.workShift = workShift;
    }

    public UserWorkShift startNewWorkShift() {
        return new UserWorkShift(user, new WorkShift(Instant.now()));
    }

    public UserWorkShift finish(Instant finishTime) {
        if (workShift == null) {
            throw new IllegalStateException("Cannot finish work shift for user, who doesn't start any yet");
        }
        return new UserWorkShift(user, new WorkShift(workShift.startTime, finishTime));
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    private final KWebSocket kWebSocket;

    private final Duration maxInterruptionLen;

    private UserWorkShift userWorkShift;

    public KpiTracker(UserWorkShift prevWorkShift, KWebSocket kWebSocket, Duration maxInterruptionLen) {
        this.userWorkShift = prevWorkShift;
        this.kWebSocket = kWebSocket;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (userWorkShift.workShift == null) {
            // Первый логин оператора, ничего не делаем
            userWorkShift = userWorkShift.startNewWorkShift();
            return;
        }

        if (userWorkShift.workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = userWorkShift.startNewWorkShift();
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            kWebSocket.sendKpi(userWorkShift.user);
        } else {
            // Начало новой смены
            userWorkShift = userWorkShift.startNewWorkShift();
        }
    }

    public void sendKpi() {
        kWebSocket.sendKpi(userWorkShift.user);
    }

    public void onLogout() {
        if (userWorkShift.workShift == null) {
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
    }

}
----

Этот рефакторинг, по мимо решения проблем с идентичностью и зависимостями, сделал Очевидным то, что в нашей системе есть потенциальная возможность позвать логин юзеру, который ни разу не логинился.
Так же он подсветил дублирование кода начала рабочей смены и создал место куда естественным образом ложится код начала рабочей смены.
Замена вызова конструктора на метод `UserWorkShigt.start()` сделала интерфейс симметричным, а по моему опыту симметрия обычно говорит о движении в правильном направлении.
Теперь форма кода мне кажется достаточно хорошей и мы готовы двинуться дальше.

Сейчас неочевидно, где хранится информация о рабочих сменах.
Переживёт ли она перезапуск приложения?
А должна.
И, если честно, информация ещё не хранится ни где - ведь у нас не порта, который бы создавал юз кейс.
Давайте создадим репозиторий рабочих расписаний и сделаем эффекты по загрузке и сохранению рабочих расписаний очевидными:

.UserWorkShiftRepository.java
[source,java]
----
// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс
public class UserWorkShiftRepository {

    public UserWorkShift getByUserId(Long userId) {
        // ...
    }

    public UserWorkShift save(@Nonnull UserWorkShift userWorkShift) {
        // ...
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    private final KWebSocket kWebSocket;

    private final UserWorkShiftRepository userWorkShiftRepository;

    private final Duration maxInterruptionLen;

    private UserWorkShift userWorkShift;

    public KpiTracker(Long userId, UserWorkShiftRepository userWorkShiftRepository, KWebSocket kWebSocket, Duration maxInterruptionLen) {
        this.userWorkShiftRepository = userWorkShiftRepository;
        this.userWorkShift = userWorkShiftRepository.getByUserId(userId);
        this.kWebSocket = kWebSocket;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (userWorkShift.workShift == null) {
            // Первый логин оператора, ничего не делаем
            userWorkShift = userWorkShift.startNewWorkShift();
            userWorkShiftRepository.save(userWorkShift);
            return;
        }

        if (userWorkShift.workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = userWorkShift.startNewWorkShift();
            userWorkShiftRepository.save(userWorkShift);
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            kWebSocket.sendKpi(userWorkShift.user);
        } else {
            // Начало новой смены
            userWorkShift = userWorkShift.startNewWorkShift();
            userWorkShiftRepository.save(userWorkShift);
        }
    }

    public void sendKpi() {
        kWebSocket.sendKpi(userWorkShift.user);
    }

    public void onLogout() {
        if (userWorkShift.workShift == null) {
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
        userWorkShiftRepository.save(userWorkShift);
    }

}
----

В этой реализации есть три проблемы:
. Она снова нарушает принцип трёх зависимостей
. При логине сохранение рабочей смены встречается 3 раза
. Метод логина начал нарушать правило логики или эффектов

Для решения первой проблемы воспользуемся Шлюзами из чистой архитектуры, а для решения двух других вынесем бизнес правило определения начала рабочей смены в чистую функцию в `UserWorkShift`.

.KpiGateway.java
[source,java]
----
public class KpiGateway {

    private final KWebSocket kWebSocket;

    private final UserWorkShiftRepository userWorkShiftRepository;

    private final Duration maxInterruptionLen;

    public KpiGateway(KWebSocket kWebSocket, UserWorkShiftRepository userWorkShiftRepository, Duration maxInterruptionLen) {
        this.kWebSocket = kWebSocket;
        this.userWorkShiftRepository = userWorkShiftRepository;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public UserWorkShift getByUserId(Long userId) {
        return userWorkShiftRepository.getByUserId(userId);
    }

    public UserWorkShift save(UserWorkShift userWorkShift) {
        return userWorkShiftRepository.save(userWorkShift);
    }

    public void sendKpi(UserWorkShift userWorkShift) {
        kWebSocket.sendKpi(userWorkShift.user);
    }

    public Duration getMaxInterruptionLen() {
        return maxInterruptionLen;
    }

}
----
.KpiRules.java
[source,java]
----
public class KpiRules {

    public boolean shouldStartNewWorkShift(UserWorkShift currentWorkShift, Duration maxInterruptionLen, Instant now) {
        if (currentWorkShift.workShift == null) {
            // Первый логин оператора, ничего не делаем
            return true;
        }

        if (currentWorkShift.workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            return true;
        }

        final Duration interruptionLen = Duration.between(currentWorkShift.workShift.finishTime, now);
        return interruptionLen.toMillis() >= maxInterruptionLen.toMillis();
    }

}
----
.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final KpiGateway kpiGateway;

    @Nonnull private final KpiRules kpiRules;

    @Nonnull private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull Long userId, @Nonnull KpiGateway kpiGateway, @Nonnull KpiRules kpiRules) {
        this.kpiGateway = kpiGateway;
        this.kpiRules = kpiRules;
        this.userWorkShift = kpiGateway.getByUserId(userId);
    }

    public void onLogin() {
        boolean shouldStartNewWorkShift = kpiRules.shouldStartNewWorkShift(userWorkShift, kpiGateway.getMaxInterruptionLen(), Instant.now());
        if (shouldStartNewWorkShift) {
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
        } else {
            kpiGateway.sendKpi(userWorkShift);
        }
    }

    public void sendKpi() {
        kpiGateway.sendKpi(userWorkShift);
    }

    public void onLogout() {
        if (userWorkShift.workShift == null) {
            return;
        }

        userWorkShift = userWorkShift.finish(Instant.now());
        kpiGateway.save(userWorkShift);
    }

}
----

Отлично, нам не хватает только лишь Порта, для того чтобы получить канонический эргономичный юз кейс, давайте добавим его:
.KpiTracker.java
[source,java]
----
@RestController
public class KpiPort {

    private final AuthService authService;

    private final KpiGateway kpiGateway;

    public KpiPort(AuthService authService, KpiGateway kpiGateway) {
        this.authService = authService;
        this.kpiGateway = kpiGateway;
    }

    @EventListener
    public void onLogin(UserLoginEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(e.userId, kpiGateway, new KpiRules());
        kpiTracker.onLogin();
    }

    @PutMapping(value = "/kpi")
    public void sendKpi() {
        final KpiTracker kpiTracker = new KpiTracker(authService.getCurrentUser().getId(), kpiGateway, new KpiRules());
        kpiTracker.sendKpi();
    }

    @EventListener
    public void onDisconnect(UserDisconnectEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(e.userId, kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }

    @EventListener
    public void onLogout(UserLogoutEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(e.userId, kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }

}
----

Порт вышел тривиальным - таким каким и должен быть.


(#todo: бизенс правило определения рабочей схемы стало очевидным#)
(#todo: пакадж протектед#)

Теперь у нас есть класс рабочей смены, но нам нужен объект.
Этот объект нам нужен в портах логина, запроса КПИ, логаут и дисконнекта.
И задним числом легко говорить, но я думаю, что если бы в оригинальной реализации был объект рабочей смены, то возник бы вопрос: "что делать, если при запросе кпи/логауте/дисконнекте нет текущего расписания?", на этот вопрос был бы дан какой-то адекватный ответ.
Более того, сама ошибка послужившая источником этого примера, просто невозможна в эргономичной версии.

==== Модель состояний оператора (#todo#)

=== Todos (#todo#)

[appendix]
= Дальнейшее чтение (#todo#)

=== Люди

[#apx_peop_uncle_bob]
==== Анкл Боб (#todo:#)

==== Эрик Майер (#todo#)

[#apx_peop_coplien]
==== Джеймс Коплейн (James Coplien)

=== Книги

[#apx_book_ddd]
==== DDD (#todo#)

[#apx_book_object_thinking]
==== Object Thinking (#todo#)

[#apx_book_lean_arch]
==== Lean Architecture for Agile Software Development

=== Научные статьи

=== Публицистические статьи

[#apx_artc_seg]
Segue

=== Доклады

[#apx_talks_dci]
==== DCI: Practical Tips and Lessons for Nerds

Ссылка: https://www.youtube.com/watch?v=SxHqhDT9WGI
