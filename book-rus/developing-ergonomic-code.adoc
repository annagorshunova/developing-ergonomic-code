= Разработка эргономичного кода (Черновик)
Алексей Жидков
Версия 0.0.1, 2020-02-29
:doctype: book
:toc:

toc::[]

= Техническая глава

== Работа не завершена

Этот материал, который пока что скорее является серией статей и заметок находится в разработке.
Я надеюсь, что со временем, он превратится в книгу о том, как разрабатывать "сатисфактори" проекты - проекты которые и разрабатывать приятно и использовать.
Разделы, которые я планирую включить в книгу, я пишу в "совершённом" времени - как будто они часть уже написанной книги.

На момент написания этого материала, я большую часть времени занимаю разработкой бэка на спринге, поэтому есть некоторый перекос в эту сторону.
Но за свою карьеру я участвовал в разработке проектов самых разных типов и изложенные идеи должны быть применимы в целом к разработке софта.
Со временем я обобщу изложенные идеи и приведу примеры их реализации в различных контекстах.

== To do

. Вставить диаграмму кубита, в качестве иллюстрации подхода к разбиению на пакеты
. Разобрать пример с отображением списка (списков дел), либо сообщение о пустом списке
.. Где должен быть этот иф? В юз кейсе или во вью?
.. Что вообще делать с этим ифом? Тащить его отдельно в логику кажется перебором.
. Выброс исключения - это эффект?
. Разбиение цикла между вью и юз кейсом
.. Забить
.. Обсёрвер
.. Возврат экшена в onXXX. Но что делать, если требуется возаимодействие - onDelete -> askConfirmation -> delete. Отдельные эвенты? Корутины?
... Примерно туда же - где должна быть логика запроса подтверждения удаления? В принципе её можно целиком во вью оставить, дёргая юз кейс только при подтверждении. Но Очевидно ли это?
. threads#bd5d4a4e, MessageServiceImpl#setMessageChannel
. Эвент != юз кейс. Эвент - атомарное действие вызываемое обычным событием (сообщением в традиционном ООП), юз кейс - сценарий достижения определённой цели, продвигаемый одним или более событием <<add_talks_dci>>
. Habits <<add_talks_dci>>
. Инклуды юз кейсов вредные, потому что теряют цель <<add_talks_dci>>
. Дизайн - разделение стабильных и изменяющихся частей <<add_talks_dci>>, <<add_peop_uncle_bob>>
. Доменная модель должна быть стабильной <<add_talks_dci>>, <<add_peop_uncle_bob>>
. Традиционные сервисы - жирные DCI Roles?
. Peter Coad, object modelling in code (https://www.infoq.com/articles/domain-color-modeling/)
. Юз кейсы - идеально место для осмысленных комментов. Сейчас стандартный бэк - это в основном набор структур данных и пакетов процедур для манипуляции ими и логику описывать не где. Юз кейсы же кодом описывают связанные куски логики и этот код можно сдобрить хорошим комментом.
. Комменты и коммит мессаджи на русском. Глухой телефон в КБ информ. На английском в опенсорсе, забугорных заказчиках, между народных коммандах.
. Временные таблицы (таблицы с данными не входящими в доменную модель и из которых данные постоянно удаляются) - потенциально скрытые юз кейсы
. Юз кейсы - настоящие объекты, с настоящим состоянием и настоящей логикой и настоящей инкапсуляцией.
. Коплейн <<add_peop_coplien>>: юнит тесты снижают качество кода

= Введение

== Мотивация

Главной мотивацией к написанию этой книги является структурирование собственных мыслей о том как писать эргономичный код.
Кроме того, я использую эту книгу как руководство разработчика в командах, которыми управляю я сам, и как референсный (#todo: корректное слово#) материал в командах под руководством других людей.

Кроме того я уже много лет преподаю различные курсы по программированию и просто довольно много взаимодействую с молодыми программистами.
И в последнее время я начал уставать от пересказа одних и тех же идей по нескольку раз в год и с этой книгой у меня есть единое и "консистентное" (#todo: перевести на русский#) место, куда можно отсылать учеников.

Наконец, опытные разработчики могут найти в этой книге классные, но мало известные идеи, такие как "Data, Context, Interaction Architecture" (#todo: больше жемчужин#).

== Что такое эргономичный код?

(#todo: попровить шрифт цитат#)

Что же такое эргономичный код?
Для начала рассмотрим несколько определений термина "эргономичность" в общем смысле, а потом адаптируем их к коду:
[quote, Большой толковый словарь русского языка]
____
Эргономичность - наличие условий, возможностей для лёгкого, приятного, необременительного пользования чем-либо или удовлетворения каких-либо нужд, потребностей
____

[quote, ISO/IEC 25010]
____
Эргономичность - способность продукта быть понимаемым, изучаемым, используемым и привлекательным для пользователя в заданных условиях
____

[quote, Краткий толковый словарь по полиграфии]
____
Эргономичность - дизайн оборудования, учитывающий взаимодействие человек/машина, позволяющий снизить вероятность ошибки оператора, повысить комфортность условий его работы.
____

[quote, dic.academic.ru]
____
Эргономичность - в изначальном смысле это эффективность инструмента производства или системы в эргономике. Под эффективностью при этом понимается наибольшая производительность при наименьшей вероятности ошибки (пользователя но не устройства). Ныне термин употребляется в более широком смысле, обозначая общую степень удобства предмета (не обязательно средства производства), экономию времени и энергии при использовании предмета. Например: «эргономичный токарный станок», «эргономичный электромобиль» или даже «эргономичный стул».
____

В нашем случае, понятно, пользователем/оператором/человеком будет программист, чем-либо/продуктом/оборудованием/инструментом производства будет код, а пользованием/использованием будет внесение модификаций в код.
В первой цитате, мне нравятся характеристики "лёгкий и приятный в использовании";
В второй цитате, мне нравятся характеристики "понимаемый и изучаемый";
В третьей цитате, мне нравится характеристика "снижающий вероятность ошибки";
Наконец, в четвёртой цитате (помимо уже упомянутой вероятности ошибки) мне нравится характеристика "наибольшая производительность".

Объединив все эти характеристики, получаем следующее определение:
[quote, Алексей Жидков, Разработка эргономичного кода]
____
Эргономичный код - это код, обеспечивающий наибольшую производительность программиста, за счёт простоты понимания и изучения, снижения вероятности внесения ошибки при модификации. Понятный и защищённый от внесения ошибок код, в свою очередь становится лёгким и приятным для внесения изменений.
____

Что же делает код эргономичным? Исчерпывающие автоматизированные тесты (в первую очередь) и очевидность эффектов. Тому что это такое и как этого достичь посвящена вся оставшаяся часть книги.

== Базовые идеи

В адекватной архитектуре нет ничего принципиально нового и она по сути основывается на идеях из следующих следующих хорошо известных (в узких кругах) докладах и статьях:

. Simple Made Easy
. Layered architecture
. Functional core, imperative shell
. Hexagonal architecture
. Onion & Clean architecture
. Railway oriented programming
. Data, Context, interaction architecture

=== Simple Made Easy
https://www.infoq.com/presentations/Simple-Made-Easy/[Simple Made Easy], (https://tonsky.livejournal.com/243192.html[краткий пересказ на русском]).

Из этого доклада я взял то, что "просто" != "легко" и что простые вещи выгоднее в длительной перспективе.

Например, для того чтобы сбросить весь надо следовать двум простым правилам - "меньше жрать", "больше двигаться". Выполнять эти правила сложно, но если сумеете, то решите проблему с весом на всегда. Есть простой путь - липоскакция. Но этот путь даёт временный результат и не решает прочих проблем вызванных "легким" образом жизни.

Не взял я из этого доклада clojure, ядрёную функциональщину; идею того, что типы и тесты не особо уменьшают количество багов; и полный отказ от ОРМов.

=== Layered architecture
https://dzone.com/articles/layered-architecture-is-good[Layered architecture], https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0[слоистая архитектура] - на самом деле никогда не занимался изучением этого вопроса, поэтому взял две первые ссылки в гугле, если подскажите ссылку на хорошую статью посвщяённую этой теме - буду очень благодарен.

Адекватная архитектура в принципе является вариантом слоистой, за исключением того, что убирает зависимость слоя бизнес логики от слоя инфраструктуры/персистанса и поднимает этот слой на один уровень со слоем бизнес логики.

=== Functional core, imperative shell (FCIS)
https://www.youtube.com/watch?v=yTkzNHF6rMs[Boundaries], версии на русском я не нашёл.

Из этого доклада я взял всё. А именно - идеи разделения логики и ввода вывода и использования структур данных в качестве интерфейса между этими частями.

=== Hexagonal (Ports&Adapters) architecture
http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm[Оригинальная статья 2005 года], https://habr.com/ru/post/267125/[описание на русском].

Это первая публикация из серии крайне схожих архитектур - hexagonal, onion и clean (да и FCIS, тоже примерно про тоже, на самом деле). По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.

Отсюда (помимо общей идеи) я позаимствовал термины Порт и Адаптер. Но я их использую в другом смысле:) А до идеи событий приходящих из внешнего мира я додумался сам, когда уже забыл детали этой статьи:)

Не взял я из Hexagonal architecture церемонии с набором порт-интерфейс-адаптер на каждое взаимодействие с платформой и идею о том, что логика приложения окружена "однотипными" портами.

=== Clean architecture, Onion architecture
- https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/[Оригинальная серия статей об Onion Architecture]
- https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Оригинальная статья о Clean Architecture]
- https://habr.com/ru/company/mobileup/blog/335382/[хорошее пояснение Clean Architecture на русском]
- https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164[оригинальная книга о Clean Architecture]
- https://www.ozon.ru/context/detail/id/144499396/[книга на русском о Clean Architecture]

Хотя Onion Architecture появилась раньше, чем Clean (2008 и 2012) и я не вижу совершенно никакой разницы между ними, по моим ощущением более известной стала Clean Architecture и она, пожалуй, самая известная и распространённая из всех базовых идей адекватной архитектуры.

Из этих двух архитектур я взял идеи того, что зависимости должны быть направлены в строну более стабильных модулей; доменная модель и бизнес-логика не должны зависеть ни от чего; фреймворк является деталью, которая должна быть задвинута на задворки. Так же, в том числе и от сюда, я взял понятие юз кейса (интерактора).

Не стал я брать границы в виде интерфейсов между всеми слоями по дефолту и утверждение, что база данных и тип гуя являются незначительными деталями.

Так же дядюшке Бобу над отдать должное за https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[Screaming architecture]. На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы (см из чистой архитектуры).

=== Railway oriented programming
https://fsharpforfunandprofit.com/rop/[Оригинальная статья]

Серия статей о функциональном подходе к обработке ошибок.

Взял идею параллельных рельс для "основного" пути и "ошибочного экспресса". Суть в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса. Плюс за то, чтобы заменять исключения на возвращаемые значения, там где это уместно.

Не стал брать, монады и весь абстрактный ад второго порядка с ними связанный.

=== Data, Context, interaction architecture
https://www.artima.com/articles/dci_vision.html[Оригинальная статья].

На эту идею я наткнулся не давно и ещё её изучаю. Суть в том, чтобы объединять "тупые" доменные объекты с поведением по юз кейсно, с помощью трейтов и тайп классов. Если язык не поддерживает тайп классы и трейты, но поддерживает экстеншн функции, то на них, я думаю, можно будет смастерить чё-нить юзабельное. Я думаю это может стать хорошей техникой реализации юз кейсов и логики.

= Проектирование

== Анатомия системы? (#todo#)

== Анатомия приложения (#todo#)

== Анатомия юз кейса

В адекватной архитектуре программа рассматривается как набор юз кейсов, которые состоят из следующих частей:

- Платформа
- Порты
- Адаптеры
- Юз кейс
- Логика

image::images/aa-use-case.JPG[Устройство юз кейса]

=== Платформа

В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт.

=== Порты

Порт является точкой входа в функцию системы. Его задача - принять вызов, при необходимости сконвертировать входные данные, при необходимости, создать юз кейс, передать в него управление и вернуть результат, при необходимости снова сконвертировав его. В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.

В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат. При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции). Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.

Порт может вызвать только один юз кейс. Если вам надо вызвать два юз кейса, значит у вас есть составной юз кейс.

В некоторых случая на один юз кейс может быть несколько портов, которые переводят управление на разные этапы юзкейса. Может быть и наоборот, несколько портов вызывают один и тот же юз кейс. В этом случае, желательно, но не обязательно, объединять их в одном классе.

=== Юз кейсы

**Todo: акцент на эффектах**


Главной задачей кода реализации юз кейса явлется предельно ясное, декларативное описание юз кейса с точки зрения пользователя и видимых эффектов, к которым приводит его выполнение. В идеале должно быть как в старых добрых книгах по XP и DDD - вы показываете код юзкейса заказчику и он его понимает в общих чертах. Для того чтобы код юз кейса был максимально приближен к языку пользователя, он не должен содержать низкоуровневых деталей и сложной логики. Вся логика юз кейса должна содержаться в одном методе.

Юз кейс может быть как простой (все необходимые данные приходят одним событием), так и составной (для того что бы выполнить юз кейс целиком, необходимо получить несколько связанных событий). Несколько простых юзкейсов можно группировать в один класс (без приватных методов). Составной же юз кейс, должен целиком содержаться в одном отдельном классе и быть единственным содержимым этого класса. Допустимо, чтобы несколько разных портов вызывали один и тот же юз кейс.

Объекты юз кейсов хранят необходимое состояние и связывают адаптеры с логикой. В юз кейсах так же запрещено использование иф-ов и прочих конструкций управления потоком выполнения, за исключением ROP - конструкции вида `if (error) return ErrorData` допустимы. Для обхода этого ограничения можно использовать DSLи:) Так же юз кейсы могут обращаться к юз кейсам более низкого уровня.

Для многошаговых юз кейсов с несколькими портами, мне кажется, может быть возможность их красиво и читаемо оформить в последовательность шагов в одном блоке. Но эту идею я ещё не изучал.

==== Персистентные юз кейсы

В случае когда юз кейс состоит из нескольких шагов, которые инициируются различными событиями во внешней среде, юз кейс может быть сохранён в кэше или в некотором постоянном хранилище в случае распределённой среде. В этом случае порты юз кейса должны будут создавать, сохранять и загружать объекты юз кейсов. Так же в этом случае стоит подумать о синхронизации доступа к объектам юз кейсов.

==== Взаимодействующие с гуём (диалог подтверждения операции)
To do

=== Адаптеры

Единственной задачей адаптеров является инкапсуляция ввода-вывода. Эти единственные компоненты, которым разрешено обращаться к платформе (порты вызываются платформой и ничего о ней не знают). В адаптерах так же как и в портах и из кейсах запрещено использовать управляющие конструкции. Если атомарная с точки зрения операция ввода-вывода требует логики, то эту логику можно либо завернуть в DSL или оформить её как отдельный юз кейс, но это уже будет юз кейс платформы, а не вашей системы.

Наконец поясню смысл запрета на логику в потрах, юз кейсах и адаптерах. Дело в том что все они транзитивно зависят от платформы и ввода-вывода.

Ввод-вывод, в принципе, можно замокать, но я считаю моки плохой практикой. В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга. Плюс они совершенно ничего не говорят о работоспособности вашего кода в реальных условиях.

Так вот если порты, юз кейсы и адаптеры будут простые, то их достаточно будет покрыть минимальным набором интеграционных тестов, для того чтобы быть в них уверенными.

=== Логика

Наконец Логика. Она же Бизнес-Логика, она же домен, она же бизнес-правила. Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения. Но тут есть другое ограничение - логика должны быть чистой в функциональном плане, то есть не иметь наблюдаемых сайд эффектов.

Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д. Нет, всего этого не надо. Любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за. Да же исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них. Ну и да логгирование тоже можно, если оно не является публичной функцией вашей системы. Вобщем, одно правило - каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.

Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами. Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его и сложно и бессмысленно, поэтому единственный вариант - исключить его.

Логика на иллюстрации не просто так больше по размеру всех прочих компонент и имеет самые толстые границы. В идеально реализации адекватной архитектуры именно в логике содержится большая часть кода, и защите логике от внешней среды уделяется особое внимание.

Так же для организации реализации логики я советую присмотреться к идеи DCI. Но сам я ещё не опробовал этот подход в боевых условиях.

== Декомпозиция приложения

=== Разбиение по видам классов

У меня нет однозначного и универсального рецепта разбиения классов по пакетам заранее. Но я точно могу сказать, что не надо разбивать проект по видам классов - entities, services, controllers. В особо одиозных случаях заводят пакеты exceptions, enums и annotations. Пакетов classes и interfaces почему-то ни разу не видел:) В плюсы такого подхода можно попытаться записать только то, что при его использовании не надо думать. Но, во-первых, в нашей работе это минус, а во-вторых, думать всё-таки надо - либо как привести класс к одному из существующих видов, либо придумать новый вид. К дизайну ни та ни другая деятельность отношения не имеет и я считаю, что время лучше посвящать продумыванию дизайна системы.

Проблемы пакетирования по видам классов:

. Не все классы однозначно относятся к одному виду
. Плохо масштабируется
. Скрывает описание архитектуры за деталями реализации
. Изменения одной фичи, как правило затрагивают несколько модулей
. #todo: сложнее рулить логами через стандартные тулы#
. Все више перечисленное - это мелкие не приятности. Действительным же аргументом против такого стиля пакетирования, является то, что он исключает использование ограниченных модификаторов доступа (package private в Java, internal в Kotlin) и вынуждает весь код делать публичным. В итоге границы отсутсвуют в принципе - есть только соглашение о том что из более низких слоёв нельзя обращаться к более высоким. А внутри слоёв и от более высоких к более низким слоям даже никаких соглашений о границах нет. В итоге получается мегамесиво, слегка напоминающие очертаниями снеговик. Это ещё больше усугубляется при использовании спригового компонент скана и иньекции зависимостей на полях.

=== Другие идеи к разбиению классов

Что касается правильного разбиения с самого начала проекта, то за вдохновением советую обратиться к:

- https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33[статье "Four Strategies for Organizing Code"]
- https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[статье "Screaming architecture"]
- и к главе "34 THE MISSING CHAPTER" из книги "Clean Architecture".

=== Мой подход к разбиению классов

[start=0]
. По началу я складываю все классы в один модуль пакет, потому как моя методика требует некоторой критической массы классов, для того чтобы сработать.
. Мою методику можно применять, когда:
** Набралось хотя бы 10, а лучше 20 классов. Но я обычно на интуитивном уровне, чувствую, что пора навести порядок в этом бардаке.
** Когда целиком реализовано 3-5 юз кейсов, среди которых есть и однотипные и ортогональные
. После того как набирается достаточное количество классов, я строю для них https://www.ndepend.com/docs/dependency-structure-matrix-dsm[матрицу зависимостей]. И разбиваю все циклы в зависимостях. Это бывает очень сложно, но многие из лучших своих решений я нашёл именно разбивая циклы.
. После того, как все циклы разбиты, классы должны разбиться на три вида кластеров:
** кластеры классов, от которых ничего не зависит, но которые зависят от почти всех остальных классов (это будут порты и код сборки и инициализации графа объектов вашего приложения, при запуске)
** кластеры классов, которые сами ни от чего не зависят, но от которых зависит почти всё (это будет домен/логика)
** кластеры классов, от которых и зависят и другие классы и которые сами зависят от других классов (это будут порты, юз кейсы и адаптеры). Кластеры должны быть высоко связные (highly cohesive, много связей между классами внутри кластера) и слабо связанные (loosely coupled, мало связей с классами из других кластеров). Вот эти кластеры я и делаю пакетами/модулями.
. Если после разбиения циклов кластеры не выявились, то тут уже надо смотреть каждый конкретный случай и универсального рецепта у меня нет.

= Кодирование

== У класса может быть не более 3 зависимостей

Ну максимум 5:) Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию). Обращение к синглтонам откуда-либо помимо платформы запрещено категорически. Если вашему классу требуется более 3 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.

== Наследование (#todo#)

=== Открытые иерархии

=== Закрытые иерархии

== Избегайте интерфейсов с единственной реализацией (#todo#)
Потому что они создают только видимость барьера и усложняют код. Невозможно сделать настоящий интерфейс по единственной реализации. Интерфейсы в АПИ лучше делать абстракными классами с закрытой реализацией, чтобы клиенты не могли их реализовывать. Интерфейсы в SPI - норм.

== Domain Specific Languages (#todo#)

= Тестирование (#todo#)

== TDD? (#todo#)

= Заключение

Адекватная архитектура рассматривает систему как набор юз кейсов. Каждый юз кейс реализуются набором компонент различных типов: платформа, порты, юз кейсы, адаптеры и логика. Каждый из типов может содержать либо ввод-вывод, либо логику.

Адекватная архитектура делает два акцента:

. Описание всех эффектов юз кейса должно содержаться в одном месте
. Необходимо разделять логику и ввод-вывод

Первый акцент упрощает понимание системы и то, как та или иная доработка повлияет на видимые эффекты, что способствует уменьшению количества ошибок, допускаемых в ходе модификации системы. Второй акцент позволяет покрыть систему надёжным набором тестов, что так же способствует и простоте понимания системы (за счёт документирования системы по средствам тестов) и уменьшению количества ошибок.

В итоге стоимость разработки системы уменьшается, а её качество увеличивается.

= Приложения

== Приложение 1. Примеры (#todo#)

 * ГУЙ
 * Низкоуровневое программирование
 * микросервисы
 * консольный уй
 * рекативность
 * Плагины билд систем
 * Распределённые кластеры

=== qbit (#todo#)
 * Факторизация кубита

=== Q5 (#todo#)
 * Отчёты тредс

=== Удобно (#todo#)

=== Болоболы (#todo#)

=== Todos (#todo#)

== Приложение 2. Дальнейшее чтение (#todo#)

=== Люди

[#add_peop_uncle_bob]
==== Анкл Боб (#todo:#)

==== Эрик Майер (#todo#)

[#add_peop_coplien]
==== Джеймс Коплейн (James Coplien)

=== Научные статьи

=== Публицистические статьи

=== Доклады

[#add_talks_dci]
==== DCI: Practical Tips and Lessons for Nerds

Ссылка: https://www.youtube.com/watch?v=SxHqhDT9WGI
