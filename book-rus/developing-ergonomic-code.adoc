= Разработка эргономичного кода (Черновик)
Алексей Жидков
Версия 0.0.1, 2020-02-29
:doctype: book
:toc:
:source-highlighter: pygments

toc::[]

= Техническая глава

== Работа не завершена

Этот материал, который пока что скорее является серией статей и заметок находится в разработке.
Я надеюсь, что со временем, он превратится в книгу о том, как разрабатывать "сатисфактори" проекты - проекты которые и разрабатывать приятно и использовать.
Разделы, которые я планирую включить в книгу, я пишу в "совершённом" времени - как будто они часть уже написанной книги.

На момент написания этого материала, я большую часть времени занимаю разработкой бэка на спринге, поэтому есть некоторый перекос в эту сторону.
Но за свою карьеру я участвовал в разработке проектов самых разных типов и изложенные идеи должны быть применимы в целом к разработке софта.
Со временем я обобщу изложенные идеи и приведу примеры их реализации в различных контекстах.

== To do

. Вставить диаграмму кубита, в качестве иллюстрации подхода к разбиению на пакеты
. Разобрать пример с отображением списка (списков дел), либо сообщение о пустом списке
.. Где должен быть этот иф? В юз кейсе или во вью?
.. Что вообще делать с этим ифом? Тащить его отдельно в логику кажется перебором.
. Выброс исключения - это эффект?
. Разбиение цикла между вью и юз кейсом
.. Забить
.. Обсёрвер
.. Возврат экшена в onXXX. Но что делать, если требуется возаимодействие - onDelete -> askConfirmation -> delete. Отдельные эвенты? Корутины?
... Примерно туда же - где должна быть логика запроса подтверждения удаления? В принципе её можно целиком во вью оставить, дёргая юз кейс только при подтверждении. Но Очевидно ли это?
. threads#bd5d4a4e, MessageServiceImpl#setMessageChannel
. Эвент != юз кейс. Эвент - атомарное действие вызываемое обычным событием (сообщением в традиционном ООП), юз кейс - сценарий достижения определённой цели, продвигаемый одним или более событием <<apx_talks_dci>>
. Habits <<apx_talks_dci>>
. Инклуды юз кейсов вредные, потому что теряют цель <<apx_talks_dci>>
. Дизайн - разделение стабильных и изменяющихся частей <<apx_talks_dci>>, <<apx_peop_uncle_bob>>
. Доменная модель должна быть стабильной <<apx_talks_dci>>, <<apx_peop_uncle_bob>>
. Традиционные сервисы - жирные DCI Roles?
. Peter Coad, object modelling in code (https://www.infoq.com/articles/domain-color-modeling/)
. Юз кейсы - идеально место для осмысленных комментов. Сейчас стандартный бэк - это в основном набор структур данных и пакетов процедур для манипуляции ими и логику описывать не где. Юз кейсы же кодом описывают связанные куски логики и этот код можно сдобрить хорошим комментом.
. Комменты и коммит мессаджи на русском. Глухой телефон в КБ информ. На английском в опенсорсе, забугорных заказчиках, между народных коммандах.
. Временные таблицы (таблицы с данными не входящими в доменную модель и из которых данные постоянно удаляются) - потенциально скрытые юз кейсы
. Юз кейсы - настоящие объекты, с настоящим состоянием и настоящей логикой и настоящей инкапсуляцией.
. Коплейн <<apx_peop_coplien>>: юнит тесты снижают качество кода
. Изучение домена: <<apx_peop_coplien>>, <<apx_book_ddd>>, <<apx_book_object_thinking>>
. Большинство ошибок находятся во взаимо действии <<apx_artc_seg>>
. "Чем раньше обнаружена ошибка, тем дешевле её исправить" - миф? <<apx_artc_seg>>
. "A proper book isn't just a collection of facts, it reflects cause and mission" <<apx_book_lean_arch>>
. "If we reflect the end user mental model in the code, we are more likely to have working software" <<apx_book_lean_arch>>
. Высокое качество достигается в первую очередь Очевидностью эффектов кода и во вторую покрытием тестами
. Динамическая вс статическая типизация
.. Типы Очевидны
.. Код проще исследовать
.. Типы исключат целый пласт ошибок
.. Юнит тесты не могут исключить те ошибки, которые исключают типы

= Введение

== Мотивация

Я профессионально занимаюсь программированием с 2004 года.
За это время я поработал в пятнадцати командах и больше двадцати проектах.
Это были очень разные проекты - серверные, десктопные, встроенные, мобильные; нацеленные на российский рынок и зарубежный; с командами в одной комнате и распределёнными по континенту и миру; с командами от 2 до 25 человек; написанные с чистого листа и уходящие своими корнями в 80-ые годы ХХ века.
Одно объединяло все эти проекты - их было страшно менять, потому что потрогав одно место, невозможно понять где и что поломалось.
А где-то что-то обязательно ломалось.

Для меня разработка софта это не способ поменять N единиц времени на K единиц денег.
Для меня разработка софта явлется основной областью интересов.
Поэтому я много часов (возможно те самые десять тысяч) провёл в поисках ответов на вопросы "Почему весь нетривиальный софт так сложно понимать и так страшно менять?" и "Как делать софт, котрый легко понимать и безопасно менять?".

Мой ответ на первый вопрос - "Из-за скрытых связей в коде". Мой ответ на второй вопрос - "Делать скрытые связи явными".
В этой книге я привожу концептуальную модель софта и набор практик разработки, которые:
. Делают Очевидным то, какие функции выполняет софт
. Делает Очевидным то, что является входом и выходом каждой функции, выполняемой софтом
. Делает Тестируемым то, что невозможно сделать Очевидным в силу его естественной сложности

Благодаря этому, становится намного проще понять, куда именно необходимо вносить те или иные правки и каковы будут их последствия.
А для сложных частей кода можно быть уверенным в тестах.

Главной мотивацией к написанию этой книги было структурирование собственных мыслей о том, как писать эргономичный код.
Кроме того, мне требовалось руководство разработчика в командах, которыми управляю я сам, и как референсный (#todo: корректное слово#) материал в предложениях по улучшению кода и архитектуры в командах, в которых политику определяют другие люди.

Кроме того я уже много лет преподаю различные курсы по программированию и просто довольно много взаимодействую с молодыми программистами.
И в последнее время я начал уставать от пересказа одних и тех же идей по нескольку раз в год и с этой книгой у меня есть единое и "консистентное" (#todo: перевести на русский#) место, куда можно отсылать учеников.

Я надеюсь, что идеи, описанные в этой книге, найдут широкое распространение, что приведёт к существенному улучшению качества софта которым я пользуюсь сам, и в разработке которого принимаю участие.

== Что такое эргономичный код?

(#todo: попровить шрифт цитат#)

Что же такое эргономичный код?
Для начала рассмотрим несколько определений термина "эргономичность" в общем смысле, а потом адаптируем их к коду:
[quote, Большой толковый словарь русского языка]
____
Эргономичность - наличие условий, возможностей для лёгкого, приятного, необременительного пользования чем-либо или удовлетворения каких-либо нужд, потребностей
____

[quote, ISO/IEC 25010]
____
Эргономичность - способность продукта быть понимаемым, изучаемым, используемым и привлекательным для пользователя в заданных условиях
____

[quote, Краткий толковый словарь по полиграфии]
____
Эргономичность - дизайн оборудования, учитывающий взаимодействие человек/машина, позволяющий снизить вероятность ошибки оператора, повысить комфортность условий его работы.
____

[quote, dic.academic.ru]
____
Эргономичность - в изначальном смысле это эффективность инструмента производства или системы в эргономике. Под эффективностью при этом понимается наибольшая производительность при наименьшей вероятности ошибки (пользователя но не устройства). Ныне термин употребляется в более широком смысле, обозначая общую степень удобства предмета (не обязательно средства производства), экономию времени и энергии при использовании предмета. Например: «эргономичный токарный станок», «эргономичный электромобиль» или даже «эргономичный стул».
____

В нашем случае, понятно, пользователем/оператором/человеком будет программист, чем-либо/продуктом/оборудованием/инструментом производства будет код, а пользованием/использованием будет внесение модификаций в код.
В первой цитате, мне нравятся характеристики "лёгкий и приятный в использовании";
В второй цитате, мне нравятся характеристики "понимаемый и изучаемый";
В третьей цитате, мне нравится характеристика "снижающий вероятность ошибки";
Наконец, в четвёртой цитате (помимо уже упомянутой вероятности ошибки) мне нравится характеристика "наибольшая производительность".

Объединив все эти характеристики, получаем следующее определение:
[quote, Алексей Жидков, Разработка эргономичного кода]
____
Эргономичный код - это код, обеспечивающий наибольшую производительность программиста, за счёт простоты понимания и изучения, снижения вероятности внесения ошибки при модификации. Понятный и защищённый от внесения ошибок код, в свою очередь становится лёгким и приятным для внесения изменений.
____

Что же делает код эргономичным? Исчерпывающие автоматизированные тесты (в первую очередь) и очевидность эффектов. Тому что это такое и как этого достичь посвящена вся оставшаяся часть книги.

== Базовые идеи

В адекватной архитектуре нет ничего принципиально нового и она по сути основывается на идеях из следующих следующих хорошо известных (в узких кругах) докладах и статьях:

. Simple Made Easy
. Layered architecture
. Functional core, imperative shell
. Hexagonal architecture
. Onion & Clean architecture
. Railway oriented programming
. Data, Context, interaction architecture

=== Simple Made Easy
https://www.infoq.com/presentations/Simple-Made-Easy/[Simple Made Easy], (https://tonsky.livejournal.com/243192.html[краткий пересказ на русском]).

Из этого доклада я взял то, что "просто" != "легко" и что простые вещи выгоднее в длительной перспективе.

Например, для того чтобы сбросить весь надо следовать двум простым правилам - "меньше жрать", "больше двигаться". Выполнять эти правила сложно, но если сумеете, то решите проблему с весом на всегда. Есть простой путь - липоскакция. Но этот путь даёт временный результат и не решает прочих проблем вызванных "легким" образом жизни.

Не взял я из этого доклада clojure, ядрёную функциональщину; идею того, что типы и тесты не особо уменьшают количество багов; и полный отказ от ОРМов.

=== Layered architecture
https://dzone.com/articles/layered-architecture-is-good[Layered architecture], https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0[слоистая архитектура] - на самом деле никогда не занимался изучением этого вопроса, поэтому взял две первые ссылки в гугле, если подскажите ссылку на хорошую статью посвщяённую этой теме - буду очень благодарен.

Адекватная архитектура в принципе является вариантом слоистой, за исключением того, что убирает зависимость слоя бизнес логики от слоя инфраструктуры/персистанса и поднимает этот слой на один уровень со слоем бизнес логики.

=== Functional core, imperative shell (FCIS)
https://www.youtube.com/watch?v=yTkzNHF6rMs[Boundaries], версии на русском я не нашёл.

Из этого доклада я взял всё. А именно - идеи разделения логики и ввода вывода и использования структур данных в качестве интерфейса между этими частями.

=== Hexagonal (Ports&Adapters) architecture
http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm[Оригинальная статья 2005 года], https://habr.com/ru/post/267125/[описание на русском].

Это первая публикация из серии крайне схожих архитектур - hexagonal, onion и clean (да и FCIS, тоже примерно про тоже, на самом деле). По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.

Отсюда (помимо общей идеи) я позаимствовал термины Порт и Адаптер. Но я их использую в другом смысле:) А до идеи событий приходящих из внешнего мира я додумался сам, когда уже забыл детали этой статьи:)

Не взял я из Hexagonal architecture церемонии с набором порт-интерфейс-адаптер на каждое взаимодействие с платформой и идею о том, что логика приложения окружена "однотипными" портами.

=== Clean architecture, Onion architecture
- https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/[Оригинальная серия статей об Onion Architecture]
- https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html[Оригинальная статья о Clean Architecture]
- https://habr.com/ru/company/mobileup/blog/335382/[хорошее пояснение Clean Architecture на русском]
- https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164[оригинальная книга о Clean Architecture]
- https://www.ozon.ru/context/detail/id/144499396/[книга на русском о Clean Architecture]

Хотя Onion Architecture появилась раньше, чем Clean (2008 и 2012) и я не вижу совершенно никакой разницы между ними, по моим ощущением более известной стала Clean Architecture и она, пожалуй, самая известная и распространённая из всех базовых идей адекватной архитектуры.

Из этих двух архитектур я взял идеи того, что зависимости должны быть направлены в строну более стабильных модулей; доменная модель и бизнес-логика не должны зависеть ни от чего; фреймворк является деталью, которая должна быть задвинута на задворки. Так же, в том числе и от сюда, я взял понятие юз кейса (интерактора).

Не стал я брать границы в виде интерфейсов между всеми слоями по дефолту и утверждение, что база данных и тип гуя являются незначительными деталями.

Так же дядюшке Бобу над отдать должное за https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[Screaming architecture]. На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы (см из чистой архитектуры).

=== Railway oriented programming
https://fsharpforfunandprofit.com/rop/[Оригинальная статья]

Серия статей о функциональном подходе к обработке ошибок.

Взял идею параллельных рельс для "основного" пути и "ошибочного экспресса". Суть в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса. Плюс за то, чтобы заменять исключения на возвращаемые значения, там где это уместно.

Не стал брать, монады и весь абстрактный ад второго порядка с ними связанный.

=== Data, Context, interaction architecture
https://www.artima.com/articles/dci_vision.html[Оригинальная статья].

На эту идею я наткнулся не давно и ещё её изучаю. Суть в том, чтобы объединять "тупые" доменные объекты с поведением по юз кейсно, с помощью трейтов и тайп классов. Если язык не поддерживает тайп классы и трейты, но поддерживает экстеншн функции, то на них, я думаю, можно будет смастерить чё-нить юзабельное. Я думаю это может стать хорошей техникой реализации юз кейсов и логики.

= Проектирование

[quote,]
[quote, IEEE1471 2007]
____
... The fundamental organiztion of a system embodien in its components, their relationships to each oterh, and to the environment and the principles guiding its design and evolution
____

[quote, Booch 2006]
____
Architecture represents the significant design decisioins that shape a system, where significiant is measured by cost of change
____
[quote, Coplien, Lean Architecture]
____
the form of a system, where the word form has a special meainign that we'll explore a bit later. (p. 2)
____

[quote, Uncle Bob]
____
(#todo:#)
____

== Анатомия системы? (#todo#)

== Анатомия приложения (#todo#)

== Анатомия юз кейса

В адекватной архитектуре программа рассматривается как набор юз кейсов, которые состоят из следующих частей:

- Платформа
- Порты
- Адаптеры
- Юз кейс
- Логика

image::images/aa-use-case.JPG[Устройство юз кейса]

=== Платформа

В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие со внешним миром и у этого взаимодействия, по сути есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт.

=== Порты

Порт является точкой входа в функцию системы. Его задача - принять вызов, при необходимости сконвертировать входные данные, при необходимости, создать юз кейс, передать в него управление и вернуть результат, при необходимости снова сконвертировав его. В коде портов не должно быть никакой логики - ифов, форов, вызовов приватных методов.

В вырожденных случаях (например CRUD операция), я не вижу особого криминала, в том, чтобы смёржить порт и юзкейс и из порта обратиться непосредственно в адаптер и вернуть результат. При условии, что соблюдается запрет на логику в порте (включая логику выраженную декларативно - читай транзакции). Так же не стоит в одном классе смешивать выделенные порты и порты-юзкейсы.

Порт может вызвать только один юз кейс. Если вам надо вызвать два юз кейса, значит у вас есть составной юз кейс.

В некоторых случая на один юз кейс может быть несколько портов, которые переводят управление на разные этапы юзкейса. Может быть и наоборот, несколько портов вызывают один и тот же юз кейс. В этом случае, желательно, но не обязательно, объединять их в одном классе.

=== Юз кейсы

**Todo: акцент на эффектах**


Главной задачей кода реализации юз кейса явлется предельно ясное, декларативное описание юз кейса с точки зрения пользователя и видимых эффектов, к которым приводит его выполнение. В идеале должно быть как в старых добрых книгах по XP и DDD - вы показываете код юзкейса заказчику и он его понимает в общих чертах. Для того чтобы код юз кейса был максимально приближен к языку пользователя, он не должен содержать низкоуровневых деталей и сложной логики. Вся логика юз кейса должна содержаться в одном методе.

Юз кейс может быть как простой (все необходимые данные приходят одним событием), так и составной (для того что бы выполнить юз кейс целиком, необходимо получить несколько связанных событий). Несколько простых юзкейсов можно группировать в один класс (без приватных методов). Составной же юз кейс, должен целиком содержаться в одном отдельном классе и быть единственным содержимым этого класса. Допустимо, чтобы несколько разных портов вызывали один и тот же юз кейс.

Объекты юз кейсов хранят необходимое состояние и связывают адаптеры с логикой. В юз кейсах так же запрещено использование иф-ов и прочих конструкций управления потоком выполнения, за исключением ROP - конструкции вида `if (error) return ErrorData` допустимы. Для обхода этого ограничения можно использовать DSLи:) Так же юз кейсы могут обращаться к юз кейсам более низкого уровня.

Для многошаговых юз кейсов с несколькими портами, мне кажется, может быть возможность их красиво и читаемо оформить в последовательность шагов в одном блоке. Но эту идею я ещё не изучал.

==== Персистентные юз кейсы

В случае когда юз кейс состоит из нескольких шагов, которые инициируются различными событиями во внешней среде, юз кейс может быть сохранён в кэше или в некотором постоянном хранилище в случае распределённой среде. В этом случае порты юз кейса должны будут создавать, сохранять и загружать объекты юз кейсов. Так же в этом случае стоит подумать о синхронизации доступа к объектам юз кейсов.

==== Взаимодействующие с гуём (диалог подтверждения операции)
To do

=== Адаптеры

Единственной задачей адаптеров является инкапсуляция ввода-вывода. Эти единственные компоненты, которым разрешено обращаться к платформе (порты вызываются платформой и ничего о ней не знают). В адаптерах так же как и в портах и из кейсах запрещено использовать управляющие конструкции. Если атомарная с точки зрения операция ввода-вывода требует логики, то эту логику можно либо завернуть в DSL или оформить её как отдельный юз кейс, но это уже будет юз кейс платформы, а не вашей системы.

Наконец поясню смысл запрета на логику в потрах, юз кейсах и адаптерах. Дело в том что все они транзитивно зависят от платформы и ввода-вывода.

Ввод-вывод, в принципе, можно замокать, но я считаю моки плохой практикой. В этом случае ваши тесты завязываются на реализацию тестируемого кода - они начинают зависеть от того, что и в каком порядке он вызывает, и требуют обработки напильником после каждого рефакторинга. Плюс они совершенно ничего не говорят о работоспособности вашего кода в реальных условиях.

Так вот если порты, юз кейсы и адаптеры будут простые, то их достаточно будет покрыть минимальным набором интеграционных тестов, для того чтобы быть в них уверенными.

=== Логика

Наконец Логика. Она же Бизнес-Логика, она же домен, она же бизнес-правила. Вот здесь уже нет никаких ограничений на конструкции управления - можно оторваться за все лишения. Но тут есть другое ограничение - логика должны быть чистой в функциональном плане, то есть не иметь наблюдаемых сайд эффектов.

Логика не должна быть реализована в идиоматичном функциональном стиле - весь код в функциях, без переменных, только с неизменяемыми структурами данных, с монадами и их интерпретаторами, трнасдьсерами, зипперами и т.д. Нет, всего этого не надо. Любите классы и объекты - пожалуйста, императивные форы и ифы - я не против, изменяемые локальные переменные и массивы ради эффективности - я только за. Да же исключения и try-catch можно, но я бы хорошенько подумал, как обойтись без них. Ну и да логгирование тоже можно, если оно не является публичной функцией вашей системы. Вобщем, одно правило - каждая функция или метод для одних и тех же параметров должна всегда возвращать одно и то же значение.

Это ограничение основано на той же мотивации - сложная логика должна быть исчерпывающе покрыта тестами. Ввод-вывод исчерпывающе покрыть тестами сложно, замокать его и сложно и бессмысленно, поэтому единственный вариант - исключить его.

Логика на иллюстрации не просто так больше по размеру всех прочих компонент и имеет самые толстые границы. В идеально реализации адекватной архитектуры именно в логике содержится большая часть кода, и защите логике от внешней среды уделяется особое внимание.

Так же для организации реализации логики я советую присмотреться к идеи DCI. Но сам я ещё не опробовал этот подход в боевых условиях.

== Декомпозиция приложения

=== Разбиение по видам классов

У меня нет однозначного и универсального рецепта разбиения классов по пакетам заранее. Но я точно могу сказать, что не надо разбивать проект по видам классов - entities, services, controllers. В особо одиозных случаях заводят пакеты exceptions, enums и annotations. Пакетов classes и interfaces почему-то ни разу не видел:) В плюсы такого подхода можно попытаться записать только то, что при его использовании не надо думать. Но, во-первых, в нашей работе это минус, а во-вторых, думать всё-таки надо - либо как привести класс к одному из существующих видов, либо придумать новый вид. К дизайну ни та ни другая деятельность отношения не имеет и я считаю, что время лучше посвящать продумыванию дизайна системы.

Проблемы пакетирования по видам классов:

. Не все классы однозначно относятся к одному виду
. Плохо масштабируется
. Скрывает описание архитектуры за деталями реализации
. Изменения одной фичи, как правило затрагивают несколько модулей
. #todo: сложнее рулить логами через стандартные тулы#
. Все више перечисленное - это мелкие не приятности. Действительным же аргументом против такого стиля пакетирования, является то, что он исключает использование ограниченных модификаторов доступа (package private в Java, internal в Kotlin) и вынуждает весь код делать публичным. В итоге границы отсутсвуют в принципе - есть только соглашение о том что из более низких слоёв нельзя обращаться к более высоким. А внутри слоёв и от более высоких к более низким слоям даже никаких соглашений о границах нет. В итоге получается мегамесиво, слегка напоминающие очертаниями снеговик. Это ещё больше усугубляется при использовании спригового компонент скана и иньекции зависимостей на полях.

=== Другие идеи к разбиению классов

Что касается правильного разбиения с самого начала проекта, то за вдохновением советую обратиться к:

- https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33[статье "Four Strategies for Organizing Code"]
- https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html[статье "Screaming architecture"]
- и к главе "34 THE MISSING CHAPTER" из книги "Clean Architecture".

=== Мой подход к разбиению классов

[start=0]
. По началу я складываю все классы в один модуль пакет, потому как моя методика требует некоторой критической массы классов, для того чтобы сработать.
. Мою методику можно применять, когда:
** Набралось хотя бы 10, а лучше 20 классов. Но я обычно на интуитивном уровне, чувствую, что пора навести порядок в этом бардаке.
** Когда целиком реализовано 3-5 юз кейсов, среди которых есть и однотипные и ортогональные
. После того как набирается достаточное количество классов, я строю для них https://www.ndepend.com/docs/dependency-structure-matrix-dsm[матрицу зависимостей]. И разбиваю все циклы в зависимостях. Это бывает очень сложно, но многие из лучших своих решений я нашёл именно разбивая циклы.
. После того, как все циклы разбиты, классы должны разбиться на три вида кластеров:
** кластеры классов, от которых ничего не зависит, но которые зависят от почти всех остальных классов (это будут порты и код сборки и инициализации графа объектов вашего приложения, при запуске)
** кластеры классов, которые сами ни от чего не зависят, но от которых зависит почти всё (это будет домен/логика)
** кластеры классов, от которых и зависят и другие классы и которые сами зависят от других классов (это будут порты, юз кейсы и адаптеры). Кластеры должны быть высоко связные (highly cohesive, много связей между классами внутри кластера) и слабо связанные (loosely coupled, мало связей с классами из других кластеров). Вот эти кластеры я и делаю пакетами/модулями.
. Если после разбиения циклов кластеры не выявились, то тут уже надо смотреть каждый конкретный случай и универсального рецепта у меня нет.

= Кодирование

== У класса может быть не более 3 зависимостей

Ну максимум 5:) Под зависимостями я понимаю параметры конструктора, включая примитивные (конфигурацию). Обращение к синглтонам откуда-либо помимо платформы запрещено категорически. Если вашему классу требуется более 3 зависимостей, то он либо делает слишком много, либо делает это использую слишком низкоуровневые примитивы (зависимости), на базе которых надо создать новую абстракцию.

== Наследование (#todo#)

=== Открытые иерархии

=== Закрытые иерархии

== Избегайте интерфейсов с единственной реализацией (#todo#)
Потому что они создают только видимость барьера и усложняют код. Невозможно сделать настоящий интерфейс по единственной реализации. Интерфейсы в АПИ лучше делать абстракными классами с закрытой реализацией, чтобы клиенты не могли их реализовывать. Интерфейсы в SPI - норм.

== Иммутабельность по дефолту (#todo:#)

== Domain Specific Languages (#todo#)

== Типизированные ИДы (#todo:#)
Типобезопасность и проще грепать логи

= Тестирование (#todo#)

== TDD? (#todo#)

== Ассерты (#todo:#)

== Контракты (#todo:#)

= Заключение

Адекватная архитектура рассматривает систему как набор юз кейсов. Каждый юз кейс реализуются набором компонент различных типов: платформа, порты, юз кейсы, адаптеры и логика. Каждый из типов может содержать либо ввод-вывод, либо логику.

Адекватная архитектура делает два акцента:

. Описание всех эффектов юз кейса должно содержаться в одном месте
. Необходимо разделять логику и ввод-вывод

Первый акцент упрощает понимание системы и то, как та или иная доработка повлияет на видимые эффекты, что способствует уменьшению количества ошибок, допускаемых в ходе модификации системы. Второй акцент позволяет покрыть систему надёжным набором тестов, что так же способствует и простоте понимания системы (за счёт документирования системы по средствам тестов) и уменьшению количества ошибок.

В итоге стоимость разработки системы уменьшается, а её качество увеличивается.

[appendix]
= Примеры (#todo#)

 * ГУЙ
 * Низкоуровневое программирование
 * микросервисы
 * консольный уй
 * рекативность
 * Плагины билд систем
 * Распределённые кластеры

=== qbit (#todo#)
 * Факторизация кубита

=== Q5 (#todo#)

=== Удобно (#todo#)

=== Проект ТруСтори
Это вымышленный проект с примерами по мотивам проблем, с которыми я столкнулся у различных заказчиков.

==== Юз кейс: КПИ сотрудников

В этом примере ТруСтори является стандартным бэком на Java/Spring/JPA с веб-фронтом с полнодуплексным соединением (#todo: проверить термин#).

Одной из фич ТруСтори является подсчёт КПИ сотрудников, среди которых есть длительность текущей смены.
Это значение сохраняется при перерыве в работе менее часа.

В реальной системе фича реализована так:

. Доменному классу юзера было добавлено поле со временем начала работы.
. Была переиспользована существующая таблица таймаутов, для того чтобы хранить момент сброса времени начала работы сотрудника.
. При логине, проверяется наличие таймаута сброса,
.. если он есть (что подразумевает, что время логаута не превысило час, т.е. продолжается текущая смена), то подсчитывается обновлённый КПИ и отправляется в браузер
.. в противном случае, обновляется значение времени начала работы
. При логауте, заводится таймер сброса времени начала работы.
. Отдельный тред в фоне удаляет протухшие таймауты из базы.

В этой функциональности зарылся неожиданный баг.
Некоторые новые (ниразу не логинвшиеся) сотрудники не могли подключиться, потому что каким-то образом у них был заведён таймаут на сброс времени начала работы (что происходит только при логауте), но при этом не было времени начала работы (т.е. не было логина).
В процессе расследования выяснилось, что одно из вспомогательных приложений, вело себя не совсем корректно и через АПИ звало логаут этим сотрудникам, что заводило им таймаут, но из-за того что они ни разу не логинились, им ни разу не проставлялось время начала работы и логика подсчёта КПИ крэшилась, из-за чего ломался логин (п. 3а).

Теперь давайте реализуем этот юз кейс в эргономичном стиле и увидим, как он помог бы избежать подобной проблемы и какие дополнительные преимущества принёс бы.

Начнём с того, что сформулируем сам юз кейс (#todo: разботанить как составлять толковые юз кейсы#).

*Цель:* Я как сотрудник хочу видеть длительность своей рабочей смены.

*Рабочая смена*: Один или более подряд идущих периодов времени нахождения сотрудника онлайн, с перерывами не более 60 минут.

*События*:

. Логин сотрудника
. Запрос КПИ
. Штатный логаут сотрудника
. Нештатный логаут сотрудника (закрытие вкладки)

*Эффекты*:

. Отображение текущих показателей сотрудника в браузере по запросу и при начале нового периода в рамках одной смены.

*Технические эффекты*: #todo: оно надо?#

. Пачка всякий загрузок из БД
. Отправление сообщения в браузер
. Сохранение чего-то в БД?

*Алгоритм*:

. При логине сотрудника
.. Если нет существующей смены (первый логин сотрудника в системе), то начать рабочую смену, и зафиксировать время её начала
.. Если существующая смена есть и время логаута менее часа назад (возврат сотрудника с обеда), то отправить сотрудника его текущие показатели КПИ.
.. Если существующая смена есть, и время логаута более часа назад (начало новой смены), то зафиксировать начало новой смены
. При логауте и закрытии вкладки, зафиксировать время события, в качестве потенциального времени окончания смены
. При запросе КПИ сотрудника, вычислить текущие показатели КПИ и отправить в браузер.

Глядя на этот юз кейс, лично у меня появляется одно желание - завести класс рабочей смены. Давайте так и поступим:

.WorkShift.java
[source,java]
----
public class WorkShift {

    private final @Nonnull WebSocket webSocket;

    private final @Nonnull User user;

    private final @Nonnull Duration maxInterruptionLen;

    private Instant @Nonnull startTime;

    private Instant @Nullable finishTime;

    public WorkShift(@Nonnull WebSocket webSocket, @Nonnull User user, @Nonnull Instant startTime, @Nonnull Duration maxInterruptionLen) {
        this.webSocket = webSocket;
        this.user = user;
        this.startTime = startTime;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (finishTime == null) {
            // Первый логин, ничего не делаем
            return;
        }
        final Duration interruptionLen = Duration.between(finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            webSocket.sendKpi(user);
        } else {
            // Начало новой смены
            startTime = Instant.now();
        }
    }

    public void sendKpi() {
        webSocket.sendKpi(user);
    }

    public void onLogout() {
        finishTime = Instant.now();
    }

}
----

Этот класс является не плохим объектом в классическом ООП - у него есть настоящее состояние и настоящее поведение.
К тому же теперь есть место где можно заэнфорсить инвариант, что время начала смены не налл.
Но у него есть и ряд проблем:

. Этот объект мутабельный и может быть использован в разных тредах, поэтому его надо синхронизировать.
. У него нет однозначной идентичности - это объект текущей рабочей смены и в разные моменты времени он соотвествует разным объектам реального мира.
. В него зашита логика определённого юз кейса.
Если появятся новые требования, связанные с рабочей сменой, например ограничение длительности рабочей смены, то эту логику также придётся добавить в этот объект, что снизит его связность (cohesion).
. Он нарушает принцип трёх зависимостей.

Для решения этих проблем воспользуемся принципами DCI и неизменяемости:

. Оставим WorkShift простым доменным объектом и сделаем его неизменяемым
. Логику вынесем в роль KpiTracker

[Note]
====
Удивительно, как DCI всё ставит на свои места. Я долгое время руководствовался эвристикой, что класс с именем заканчивающимся на *er (все возможные Controllers, Managers, Drivers, Updaters и т.д.) указывает на проблемы в дизайне, потому что как правило это были пакеты процедур управляющие структурами данных.

Роль же с именем *er является вполне логичной и является одним из аспектов поведения объекта, который манипулирует состоянием того же объекта.
====

(#todo: чёт с KpiTracker-ом в итоге концептуальное месиво какое-то вышло - он и роль, и юз кейс и контекст, надо выяснить норм ли это#)

.WorkShift.java
[source,java]
----
public class WorkShift {

    @Nonnull Instant startTime;

    @Nullable Instant finishTime;

    public WorkShift(@Nonnull Instant startTime) {
        this.startTime = startTime;
    }

    public WorkShift(@Nonnull Instant startTime, @Nonnull Instant finishTime) {
        this.startTime = startTime;
        this.finishTime = finishTime;
    }

    public WorkShift finish(Instant finishTime) {
        return new WorkShift(startTime, finishTime);
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    private final User user;

    private final WebSocket webSocket;

    private final Duration maxInterruptionLen;

    private WorkShift workShift;

    public KpiTracker(User user, WorkShift prev, WebSocket webSocket, Duration maxInterruptionLen) {
        this.user = user;
        this.workShift = prev;
        this.webSocket = webSocket;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    public void onLogin() {
        if (workShift == null) {
            // Первый логин сотрудника, ничего не делаем
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        if (workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            workShift = new WorkShift(user, Instant.now());
            return;
        }

        final Duration interruptionLen = Duration.between(workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            webSocket.sendKpi(user);
        } else {
            // Начало новой смены
            workShift = new WorkShift(user, Instant.now());
        }
    }

    public void sendKpi() {
        webSocket.sendKpi(user);
    }

    public void onLogout() {
        workShift = workShift.finish(Instant.now());
    }

}
----

Рассмотрим, как новая версия решает обозначенные выше проблемы:

. Синхронизация: теперь `WorkShift` иммутабельный, а `KpiTracker` создаётся для каждого треда по отдельности - ни тот ни другой класс синхронизации больше не требуют.
. Идентичность: рабочая смена стала вэлью объектом и больше не имеет идентичности.
Эта версия кода подсветила новый объект - рабочая смена сотрудника.
У него уже вполне понятная идентичность, которая определяется ключём `(user, startTime)`.
Следующим шагом выделим класс `UserWorkShift`.
. Теперь логика юз кейса находится в отдельном классе.
Если потребуется добавить логику ограничения смены, то она так же пойдёт в отдельный класс `TimeShiftLimiter`.
Каждый из этих классов будет описывать отдельный юз кейс и будет иметь высокую связность (cohesion).
. Принцип трёх зависимостей остался нарушен, но мы это исправим, создав класс `UserWorkShift`.

Кроме того, в новой версии стала Очевидна вероятность возникновения ошибочной ситуации повторного логина без предварительного логаута - в первой версии он была скрыта обработкой первого логина сотрудника в системе.

Теперь давайте выделим `UserWorkShift`.
При попытке выделить `UserWorkShift` обнаружится проблема: при создании `KpiTracker` ещё не понятно, есть ли у сотрудинка активная текущая смена.
Можно попробовать сделать этот параметр нуллабельным, но мы тогда потеряем инфу о сотруднике, и не сможем начать рабочую смену при логине.
Поэтому в конструктор надо передавать сотрудника, для которого будем отслеживать рабочую смену и репозиторий рабочих смен, из-за чего мы снова нарушим правило трёх зависимостей.
Для того чтобы окончательно решить проблему с зависимостями, мы пойдём другим путём - вместо передачи репозитория рабочих смен, воспользуемся техникой шлюза из чистой архитектуры и все нужные зависимости скроем за одним интерфейсом.

.UserWorkShiftRepository.java
[source,java]
----
// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс
new UserWorkShift(user, Instant.now());
public class UserWorkShiftRepository {

    @Nullable
    public UserWorkShift getByUserId(Long userId) {
        return null;
    }

}
----
.KpiGateway.java
[source,java]
----
public class KpiGateway {

    private final UserWorkShiftRepository userWorkShiftRepository;

    private final Duration maxInterruptionLen;

    public KpiGateway(UserWorkShiftRepository userWorkShiftRepository, Duration maxInterruptionLen) {
        this.userWorkShiftRepository = userWorkShiftRepository;
        this.maxInterruptionLen = maxInterruptionLen;
    }

    @Nullable
    public UserWorkShift getByUser(User user) {
        return userWorkShiftRepository.getByUserId(user.getId());
    }

    public void sendKpi(@Nonnull UserWorkShift userWorkShift) {
        // sendKpi
    }

    public Duration getMaxInterruptionLen() {
        return maxInterruptionLen;
    }

}

----
.UserWorkShift.java
[source,java]
----
public class UserWorkShift {

    @Nonnull public final User user;

    @Nonnull public final Instant startTime;

    @Nullable public final Instant finishTime;

    public UserWorkShift(@Nonnull User user, @Nonnull Instant startTime) {
        this(user, startTime, null);
    }

    public UserWorkShift(@Nonnull User user, @Nonnull Instant startTime, @Nullable Instant finishTime) {
        this.user = user;
        this.startTime = startTime;
        this.finishTime = finishTime;
    }

    public UserWorkShift finish(Instant finishTime) {
        return new UserWorkShift(user, startTime, finishTime);
    }

}
----

.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final User user;

    @Nonnull private final KpiGateway kpiGateway;

    @Nullable private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull User user, @Nonnull KpiGateway kpiGateway) {
        this.user = user;
        this.kpiGateway = kpiGateway;
        userWorkShift = kpiGateway.getByUser(user);
    }

    public void onLogin() {
        if (userWorkShift == null) {
            // Первый логин сотрудника, ничего не делаем
            userWorkShift = new UserWorkShift(user, Instant.now());
            return;
        }

        if (userWorkShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = new UserWorkShift(user, Instant.now());
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < kpiGateway.getMaxInterruptionLen().toMillis()) {
            // Продолжение смены
            kpiGateway.sendKpi(userWorkShift);
        } else {
            // Начало новой смены
            userWorkShift =  new UserWorkShift(user, Instant.now());
        }
    }

    public void sendKpi() {
        if (userWorkShift == null) {
            // Ошибка - запрос на отравку КПИ для ни разу не логиневшегося сотрудника
            return;
        }
        kpiGateway.sendKpi(userWorkShift);
    }

    public void onLogout() {
        if (userWorkShift == null) {
            // Ошибка - логаут ни разу не логиневшегося сотрудника
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
    }

}
----

Так же этот рефакторинг, по мимо решения проблем с идентичностью и зависимостями, сделал Очевидным то, что в нашей системе есть потенциальная возможность позвать логаут сотруднику, который ни разу не логинился.

Внимательный читатель, наверное заметил, что мы сейчас только загружаем смены из репозитория, но никогда их не сохраняем.
Давайте добавим в репозиторий возможность сохранения смен и сделаем эффекты по загрузке и сохранению рабочих расписаний симметричными и Очевидными:

.UserWorkShiftRepository.java
[source,java]
----
// Т.к. реализация репозитория не имеет особого значения, привожу только интерфейс
public class UserWorkShiftRepository {

    // ...

    public UserWorkShift save(@Nonnull UserWorkShift userWorkShift) {
        // ...
    }

    // ...

}
----
.KpiGateway.java
[source,java]
----
public class KpiGateway {

    // ...

    public UserWorkShift save(UserWorkShift userWorkShift) {
        return userWorkShiftRepository.save(userWorkShift);
    }

    // ...
}
----
.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final User user;

    @Nonnull private final KpiGateway kpiGateway;

    @Nullable private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull User user, @Nonnull KpiGateway kpiGateway) {
        this.user = user;
        this.kpiGateway = kpiGateway;
        userWorkShift = kpiGateway.getByUser(user);
    }

    public void onLogin() {
        if (userWorkShift.workShift == null) {
            // Первый логин сотрудника, ничего не делаем
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
            return;
        }

        if (userWorkShift.workShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
            return;
        }

        final Duration interruptionLen = Duration.between(userWorkShift.workShift.finishTime, Instant.now());
        if (interruptionLen.toMillis() < maxInterruptionLen.toMillis()) {
            // Продолжение смены
            kpiGateway.sendKpi(userWorkShift.user);
        } else {
            // Начало новой смены
            userWorkShift = userWorkShift.startNewWorkShift();
            kpiGateway.save(userWorkShift);
        }
    }

    // ...

    public void onLogout() {
        if (userWorkShift == null) {
            // Ошибка - логаут ни разу не логиневшегося сотрудника
            return;
        }
        userWorkShift = userWorkShift.finish(Instant.now());
        kpiGateway.save(userWorkShift);
    }

}
----

В этой реализации есть две новые проблемы:

. При логине сохранение рабочей смены дублируется 3 раза
. Метод логина начал нарушать правило логики или эффектов - логика определения начала смены не совсем тривиальная и её хочется покрыть тестами, но это невозможно не замокав `kpiGateway`.

Для решения этих проблем вынесем бизнес правило определения начала рабочей смены в чистую функцию предметной области в классе `KpiRules`.

.KpiRules.java
[source,java]
----
public class KpiRules {

    public boolean shouldStartNewWorkShift(UserWorkShift currentWorkShift, Duration maxInterruptionLen, Instant now) {
        if (currentWorkShift == null) {
            // Первый логин сотрудника, ничего не делаем
            return true;
        }

        if (currentWorkShift.finishTime == null) {
            // Ошибка - повторынй логин после начала смены, без предварительного логаута
            return true;
        }

        final Duration interruptionLen = Duration.between(currentWorkShift.finishTime, now);
        return interruptionLen.toMillis() >= maxInterruptionLen.toMillis();
    }

}
----
.KpiTracker.java
[source,java]
----
public class KpiTracker {

    @Nonnull private final KpiGateway kpiGateway;

    @Nonnull private final KpiRules kpiRules;

    @Nonnull private UserWorkShift userWorkShift;

    public KpiTracker(@Nonnull Long userId, @Nonnull KpiGateway kpiGateway, @Nonnull KpiRules kpiRules) {
        this.kpiGateway = kpiGateway;
        this.kpiRules = kpiRules;
        this.userWorkShift = kpiGateway.getByUserId(userId);
    }

    public void onLogin() {
        UserWorkShift currentWorkShift = userWorkShift();

        boolean shouldStartNewWorkShift = kpiRules.shouldStartNewWorkShift(currentWorkShift, kpiGateway.getMaxInterruptionLen(), Instant.now());
        Assert.isTrue(currentWorkShift != null || shouldStartNewWorkShift, "KPI rules has decided to not start new work shift on login of user without active work shift");

        if (shouldStartNewWorkShift) {
            currentWorkShift = new UserWorkShift(user, Instant.now());
            kpiGateway.save(currentWorkShift);
        } else {
            kpiGateway.sendKpi(currentWorkShift);

    }

    // ...

}
----

Отлично, теперь нам не хватает только лишь Порта, для того чтобы получить канонический эргономичный юз кейс, давайте добавим его:

.KpiTracker.java
[source,java]
----
@RestController
public class KpiPort {

    private final AuthService authService;

    private final UserService userService;

    private final KpiGateway kpiGateway;

    public KpiPort(AuthService authService, UserService userService, KpiGateway kpiGateway) {
        this.authService = authService;
        this.userService = userService;
        this.kpiGateway = kpiGateway;
    }

    @EventListener
    public void onLogin(UserLoginEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogin();
    }

    @PutMapping(value = "/kpi")
    public void sendKpi() {
        final KpiTracker kpiTracker = new KpiTracker(authService.getCurrentUser(), kpiGateway, new KpiRules());
        kpiTracker.sendKpi();
    }

    @EventListener
    public void onDisconnect(UserDisconnectEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }

    @EventListener
    public void onLogout(UserLogoutEvent e) {
        final KpiTracker kpiTracker = new KpiTracker(userService.getUser(e.userId), kpiGateway, new KpiRules());
        kpiTracker.onLogout();
    }


}
----

Порт вышел тривиальным - таким каким и должен быть.

(#todo: диаграмма#)

Вот чего мы добились применив эргономичный подход:

. Обнаружили и сделали Очевидной ранее скрытую сущность предметной области - рабочая смена сотрудника
. Замкнули на один класс все входы и выходы юз кейса - теперь очевидно куда добавлять новую функциональность (этого юз кейса конечно же, другие юз кейсы пойдут в другие классы), когда она появится, и при каких событиях она должна и будет вызываться и какие эффекты будет иметь
. Описали юз кейс в одном месте и сделали его Очевидным (в оригинальной версии, юз кейс раскидан по четырём разным классам в трёх разных модулях)
. Описали правило начала новой рабочей смены (в оригинальном коде, начало смены определялось по наличию записи в таблице таймаутов, которая записывалась в двух разных классах, а удалялась в третьем)

Оригинальная ошибка в эргономичной версии практически исключена - из-за того что языком реализации является Java, приходится рассчитывать на аннотации и подскзки Идеи, в Kotlin'е эта ошибка была бы исключена на уровне типов.

Единственное что меня не много смущает в итоговой версии - объединение отслеживания рабочих смен и отправку КПИ в одном классе.
Но пока что рабочая смена является нужна только в юз кейсе КПИ, поэтому я думаю эту связность пока можно оставить.
Когда рабочая смена потребуется в другом юз кейсе, её надо будет выделить в отдельный модуль.
Наконец, это объясняет все наши мучения с принципом трёх зависимостей - `KpiTracker` действительно делает слишком много.
И он и рабочие расписания отслеживает, и определяет правило продления смены (вообще надо было изначально длительность перерыва перенести в `KpiRules`, но оставим так) и КПИ отправляет.

==== Модель состояний сотрудника (#todo#)

==== Отчёты

=== Todos (#todo#)

[appendix]
= Дальнейшее чтение (#todo#)

=== Люди

[#apx_peop_uncle_bob]
==== Анкл Боб (#todo:#)

==== Эрик Майер (#todo#)

[#apx_peop_coplien]
==== Джеймс Коплейн (James Coplien)

=== Книги

[#apx_book_ddd]
==== DDD (#todo#)

[#apx_book_object_thinking]
==== Object Thinking (#todo#)

[#apx_book_lean_arch]
==== Lean Architecture for Agile Software Development

=== Научные статьи

=== Публицистические статьи

[#apx_artc_seg]
Segue

=== Доклады

[#apx_talks_dci]
==== DCI: Practical Tips and Lessons for Nerds

Ссылка: https://www.youtube.com/watch?v=SxHqhDT9WGI
