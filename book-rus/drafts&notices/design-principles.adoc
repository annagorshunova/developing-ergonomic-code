=== Принципы проектирования (рекурсивные)

==== Откуда я всё это взял
==== Личный опыт
==== Предъявить как гипотезу
==== Что нам это даст
Что я вижу по личному опыту работы с кодом серверов на яве в Новосибирске, Москве и Долине -
кругом код разбитый по техническим признакам (слои, исключения, ДТО и билдеры, енамы и т.п.).
В лучшем случае есть согласованный второй уровень разбиения, в котором интуитивно выделены "логические" части.

Такой подход к декомпозиции кода ведёт к тому, что в любом месте (пакете, модуле, компоненте) доступен код из любого места.
Это в свою очередь ведёт к big bull of mud (#todo: ссылка#).
Представителями которого и были буквально все коммерчески успешные продукты, с которыми мне довелось сталкиваться.

Я понимаю почему так происходит - никто и ни где не учит проектированию програм.
Самому научиться тоже сложно - есть огромное количество хороших книг, содержащих отдельные кусочки пазла.
Например, OOSE

(#todo: база данных - это глобальная переменная#)

Как нарисовать сову - прийти от требований к рабочей системе, да ещё и эргономичной.

Эргономичный подход базируется на двух базовых конструкциях проектирования:
1) Компонент из ООП, инкапсулирующий в себе состояние
2) Воркфлов из ФП, описывающий функцию сигнал -> изменения в окружении.

Эти две конструкции постоянно чередуются на разных уровнях абстракции, от системы в целом до данных и функций - компоненты состоят из воркфловов,
а воркфловы из компонент.



На самом абстрактном уровне вся система - это компонент-система инкапсулирующий в себе всё состояние системы и все её функции.
Далее этот компонент состоит из воркфловов-системы реализующих всё поведение системы.

Каждый воркфлов-системы состоит из компонент-приложений, инкапсулирующих какую-то часть системы - входы и выходы системы, базу данных.

Каждый компонент-приложения состоит из воркфловов-приложения реализующих поведение приложения.
Каждый воркфлов приложения состоит из компонент-пакетов, инкапслуирующих части приложения, задействованные в реализации воркфлова.

На этом уровне уже может появится разделение между компонентами-решателями и компонентами-делателями.
