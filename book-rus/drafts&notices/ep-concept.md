У меня кажись наконец оформилась концепция принципов проектирования информационных систем на платформе Java.
Её ещё нужно детализировать и опробовать на практике (этим я занимаюсь на другом проекте, как закончу - расскажу о результатах), но тем не менее предлагаю вам ознакомиться с первой версией по двум причинам:
1. Может возьмёте в тредс. Станет сильно лучше во всех смыслах - зуб даю
2. получить от вас обратную связь - в первую очередь вопросы, которые подсветят оставшиеся белые пятна и нестыковки.

**ТЛ, ДР
Я на самом деле нифига не открываю америку - я, кажись, начал догонять то о чём безуспешно с 90ых годов толдычат Фаулер, Мартин, Еванс, Вест, Якобснон, Коплейн, MVC-чувак-с-непроизносмимым-именем, Кэй и прочая ОО-компания. Кажись кроме прокляться монады (https://www.infoq.com/presentations/functional-pros-cons/, 26:21) есть ещё и проклятье ООП/ООД:)

Глобально система строится из компонентов-объектов (которые состоят из классов и их экземпляров) инкапсулирующих состояние (таблицы в БД, чаще всего) по принципам традиционного ООД.
Состояние нарезается на кусочки по принципам агрегатов из ДДД.
Локально каждый из компонент делится на две части - сложная логика (энтити, доменные сервисы) и общий пайплайн (юз кейс/аппсервис) в функциональном стиле и тупой ввод-вывод (репозы, гейтвеи, контроллеры) в процедурном (стандартном для явы) стиле.
Каждая из частей оформлется в отдельный грэдл/мавен-модуль с внешними зависимостями, а все классы одного компонента помещаются в один пакет этих модулей.

Ну и кажись это на самом деле функциональная архитектура:) Хаскель я так и не разботанил, и чего-то подобного в МЛях не помню, но вот экторная модель Эрланга и Кложуры - как раз про это - у них экторы выступают компонентами/объектами из этого лонг рида.
**

Я начну из далека:)

*Литература*
Patterns, principles and practises of DDD (PPP of DDD) (https://www.amazon.com/Patterns-Principles-Practices-Domain-Driven-Design/dp/1118714709)
Domain Modeling Made Functional (DMMF) (https://www.amazon.com/Domain-Modeling-Made-Functional-Domain-Driven/dp/1680502549)
Эргономичный подход (ЭП) (https://github.com/d-r-q/developing-ergonomic-code/blob/master/book-rus/developing-ergonomic-code.adoc)
Кричащая архитектура (https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html)

*Цели*
В этой концепции я буду использовать следующие определения:
1. архитектура - логическое устройство системы, оторванное от средства реализации.
2. дизайн - реализация архитектуры с использованием конкретных средств (котлин/ява, классы, грэдл/мавен)

Для любой проблемы (набора бизенс-требований) можно спроектировать множество архитектур, обладающих разными характеристиками.
И любую из этих архитектур можно также реализовать множеством дизайнов, также обладающих разными характеристиками.

Так вот, достижение следующих характеристик дизайна **не** является целью описываемых принципов:
1) Возможность 100% покрытия юнит тестами
2) Производительность. Но на практике (роутинг) следование описываемым принципам даёт на несколько порядков более быстрый дизайн, чем дизайн полученный по средствам безпринципного программирования, за счёт "делания явным" и последующей оптимизации ввода-вывода, который сжирает львиную долю времени обработки события/запроса.
3) Масштабируемость. Тут уже теоретически следование описываемым принципам (маленькие агрегаты и интерфейсы компонент, см. ниже) даёт существенно более масштабируемую систему, чем безпринципнре программирование за счёт минимизации конкурентных модификаций глобального состояния и возможности быстрого выпиливания и деплоя компонент в отдельные сервисы, при необходимости.
4) Привычность для глаза среднестатистического ява-разработчика - чтобы можно было выдернуть кого угодно с рынка, и он сразу бы начал пилить код, проходящий ревью с первой-второй попытки.
5) Максимальная скорость реализации одной отдельно взятой фичи.

А вот какие цели преследуются:
1) Минимизация зависимостей в коде
2) "Делание очевидным" контракта событие (рест-запрос) -> эффекты (запись в бд, отправка сообщений)
3) "Делание очевидным" связей через глобальное состояние между разными частями кода
4) Простота покрытия надёжными (без моков) юнит-тестами бизнес-логики

Благодаря этому минимизируется кол-во регрессий при рефакторинге и изменении фич. Благодаря чему исчезает блок перед рефакторингом из-за страха что-то сломать. Благодаря чему общий дизайн постоянно улучшается и адаптируется к изменениям в требованиях.

Так же благодаря п. 4 (+ фокус на интеграционных тестах -> тесты не приколачиваются моками к реализации) минимизируется кол-во изменений, требуемых при рефакторинге (в идеале они инкапсулируются в одном компоненте), что так же убирает блок перед рефакторингом из-за страха залипнуть на изменений всей системы. Благодаря чему, опять же, общий дизайн постоянно улучшается и адаптируется к изменениям в требованиях.

И благодаря качественному дизайну, в долгую, средняя скорость становится выше средний скорости беспринципной разработки.

Путь в этот чудесный мир, хорошего дизайна, надёжных тестов и быстрой и приятной разработки лежит через настощяие объекты/компоненты.

*ООП, ООД и компоненты*
Имхо, ООП - тотально облажавшаяся хрень повсеместно выродившаяся в процедурное программирование с элементами полиморфизма со всеми его проблемами (и я тут внезапно наткнулся на то, что Вест со мной согласен - https://www.youtube.com/watch?time_continue=4&v=RdE-d_EhzmA&feature=emb_logo, ну или я с ним:) ).
Сейчас 90% классов в индустрии это либо ваще тупые структуры данных (энтити, дто), либо синтаксический сахар над старыми добрыми структурами с функциональными указателями из С (контроллеры, сервисы).
И именно реализацию лучше писать в функциональном стиле, т.к. в результате получается код, по которому проще понять его контракт и который проще протестировать и, следовательно, проще поддерживать.

А вот объектно-ориентированные дизайн и анализ же - это совсем другая история.
Напомню, что изначально объект - это состояние, поведение и идентичность.
И если объектно-ориентированный подход применять к более крупным чем классы блокам - компонентам - то он внезапно из теоретических лозунгов превращается в практический инструмент.
В моей концепции компонент физически представлен набором классов, находящихся в одном пакете, но, при необходимости, разбитых на несколько грэдл/мавен-модулей (в зависимости от их зависимостей, прошу прощения за каламбур:))
А логически, компонент это объект, т.е. обладает состоянием и поведением.

**Чтобы не вносить путаницу, пусть объектом будет набор байт в памяти в рантайме, а компонентом - настоящий объект (с состоянием и поведением), являющийся единицей проектирования.
Плюс у слова "объект", у меня по крайней мере, есть нежелательные коннотации - антропоромфный взгляд на объекты Веста и Бугаенко и объекты как средство моделирования реального мира Буча.
Нахер вот это вот всё. Объект - средство инкапсуляции состояния. Инкапсуляция состояния - средство "очевидизации"/"делания явным" связей кода через глобальное состояние. Очевидность этих связей в конечном итоге упрощает понимание к каким изменениям в контракте приведут те или иные изменения в коде, что в свою очередь уменьшает количество регрессий.**

Но возникает вопрос - что такое состояние и поведение у компонента (пакета с пачкой классов в разных модулях)? Для ответа нам понадобятся агрегаты из ДДД и аппсервисы/workflows/pipelines/use cases из ДДД/DMMF/ЭП.

*Агрегаты*
Агрегат из ДДД - это граф объектов (JPA Entity) с корневым объектом (корень агрегата), который является единицей персистанса, т.е. этот граф загружается целиком (без лэзи лоада) и сохраняется целиком.
ДДД накладывает ряд ограничений на агрегаты:
1. Как я уже писал - агрегаты загружаются и сохраняются целиком
2. Это влечёт рекомендацию держать агрегаты маленькими
3. Репозитории пишутся только для агрегатов
4. На агрегат можно ссылаться только через корень
5. Ссылки между агрегатами делаются только через ИДы
6. В одной транзакции можно менять только один агрегат (создавать можно сколько угодно)
7. Отсюда рекомендация дизайнить агрегаты исходя из юз кейсов, а не модели данных

И уже моё ограничение - в БД изменения вносятся только через репозитории. Ток на JPA это ограничение технически обеспечить невозможно из-за чёртового персистанс контекста, который и иммутабельными энтити сделать не позволяет и сохранит всю ту хрень, которую кто угодно может туда записать через сеттеры. Возможно package private сеттеры помогут, но надо на практике проверять. Ну и на ебине точно можно сделать как надо - я проверил:)

*Другие виды состояний компонента*
Агрегат - это наиболее распространённый вид состояния в информационных системах, но вообще состояние - это любая внешняя система
1. все виды баз данных
2.   файловая система
3. ТГ
4. Джира
5. email

*Workflows/Use cases/Pipelines*
Это апп сервисы из ДДД.
Или worklow/pipeline из (DMMF).
Или юз кейсы из ЭП.
Реализуются они в функциональном стиле адаптированном к яве/котлину (ЭП) - в юз кейсе описывается сэндвич из тупого (без условной логики) ввода-вывода и сложной логики, но для пайплайна используется банальный ретарн вместо монад.
Правда всё-таки Котлин подходит лучше для такого стиля, т.к. этот стиль подразумевает активное создание типов при первой необходимости, а в яве на любой маломальский тип нужна горка бойлерплейта.

*И снова компоненты*
Так вот состоянием компонента является изолированный кусочек состояния внешней системы (таблиц на которые замаплены агрегаты, например), которое должно меняться атомарно и изменение которого компонент инкапсулирует за поведением - воркфловами.
В оригинале у объекта есть ещё идентичность, но она в этой концепции не особо нужна, т.к. большинство компонент в рантайме будет в единственном экземпляре. Но если надо много, то идентичность компонента привязывается к идентичности объекта фасада.
Публичным интерфейсом компонента выступает класс-фасад, который либо сразу содержит воркфловы, либо просто их делегирует выделенным для них классам. Аргументы и результат метода фасада должен быть ДТОшкой.
Энтити, агрегаты и репозы являются приватными членами - не уверен что это удастся реализовать на практике только средствами явы/грэдла/мавена. Но ArchUnit, надеюсь, сможет помочь.

Продолжая аналогию с классами/объектами:
1. Класс = пакет
2. Объект в ранатайме = граф объектов в рантайме с корнем в виде фасада
3. Конструктор объекта = специальный класс (спринг конфиг), который на вход получает конфиг и набор других компонент (в виде фасадов), строит граф объектов компонента и возвращает объект-фасад.
4. Метод = метод фасада
5. Поле = какое-то глобальное изменяемое состояние - просто изменяемое поле класса/объекта, таблица в БД, таблица в БД за РЕСТ АПИ внешней системы и т.д.

Тут ещё детально не продумывал, но такое ощущение, что все принципы ООД  - ацикличный граф зависимостей, high cohesion/low coupling, SOLID, CQS и контракты Мейера и т.д. - прекрасно и, главное понятно, работают на уровне компонент. Ну за исключением всего, что касается наследования, понятное дело. Но оно в любом случае должно уйти на покой:) (и тут Вест снова со мной согласен, см. тот же видос :)

Из системы компоненты выставляются по средствам адаптеров - рест контроллеры, либо какие-то другие штуки, которые знают как делать ввод-вывод пригодный для использования конечным пользователем или внешней системой.

Если интерфейс компонента сразу сделать асинхронным, то его можно тривиальной манипуляцией вынести в отдельный сервис при деплое. Это уже будет экторная модель дефакто:)

Надо подумать, но вроде вариант инкапсуляции нескольких агрегатов в одном компоненте допустим.

*Модули*
Вообще я сторонник кричащей архитектуры. Поэтому в идеале надо стремиться к тому, чтобы компоненты мапились на модули 1 в 1.
Но из-за особенностей систем сборки на яве (нельзя прописать грэдл/мавен-зависимость конкретному классу), компонент разбивается как минимум на два модуля - домен и инфраструктура.
В домене живут энтити, агрегаты, интерфейсы репоза и других гейтвеев, юз кейсы и всё что надо для их работы. Сюда же можно засунуть доменные сервисы, но они должны быть чистыми - без ввод-вывода. И эти модули не зависят ни от чего, кроме модулей других доменов и небольших, неинвазивных локальных либ.
В инфраструктуре живут реализации репозов и гейтвеев, контроллеры и конструктор компонента (спринговый конфиг, например). И они зависят от всех этих вездесущих спрингов, хиберов, томкэтов и прочих фреймворков.
Конфиг модуля публикует (в спринговый контекст, например) только контроллеры и юз кейсы, а репозы и прочие гейтвеи создаются и инжектятся в юз кейсы приватно и снаружи недоступны.
В принципе можно вообще обойтись двумя модулями - апп и домен, и их внутри уже на пакеты нарезать на компоненты. Но т.к. я сторонник кричащей архитектуры и модули это намного более прочные границы, чем пакеты, я всё-таки за то чтобы доменные части компонент выделять в отдельные модули.

*Подсистемы*
В целом систему можно бить на подсистемы, состоящие из логически и физически сильно связанных компонент.

*Как это реализовать в тредс*
Если често - хз:)
Поидеи надо брать ядерный компонент (тред) и оформлять его в таком стиле, брать следующий по важности, править его и так Н раз. Но править тред, скорее всего, будет бесконечно долго и в процессе не будет никаких промежуточных плюшек.
Можно попробовать зайти с другой стороны - выделять периферийные компоненты (какие-нить расписания работы, например) и оформлять в таком виде. Это кажись, можно делать шажками разумных размеров, и после каждого такого шага кол-во входящих зависимостей у более ядерных компонент будет уменьшаться, делая их более пригодными для приведения в порядок. До того же треда с таким подходом тоже придётся добираться бесконечно долго, но при этом после каждого маленького шажка, архитектура будет становиться чуть лучше.
