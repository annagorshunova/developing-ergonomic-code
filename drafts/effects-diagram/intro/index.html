<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Диаграмма Эффектов: Спецификация v0.0.2 - Алексей Жидков"><meta property="og:description" content="Душой информационной системы являются её эффекты. Именно на основании эффектов конечные пользователи выносят суждения о корректности работы системы. И при столь большой важности эффектов, в мире не существовало инструмента для визуализации и проектирования эффектов. Поэтому я придумал свой - диаграмму эффектов"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/effects-diagram/intro/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/effects-diagram/intro/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/effects-diagram/intro/><title>Диаграмма Эффектов: Спецификация v0.0.2 - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/effects-diagram/intro/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Диаграмма Эффектов: Спецификация v0.0.2</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Этот пост является первой попыткой описать диаграмму формально, поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.</p></aside><p>Это первый пост в серии, посвящённый диаграмме эффектов:</p><div class="olist arabic"><ol class=arabic><li>"Спецификация": назначение диаграммы, основные концептуальные элементы и их визуальное представление</li><li>"Пример построения диаграммы, проект True Story Project (TSP)" - процесс построения диаграммы эффектов реального проекта</li><li>"Методика объектно-ориентированной декомпозиции" - рациональный подход к разбиению системы на модули с помощью диаграммы эффектов и его применение для декомпозиции проекта TSP</li><li>"Методика перевода диаграммы в код" - процесс трансляции диаграммы в исходный код на примере проекта TSP</li></ol></div><section class="doc-section level-1"><h2 id=_введение><a class=link href=#_введение>Введение</a></h2><p>Идентичность информационной системы определяется тем, как она взаимодействует с внешним миром.
Что, где и когда она сохраняет; что, откуда и когда она запрашивает; что, куда и когда она отправляет.
Это я называю наблюдаемым поведением.</p><p>Можно переписать приложение с Java на Haskell, сменить слоёную архитектуру на шестиугольную, реляционную базу данных заменить документной, а пользовательский интерфейс перевести с серверной генерации HTML на React Native - если наблюдаемое поведение системы останется неизменным, то это будет просто очередная версия всё той же системы.
Если же кардинально изменить её взаимодействие с внешним миром, то это будет уже другая система.</p><p>Именно на основании наблюдаемого поведения конечные пользователи выносят суждения о корректности работы программы.
Даже для того чтобы оценить корректность результата сложного вычисления, пользователю в первую очередь надо чтобы правильно сработал механизм отображения этого результата.</p><p>При всей значимости наблюдаемого поведения, я не знаю ни одного общепринятого инструмента для его проектирования и визуализации.
Поэтому изобрёл свой - диаграмму эффектов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>При чём здесь эффекты?
При том, что наблюдаемое поведение состоит из эффектов.
И так короче.</p></aside></section><section class="doc-section level-1"><h2 id=_концептуальная_модель_триада_события_эффекты_ресурсы><a class=link href=#_концептуальная_модель_триада_события_эффекты_ресурсы>Концептуальная модель: триада События-Эффекты-Ресурсы</a></h2><p>Концептуальная модель диаграммы эффектов состоит из трёх ключевых типов элементов: событий - триггеров работы системы, эффектов - атомарных действий системы и ресурсов - объектов (в <a href=https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82>философском смысле</a> этого слова) действий системы.</p><section class="doc-section level-2"><h3 id=_эффект><a class=link href=#_эффект>Эффект</a></h3><p>Если не вдаваться в философию программирования, то <strong>эффект</strong> - это ввод-вывод.
Включая запись и чтение глобальных переменных (кучи).</p><p>Очевидно, глобально эффекты бывают двух видов - чтения и записи.
Первые изменяют состояние программы, вторые - состояние окружающего мира.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Впереди - часть моей личной и не до конца оформленной версии философии программирования - её можно смело пропустить, без ущерба для основной части поста.</p><p>Так вот если всё-таки немного вдаться в философию, то в программировании эффект - это всегда <strong>действие</strong> по изменению состояния какого-то транзистора.
В эффекте чтения состояние транзистора памяти внешнего устройства через несколько промежуточных этапов попадает в регистр процессора (который является группой транзисторов).</p><p>В эффекте записи наоборот состояние регистра процессора переносится в транзистор внешнего устройства.
На этом эффект может быть завершён, в случае жёсткого диска, либо это состояние может быть "аналогизировано" - превращено в физический процесс (например, световую волну или движение ноги робота).
Так эффект работы программы становится наблюдаемым поведением.</p><p>Вообще в максималистичном понимании "неэффектов" не существует - любое действие в программе выражается в изменении состояния транзисторов.
В <a href=https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0>фон Нейманавской архитекутре</a>, по крайней мере.</p><p>При этом существует функциональная парадигма программирования, которая характеризуется акцентом на функциях без эффектов.
Но даже идеально чистая вызывающая функция записывает данные в память, выделенную для стэка, и ожидает, что идеально чистая вызываемая функция их считает, а потом запишет свой результат.</p><p>Я ни разу не встречал формального определения того, что считается эффектом, а что "неэффектом".
Но, по-видимому, общепринятое мнение таково, что изменение регистра процессора и стэка программы эффектами не считается, а любые изменения начиная с кучи программы и далее - считаются.
То есть разница между эффектом и "неэффектом" в области видимости.
Или, другими словами, количеством наблюдателей поведения.</p><p>Высокоуровневый эффект может проходить через несколько этапов переноса, посредством чтения и записи.
Например, эффект "Отправить пуш уведомление" пройдёт такой путь: сначала информация переносится через кэши из процессора в память программы, потом в память ОС, потом в память сетевой карты, потом через память нескольких роутеров и серверов в память сетевой карты другого компьютера, там обратно в память программы, а оттуда, опять же через несколько слоёв, в память монитора, где состояние транзистора "аналогизиурется" в свечение пикселя.
И где-то попутно этот эффект заодно осядет на транзисторах диска БД пуш-сервиса.</p><p>Но возвращаемся на уровень абстракции разработчика информационных систем: эффект - это ввод-вывод плюс чтение-запись глобальных переменных.</p></aside></section><section class="doc-section level-2"><h3 id=_событие><a class=link href=#_событие>Событие</a></h3><p>Программы (особенно интерактивные) редко выполняют эффекты сплошным потоком - обычно программа выполняет набор эффектов в ответ на какое-то <strong>событие</strong> и засыпает до следующего события.
Таким событием может быть получение вызова удалённой процедуры в любом виде, появление нового сообщения в некоторой очереди, наступление определённого момента времени или истечение определённого периода времени.</p><p>По сути, события также являются эффектами (перенос Wi-Fi-сигнала, например, в память программы в виде DTO с данными пользователя), но эти эффекты обычно низкоуровневые и выполняются фреймворком или платформой.</p></section><section class="doc-section level-2"><h3 id=_операция><a class=link href=#_операция>Операция</a></h3><p>Как правило, для реализации функции системы требуется несколько эффектов.
Как минимум что-то считать и потом записать обратно.
Группы эффектов, реализующих одну функцию системы, образуют <strong>операции</strong> системы.
Система может реагировать как несколькими операциями, в ответ на одно событие, так и одной операцией в ответ на несколько событий разных типов.</p></section><section class="doc-section level-2"><h3 id=_ресурс><a class=link href=#_ресурс>Ресурс</a></h3><p>Наконец, у эффектов, которые являются действиями, есть объект - целевое состояние .
Это какая-то часть физического мира, с которой будет взаимодействовать устройство ввода-вывода в процессе реализации эффекта.
Чаще всего целевым состоянием выступают биты на носителях информации, но это могут быть и пиксели экрана, и динамик колонки и нога робота.
Эти кусочки физического мира представленны их абстракциями в системе - <strong>ресурсами</strong>.</p><p>Чёткое понимание триады События-Эффекты-Ресурсы - в ответ на какие события, какими эффектами на какие ресурсы система должна реагировать - крайне полезно на всех этапах жизненного цикла разработки системы.</p><p>На этапе оценки триада помогает осознать количество функций системы и примерную трудоёмкость реализации каждой из них.</p><p>На этапе проектирования операции и ресурсы становятся основными блоками, правильная декомпозиция которых создаст основу для системы с низкой сцепленностью.</p><p>На этапе реализации оценочная сложность операций (определяемая количеством и типом обеспечивающих её ресурсов) и их зависимости через ресурсы помогают определить порядок выполнения работ и те работы, которые могут быть выполнены параллельно.</p><p>Наконец, на этапе поддержки сцепленность операций через ресурсы помогает спрогнозировать последствия планируемого изменения и предотвратить внесение регрессий.</p><p>Изначально я осознал важность триады именно в контексте модификации сложных операций и представлял её в виде <a href=/book/ergo/#_таблица_эффектов>таблицы эффектов</a>.
Однако постепенно таблица трансформировалась в диаграмму, а я увидел её пользу для других этапов работы.
Это привело к тому, что триада стала моим способом размышлять о программах и легла в основу моей каждодневной работы.</p></section></section><section class="doc-section level-1"><h2 id=_реализация_триады_события_эффекты_ресурсы_в_коде><a class=link href=#_реализация_триады_события_эффекты_ресурсы_в_коде>Реализация триады События-Эффекты-Ресурсы в коде</a></h2><p>Все описанные выше элементы транслируются непосредственно в код: события и операции - в методы, ресурсы - в классы, эффекты - в вызовы методов.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Тут есть небольшая шероховатость.
События на самом деле транслируются в метод, передаваемый фреймворку (см. ниже) и вызов из него метода операции.
По крайней мере если следовать принципам единственности ответственности и/или разделения аспектов (separation of concerns).
Но пока что я не вижу ни потребности, ни возможности отразить это в концептуальной модели.
Возможно, позже, я найду какую-то другую абстракцию для события - в конце концов, технически ничего не мешает передать метод операции напрямую фреймворку.</p></aside><p>Операции всегда транслируются в методы классов слоя сервисов приложения - методы определяющие публичный интерфейс модуля.
При том при реализации желательно сохранить очевидность эффектов выполнения операции, присущую диаграмме.</p><p>События превращаются в методы, передаваемые фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера и т.д.
Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются:</p><div class="olist arabic"><ol class=arabic><li>Получение запроса по сети (@RestController + @*Mapping в случае разработки на Spring).
Сейчас популярностью пользуется протокол запросов в REST-стиле, но SOAP, gRPC, CORBA и т.п. так же попадают в эту категорию.</li><li>Появление сообщения в очереди (@EventListener, @JmsListener).
Это может быть как "вне-процессная" очередь, вроде ActiveMQ, так и "внутри-процессная" очередь вроде Spring ApplicationEventPublisher.</li><li>Наступление определённого момента времени (@Scheduled).
Два основных типа таких событий - наступление заранее известного момента времени (например, полуночи вторника) и истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).</li></ol></div><p>Ресурсы же превращаются в структуру данных и коллекцию методов работы с ней - классы Spring Data агрегата и репозитория, классы события и ApplicationEventPublisher-а (или обёртки вокруг него), классы REST API модели и клиента и т.п.
В контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются:</p><div class="olist arabic"><ol class=arabic><li>любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.</li><li>REST API внешних сервисов</li><li>любые очереди сообщений/шины данных</li><li>изменяемые структуры данных, доступные через глобальные переменные</li></ol></div></section><section class="doc-section level-1"><h2 id=_нотация><a class=link href=#_нотация>Нотация</a></h2><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Нотация с большой вероятностью претерпит косметические изменения в процессе бета-теста, а так же в связи с привлечением профессионального дизайнера к полировке визуального языка перед релизом 1.0.</p></aside><p>Основу визуального языка диаграммы эффектов я позаимствовал в <a href=https://c4model.com/>модели C4</a>.
Во-первых, мне нравится сам язык модели C4.
А во-вторых, диаграмму эффектов можно встроить в модель C4 на четвёртом уровне - вместо кода.
Кроме того, диаграмму третьего уровня (компонентов) я строю как раз на базе диаграммы эффектов.</p><p>Диаграмма эффектов бывает двух типов - краткая и полная.
Краткая содержит только обозначение эффектов и связанных ими операций и ресурсов.
Полная нотация дополнительно включает события и их источники, внешние системы, обеспечивающие реализацию ресурсов и более полное описание всех элементов.</p><p>Рассмотрим нотации с помощью минимального примера визуализации функциональности регистрации и аутентификации пользователей в произвольной системе.
После успешной регистрации пользователям необходимо отправлять приветственное письмо.
Начнём с краткой нотации.</p><section class="doc-section level-2"><h3 id=_краткая_нотация><a class=link href=#_краткая_нотация>Краткая нотация</a></h3><p>В краткой нотации диаграмма выглядит следующим образом (картинка кликабельна):</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/short-notation-example.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/short-notation-example.svg alt="short notation example"></a></div><p>Теперь рассмотрим отдельные элементы</p><section class="doc-section level-3"><h4 id=_операции><a class=link href=#_операции>Операции</a></h4><p>Операции обозначаются прямоугольником с именем операции:</p><div class=image-block><img src=/drafts/effects-diagram/images/operation.svg alt=operation></div></section><section class="doc-section level-3"><h4 id=_ресурсы><a class=link href=#_ресурсы>Ресурсы</a></h4><p>Ресурсы обозначаются прямоугольником с именем ресурса и цветом отличным от цвета операции:</p><div class=image-block><img src=/drafts/effects-diagram/images/resource.svg alt=resource></div></section><section class="doc-section level-3"><h4 id=_эффекты><a class=link href=#_эффекты>Эффекты</a></h4><p>Эффект модификации ресурса обозначается "сильной" (более заметной) стрелкой от операции к ресурсу, с кратким описанием эффекта:</p><div class=image-block><img src=/drafts/effects-diagram/images/operation-resource-rw.svg alt="operation resource rw"></div><p>Эффект чтения ресурса обозначается стрелкой от ресурса к операции, с кратким описанием считываемых данных:</p><div class=image-block><img src=/drafts/effects-diagram/images/operation-resource-ro.svg alt="operation resource ro"></div></section><section class="doc-section level-3"><h4 id=_эффекты_вызова_операций><a class=link href=#_эффекты_вызова_операций>Эффекты вызова операций</a></h4><p>Дополнительно есть особый вид стрелок для эффектов вызова операций в следствии взаимодействия с ресурсами.
Как правило, это ресурсы всевозможных шин событий и связанные с ними операции-обработчики.
Такие связи отображаются прерывистой стрелкой того же стиля, что и стрелка эффекта записи с кратким описанием связи:</p><div class=image-block><img src=/drafts/effects-diagram/images/resource-operation-rw.svg alt="resource operation rw"></div></section><section class="doc-section level-3"><h4 id=_примечания><a class=link href=#_примечания>Примечания</a></h4><p>Дополнительно на диаграмму можно помещать заметки и примечания, используя любую удобную нотацию.
Я предпочитаю нотацию UML - "лист" с загнутым углом, связанный прерывистой линией с комментируемым элементом.</p><div class=image-block><img src=/drafts/effects-diagram/images/note.svg alt=note></div><p>Это все элементы, составляющие ядро диаграммы эффектов.</p></section></section><section class="doc-section level-2"><h3 id=_полная_нотация><a class=link href=#_полная_нотация>Полная нотация</a></h3><p>Теперь рассмотрим ту же функциональность, описанную в полной нотации:</p><div class=image-block><a class="image bare" href=/drafts/effects-diagram/images/full-notation-example.svg title="Open the image in full size" aria-label="Open the image in full size"><img src=/drafts/effects-diagram/images/full-notation-example.svg alt="full notation example"></a></div><p>В полной нотации появляются:</p><div class="olist arabic"><ol class=arabic><li>события</li><li>описание операций и ресурсов в формате модели C4</li><li>границы контейнера из C4.
Обозначает границы процесса - всё что находится внутри этих границ выполняется в памяти визуализируемого приложения.</li><li>внешние системы, базы данных и компоненты из C4.
Внешние системы могут быть как источником события, так и средством реализации ресурса.</li></ol></div><p>Расширять состав диаграммы можно постепенно, добавляя только те элементы, которые помогают в решении текущей задачи.</p><section class="doc-section level-3"><h4 id=_события><a class=link href=#_события>События</a></h4><p>На мой взгляд, из дополнительных элементов наибольшую ценность имеют события.
В полной нотации они обозначаются стрелкой от внешней системы к операции с кругом на стартовом конце и описанием в формате C4.
Но в промежуточной версии, внешнюю систему можно опустить и "подвесить" стрелку:</p><div class=image-block><img src=/drafts/effects-diagram/images/event-operation.svg alt="event operation"></div></section><section class="doc-section level-3"><h4 id=_описания><a class=link href=#_описания>Описания</a></h4><p>Затем можно дополнить типом, способом реализации и описанием блоки операций и ресурсов:</p><div class=image-block><img src=/drafts/effects-diagram/images/descriptions.svg alt=descriptions></div></section><section class="doc-section level-3"><h4 id=_внешние_системы><a class=link href=#_внешние_системы>Внешние системы</a></h4><p>Границы системы и внешние системы полностью соответствуют нотации C4:</p><div class="olist arabic"><ol class=arabic><li>Границы отображаются "приглушённым" прямоугольником с прерывистой границей и подписью с именем контейнера</li><li>Неуправляемые внешние системы и компоненты и базы данных обозначаются "приглушёнными" прямоугольниками и символом "База Данных" соответственно</li><li>Управляемые внешние системы и базы данных обозначаются прямоугольником и символом "База Данных"</li></ol></div><p>Внешние системы связываются с операциями посредством событий:</p><div class=image-block><img src=/drafts/effects-diagram/images/event-sources.svg alt="event sources"></div><p>А ресурсы связываются со внешними системам по средствам стрелок с описанием:</p><div class=image-block><img src=/drafts/effects-diagram/images/resource-impls.svg alt="resource impls"></div><p>Ресурс может быть связан со сторонним компонентом, работающем в том же процессе:</p><div class=image-block><img src=/drafts/effects-diagram/images/resource-component.svg alt="resource component"></div><p>Здесь приведена, связь ресурса с эффектом вызова операции системы, в случае же если ресурс не обладает таким эффектом, то он соединяется со сторонним компонентом обычной стрелкой.</p><p>Выбор нотации зависит от решаемой задачи.
Если надо быстро разбить систему на модули, или спланировать модификацию сложной или незнакомой операции - можно обойтись краткой нотацией.
Если надо оценить проект для работы за фиксированную цену - лучше взять полную нотацию, чтобы минимизировать вероятность "потери" существенных деталей.</p><p>Ещё два критерия выбора нотации - срок жизни диаграммы и размер целевой аудитории диаграммы.
Если планируете выкинуть диаграмму после анализа и никому не будете её показывать - можно обойтись краткой нотацией.
Если же вы планируете возвращаться сами к диаграмме через длительный срок или публиковать её для ознакомлении без вашего руководства - стоит как минимум добавить события и описания ресурсов и операций.</p><p>Я сам обычно начинаю с промежуточной нотации - краткой с событиями, и дополняю её по мере необходимости.</p></section></section></section><section class="doc-section level-1"><h2 id=_инструментарий><a class=link href=#_инструментарий>Инструментарий</a></h2><p>Одним из плюсов базирования на визуальном языке модели C4 является то, что для диаграммы эффектов можно использовать <a href=https://c4model.com/#Tooling>любой инструмент с поддержкой C4</a>.
А в силу простоты C4 таким инструментом может быть хоть графический редактор.
Тем не менее, поддержка привязки элементов сильно помогает, поэтому я сам сейчас использую <a href=https://www.diagrams.net/>десктопную версию draw.io</a>.</p></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Сущность информационной системы заключена в её поведении - эффектах на окружающий мир.</p><p>Самым эффективным способом отразить суть поведения системы является триада События-Эффекты-Ресурсы - какими эффектами на какие ресурсы в ответ на какие события система реагирует.</p><p>Для визуализации, анализа и проектирования этой триады я разработал диагрмму эффектов и с радостью делюсь с вами этим инструментом.
Надеюсь он поможет вам лучше понять душу ваших программ и точнее отразить её в более <a href=https://azhidkov.pro/posts/22/04/220409-ergo-approach-v10m1/>эргономичном коде</a>.</p><p>Но прежде чем приступить к визуализации триады, её надо понять.
В следующем посте я опишу процесс построения диаграммы эффектов (читай - понимания сути задачи) реального проекта.</p></section></article></section></div></main><script src=/js/app.js></script></body></html>