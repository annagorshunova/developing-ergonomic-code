<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="Подходы к декомпозиции бэкендов информационных систем (Черновик) - Алексей Жидков"><meta property="og:description" content="(#todo: коммент#)"><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/ergonomic-decomposition/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/ergonomic-decomposition/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/ergonomic-decomposition/><title>Подходы к декомпозиции бэкендов информационных систем (Черновик) - Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/ergonomic-decomposition/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1>Подходы к декомпозиции бэкендов информационных систем (Черновик)</h1></header><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Следить за обновлениями блога можно в моём канале: <a href=https://t.me/ergonomic_code>Эргономичный код</a></p></aside><div class="quote-block epigraph"><blockquote><p>a class is a necessary but insufficient vehicle for decomposition</p><p>Класс - это необходимое, но недостаточное средство декомпозиции</p><footer>— <cite>Grady Booch, Object-Oriented Analysis and Design with Applications</cite></footer></blockquote></div><p>Количество классов в реализации даже небольшой программы на один человеко-месяц исчисляется десятками.
В средних программах на несколько человеко-лет счёт идёт уже на тысячи.
А человек может одновременно оперировать 7-ю +/- 2 объектами.
Поэтому все нетривиальные программы требуют декомпозиции своей реализации на более крупные блоки чем классы - я буду называть такие блоки пакетами.</p><p>Сейчас чаще всего можно встретить два основных подхода к декомпозиции систем:</p><div class="olist arabic"><ol class=arabic><li>Пакетирование по слоям и техническим аспектам (далее просто "по слоям" для краткости)</li><li>Пакетирование на основе предметной области, представленное группой вариантов:<ol class=loweralpha type=a><li>Пакетирование по фичам</li><li>Пакетирование по компонентам</li><li>Ограниченные контексты и пакетирование по агрегатам из предметно-ориентированного дизайна (DDD)</li></ol></li></ol></div><p>Однако мне в полной мере не подошёл ни один из этих подходов и я разработал ещё один подход к декомпозиции системы на пакеты, основывающийся на предметной области.
Его текущее рабочее название - объектно-ориентированный.</p><p>Естественным образом, все варианты подходов на базе предметной области дают схожую декомпозицию.
Но в отличие от остальных подходов, для объектно-ориентированного существует простая и понятная методика, которая позволяет быстро получить хороший результат.
Сам факт существования и суть методики делает подход более инженерным, чем остальные подходы в группе, которые больше напоминают исскуство или ремесло.</p><p>В этом посте я определю критерии сравнения подходов, оценю по ним распространённые подходы и кратко представлю используемый мной подход.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>В области группировки кода вообще и классов в частности есть ещё много разных идей и подходов - <a href=http://jodypaul.com/SWE/HAL/hal.html>разделение Парнаса</a>, <a href=https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719>структурный дизайн Константина</a>, <a href="https://www.youtube.com/watch?v=N7agCpAYp1Q">принципы дизайна пакетов Мартина</a>, <a href=https://ieeexplore.ieee.org/document/914968>подходы на основе кластерного анализа</a>, многие книги (<a href=https://www.amazon.com/Designing-Object-Oriented-Software-Rebecca-Wirfs-Brock/dp/0136298257>Designing object-oriented software</a>, <a href=https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062>Applying UML and Patterns</a>, <a href=https://www.amazon.com/Designing-Object-Oriented-Applications-Method/dp/0132038374>Designing Object Oriented C++ Applications Using The Booch Method</a>) по ООП/Д затрагивают этот вопрос.</p><p>Однако по моей оценке на основе того что я вижу в интернете и на конференциях - все они не получили распространения на практике и чтобы сократить и без того огромный пост, я не буду их рассматривать.</p><p>Отмечу лишь, что две из них (разделение Парнаса и структурный дизайн) - дали нам универсальные критерии оценки дизайна программ - сокрытие информации и сцепленность/связанность соотвественно.
И я их возьму за основу для критериев оценки подходов.</p></aside><section class="doc-section level-1"><h2 id=_критерии><a class=link href=#_критерии>Критерии</a></h2><p>Подходы я буду сравнивать по двум аспектам - насколько хорошие декомпозиции они дают и насколько легко их применять.</p><p>Качество декомпозиции я буду оценивать по следующим критериям:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации.
Какую информацию подход скрывает</li><li>Сцепленность.
Какое количество связей между пакетами порождает подход.</li><li>Связанность.
Какое количество связей внутри пакета порождает подход.</li><li>Масштабируемость.
Насколько большие системы могут быть эффективно декомпозированы с помощью подхода</li></ol></div><p>Оценка сцепленности только по количеству связей внутри пакета, может быть легко "хакнута" - например, если в слоёной декомпозиции слой сервисов сделать высоко сцепленным.
В этом случае формально слой сервисов будет обладать высокой связанностью, но фактически он будет обладать высокой сцепленностью внутренних элементов.</p><p>Для того чтобы это обойти, для оценки сцепленности я дополнительно буду оценивать локальность изменений.
Локальность изменений, в свою очередь, я буду оценивать по двум критериям:</p><div class="olist arabic"><ol class=arabic><li>Сколько в среднем пакетов затрагивает одно изменение.
В идеальной декомпозиции это число должно быть равно 1.</li><li>Можно ли найти <a href=https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0>топологическую сортировку</a>, определяющую такой порядок, что при удалении пакетов в соответствии с ним, система продолжает на каждом шаге:<ol class=loweralpha type=a><li>Собираться</li><li>Быть полезной для конечного пользователя</li></ol></li></ol></div><p>Что касается лёгкости применения, то её я буду оценивать по таким критериям:</p><div class="olist arabic"><ol class=arabic><li>Простота обучения.
Насколько просто обучить человека подходу.</li><li>Простота исполнения.
Есть ли у подхода методика выполнения и насколько она проста</li></ol></div></section><section class="doc-section level-1"><h2 id=_пакетирование_по_слоям_и_техническим_аспектам><a class=link href=#_пакетирование_по_слоям_и_техническим_аспектам>Пакетирование по слоям и техническим аспектам</a></h2><div class=image-block><img src=/drafts/images/ergonomic-decomposition-Layers.drawio.svg alt="ergonomic decomposition Layers.drawio"></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>В этом посте я буду рассматривать только декомпозицию выделенных бэкендов, которые предоставляют API для фронтэнда.
В этом случае контроллеры выступают в роли тонких адаптеров обращений по протоколу сетевого взаимодействия (REST, SOAP, всевозможные протоколы RPC и т.д.) в вызовы методов сервисов.</p><p>Иллюстрировать декомпозиции я буду на примере вымышленной системы управления задачами.</p></aside><p><a href=https://github.com/ardalis/CleanArchitecture/tree/main/src/Clean.Architecture.Core>Пример</a></p><p>Этот подход настолько прост и существует настолько давно, что кажется это уже коллективное бессознательное нашей индустрии.
Я пытался найти авторитетный источник, в котором бы вводилась эта концепция, но потерпел крах.</p><p>Тем не менее, в моей практике этот подход является самым распространённым и, думаю, он знаком всем разработчикам, имеющим хотя бы полгода коммерческого опыта за плечами.
Способ группировки заключается в том, что команда выбирает несколько аспектов реализации (самые частые примеры - контроллеры, сервисы, репозитории/дао, сущности, дто, фабрики, исключения, перечисления) и группирует классы по ним.
Классы, которые не удаётся однозначно отнести к одному из этих аспектов, сваливают в специальную группу, которую обычно называют utils или common.</p><p>В слоёной архитектуре существует только одно ограничение - более "низкие" слои не могут зависеть от более "высоких".
Это ограничение становится сложнее соблюдать, когда на одном уровне смешивают и архитектурную декомпозицию (контроллеры, сервисы, репозитории, сущности) и техническую (исключения, перечисления, фабрики).
В этом случае для технических "слоёв" становится невозможно определить их порядок.
Например, что является более "высоким" слоем/уровнем - исключения или перечисления?</p><p>Такая декомпозиция теоретически должна скрывать способ реализации технических аспектов, например, способ работы с БД.
Однако на практике, детали реализации слоёв "<a href=https://azhidkov.pro/posts/22/07/abstraction-wars/>протекают</a>" через границы, результатом чего становится отсутствие какого-бы то ни было сокрытия информации вообще.</p><p>Для слоёной декомпозиции естественной является высокая сцепленность системы.
Самый "толстый" слой сервисов содержит в себе только код, а все структуры данных (сущности, дто, исключения, перечисления) и код работы с ними (репозитории, фабрики, билдеры) находятся в других пакетах.
В итоге каждый класс в пакете сервисов начинает зависеть от множества классов в соседних пакетах, тем самым, по определению, повышая сцепленность.</p><p>Кроме того, даже единственное ограничение на зависимости между слоями чаще нарушают, чем соблюдают, ещё больше повышая сцепленность системы за счёт внесения циклов в зависимости.</p><p>В итоге декомпозиция по слоям представляет собой сочетание врождённой высокой сцепленности между пакетами и белого пятна в проектировании внутри пакетов.
Эта гремучая смесь приводит к превращению системы в печально известный Big Ball of Mud (большой ком грязи) уже к концу первого года своей жизни.</p><p>Если связанность оценивать только по количеству связей внутри пакета, то откровенно плохо реализованная система с десятками зависимостей в каждом сервисе и связным графом сущностей может показаться высоко связанной.
Однако истинная связанность таких систем легко демонстрируется с помощью <a href=#_критерии>дополнительных критериев</a>, введённых специально для этого случая.</p><p>Большинство нетривиальных изменений таких систем будет затрагивать множество пакетов.
А единственный пакет, который может быть удалён первым без поломки сборки проекта - пакет контроллеров - сразу же сделает всю систему бесполезной для пользователя.
Если рассмотреть слоёную декомпозицию с этих точек зрения, то становится очевидно, что она обладает логической связанностью - чуть лучшей связанностью, чем случайная.</p><p>С точки зрения масштабируемости слоёная декомпозиция так же даёт плохие результаты.
Постоянно развиваемая система довольно быстро доходит до 20-30 классов одного типа (то есть в одном пакете) и снова возникает проблема их группировки.</p><p>Хорошо, если команда осознано выбрала слоёную декомпозицию, для сокращения времени разработки первой версии.
В этом случае, достигнув пределов масштабирования слоёной архитектуры, команда может провести качественную декомпозицию.</p><p>Однако на практике слоёную декомпозицию не выбирают.
Чаще всего это единственный известный и понятный разработчикам способ декомпозиции.
И разработчиков сложно в этом винить, декомпозиции систем действительно нигде не учат - меня самого не учили в университете, и соответствующих курсов я ни разу не видел.
И это не только моё мнение, с ним согласен например и <a href=https://ru.wikipedia.org/wiki/%D0%9E%D1%83%D1%81%D1%82%D0%B5%D1%80%D1%85%D0%B0%D1%83%D1%82,_%D0%94%D0%B6%D0%BE%D0%BD>Джон Оустерхаут</a>, автор <a href=https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201>A Philosophy of Software Design</a>:</p><div class=quote-block><blockquote><p>I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.</p><p>У меня до сих пор не получилось найти хотя бы один курс в каком-либо университете, где бы декомпозиция задач была основной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.</p><footer>— <cite>John Ousterhout, A Philosophy of Software Design, с. 9</cite></footer></blockquote></div><p>Поэтому, как правило, дальнейшая декомпозиция внутри пакетов-слоёв выполняется методом "как бог на душу положит" первым разработчиком, который решил, что "пакет слишком разросся".</p><p>Если слоёная декомпозиция даёт столь плохие результаты, как она стала самой распространённой?
Секрет кроется во второй группе критериев оценки методики - простоте обучения и исполнения.</p><p>Слоёная декомпозиция не требует практически никакой квалификации и мышления и может быть автоматизирована даже без применения нейронных сетей - просто путём поиска нескольких ключевых подстрок в строке определения класса.</p><p>Этим же определяется и простота исполнения - опытный разработчик выполняет слоёную декомпозицию буквально спинным мозгом не затрачивая ни секунды на проектирование.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Хочу отметить, что я не являюсь противником разделения кода на слои как такового - в моих проектах есть и контроллеры, и сервисы, и репозитории.
Более того, во всех моих системах последних семи лет за пользовательский интерфейс, бизнес-логику и хранение данных отвечают разные программы - веб- или мобильное приложение, бэкенд сервер и СУБД соотвественно.
А если бы я делал программу, реализующую все три аспекта, то я бы её в первую очередь разбил по слоям.
Однако для программ, сфокусированных только на одном из этих аспектов, слои работают откровенно плохо.</p></aside><p>Итоговая оценка пакетирования по слоям:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации - плохо</li><li>Сцепленность - плохо</li><li>Связанность - плохо</li><li>Масштабируемость - плохо</li><li>Простота объяснения - очень хорошо</li><li>Простота применения - очень хорошо</li></ol></div></section><section class="doc-section level-1"><h2 id=_пакетирование_по_фичам><a class=link href=#_пакетирование_по_фичам>Пакетирование по фичам</a></h2><div class=image-block><img src=/drafts/images/ergonomic-decomposition-Features.drawio.svg alt="ergonomic decomposition Features.drawio"></div><p><a href=https://github.com/mmpodkanski/computer-shop-back/tree/main/src/main/java/io/github/mmpodkanski/computershop>Пример</a>.</p><p>Найти источник идеи пакетирования по слоям у меня тоже не получилось, но этой теме посвящено множество постов:</p><div class="olist arabic"><ol class=arabic><li><a href="http://www.javapractices.com/topic/TopicAction.do?Id=205">Package by feature, not layer</a></li><li><a href=https://medium.com/sahibinden-technology/package-by-layer-vs-package-by-feature-7e89cde2ae3a>Package by Layer vs Package by Feature</a></li><li><a href=https://dzone.com/articles/how-changing-java-package>How Changing Java Package Names Transformed my System Architecture</a></li><li><a href=https://medium.com/expedia-group-tech/package-by-feature-not-by-layer-5ba04a070003>Package by Feature, Not by Layer</a></li><li><a href=https://dzone.com/articles/package-by-feature-is-demanded>Package by Feature Is Demanded</a></li><li>Продолжать можно очень долго</li></ol></div><p>Хотя ни один из них я не могу назвать ни авторитетным, ни исчерпывающим.</p><p>В этом подходе, приложение декомпозируют на пакеты по фичам - для каждой фичи создаётся пакет, и весь код реализующий фичу попадает в этот пакет.
При том каждый пакет имеет явно выделенный публичный интерфейс, а всё остальное скрывается.</p><p>Но тут мы сразу упираемся в главный недостаток этого подхода - его сложно объяснить, а исполнить ещё сложнее.</p><p>Декомпозиция по фичам только звучит просто (и то не для всех).
Когда же вы сядете и попытаетесь декомпозировать по фичам, у вас тут же возникнет множество вопросов: "А фича это вообще что такое?", "Как мне из требований получить набор фич?", "Судя по примерам, фича - это таблица. Мне что, заводить по пакету на каждую таблицу?", "А что делать с таблицами связками?", "Что делать с функциями, которые затрагивают две и более таблицы - в какой пакет их помещать?", "А что делать с функциями, которые работают не с таблицами, а с REST API?", "А с S3?", "А куда мне положить DSL создания Excel файлов для нескольких фич? В utils?".
Ответы на все эти вопросы придётся искать самостоятельно, потому как все посты ограничиваются поверхностным описанием идеи.</p><p>Найти ответы, конечно же, можно - я нашёл и у меня получился объектно-ориентированный подход к пакетированию.
Но мне для этого потребовалось пять лет вялотекущих размышлений, два года активной работы в этом направлении и эксперименты в пяти коммерческих проектах.
Не у всех есть желание и возможность этим заниматься - когда давят сроки, лучше декомпозировать на въевшиеся в подкорку слои.</p><p>Но если преодолеть все сложности и не остановиться на полпути, то наградой будет декомпозиция высокого качества по нашим критериям - принципы низкой сцепленности/высокой связанности и сокрытия информации практически во всех постах предлагаются как главенствующие.</p><p>С масштабируемостью дела обстоят хуже.
При декомпозиции по фичам, быстро рости будет не количество классов в пакетах, а количество самих пакетов
И если ничего не предпринять, то уже количество пакетов быстро дорастёт до 20-30 штук и проблема декомпозиции системы снова встанет в полный рост.
В постах же эта проблема либо не упоминается вовсе, либо упоминается лишь вскользь
В результате разработчик снова остаётся с ней один на один.
Но благодаря поискам ответов на изначальные вопросы, разработчик хорошо прокачает свой скилл проектирования и в этом случае будет высокий шанс того, что получившаяся декомпозиция окажется высокого качества.</p><p>Итоговая оценка пакетирования фичам:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации - хорошо</li><li>Сцепленность - хорошо</li><li>Связанность - хорошо</li><li>Масштабируемость - средняя</li><li>Простота объяснения - плохо</li><li>Простота применения - плохо</li></ol></div></section><section class="doc-section level-1"><h2 id=_пакетирование_по_компонентам><a class=link href=#_пакетирование_по_компонентам>Пакетирование по компонентам</a></h2><div class=image-block><img src=/drafts/images/ergonomic-decomposition-Components.drawio.svg alt="ergonomic decomposition Components.drawio"></div><p>Примеры: <a href=https://github.com/techtribesje/techtribesje>[1</a>], <a href=https://github.com/ttulka/blog-code-samples/tree/master/myshop>[2</a>].</p><p>Пакетирование по компонентам - первый подход в нашем списке, для которого есть конкретный <a href=http://www.codingthearchitecture.com/2013/04/08/mapping_software_architecture_to_code.html>источник</a> (так же см. <a href=http://www.codingthearchitecture.com/2014/05/29/software_architecture_vs_code.html>1</a>, <a href=http://www.codingthearchitecture.com/2014/06/01/an_architecturally_evident_coding_style.html>2</a>, <a href=http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html>3</a>, <a href=https://github.com/techtribesje/techtribesje>4</a>, а так же главу 34 "Missing Chapter" из <a href=https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164>Clean Architecture</a>).</p><p>Пакетирование по компонентам очень похоже на пакетирование по фичам, поэтому я не буду на нём подробно останавливаться и лишь обозначу отличия.</p><p>Браун дистанцируется от пакетирования по фичам в первую очередь тем, что у него контроллеры вынесены в отдельный пакет.
По его задумке это должно повысить сокрытие информации о реализации сервисов
Однако он это делал для классических контроллеров из MVC, которые собирают модель для представления из нескольких сервисов и для нашего примера с контроллерами API в этом смысла нет.</p><p>Зато есть другое отличие - модель данных выделена в собственный пакет.
В тексте это явно не проговорено, но видно из <a href=/drafts/images/package-by-component.png>иллюстрации</a> и <a href=https://github.com/techtribesje/techtribesje/tree/master/techtribes-core/src/je/techtribes/domain>кода примера</a>.
И вот это уже, на мой взгляд, проблема, так как из-за этого за границы компонента начинает утекать структура его данных и это создаёт предпосылки для сцепленности через общее окружение.</p><p>Уже в процессе редактуры этого поста я наткнулся на твит Брауна:</p><div class=quote-block><blockquote><p>Each non-UI component isn’t a “feature”, it’s something else…​
like a domain concept or aggregate root (including DB access), integration point to the outside world, technical service, etc.</p><p>Каждый "non-UI" компонент не является "фичей", это что-то другое…​
как концепт предметной области или корень агрегата (включая доступ к БД), точка интеграции с внешним миром, технический сервис и т.д.</p><footer>— <cite>Simon Brown, https://twitter.com/simonbrown/status/969112668132073473?s=20&t=w8c5RikLz3zFdS7X4APvNw</cite></footer></blockquote></div><p>Основываясь на этом твите, можно предположить, что понимание Брауна подхода к декомпозиции эволюционировало и теперь пакетирование по компонентам по сути совпадает с пакетированием по объктам.
Но это не точно.</p><p>И хотя с описанием пакетирования по компонентам дела обстоят лучше, чем с описанием пакетирования по фичам, чёткой методики выявления компонентов Браун так же не предлагает.
Поэтому итоговая оценка примерно такая же.</p><p>Итоговая оценка пакетирования компонентам:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации - средне</li><li>Сцепленность - средне</li><li>Связанность - хорошо</li><li>Масштабируемость - средняя</li><li>Простота объяснения - плохо</li><li>Простота применения - плохо</li></ol></div></section><section class="doc-section level-1"><h2 id=_ограниченные_контексты_и_пакетирование_по_агрегатам_из_предметно_ориентированного_дизайна_ddd><a class=link href=#_ограниченные_контексты_и_пакетирование_по_агрегатам_из_предметно_ориентированного_дизайна_ddd>Ограниченные контексты и пакетирование по агрегатам из предметно-ориентированного дизайна (DDD)</a></h2><div class=image-block><img src=/drafts/images/ergonomic-decomposition-DDD.drawio.svg alt="ergonomic decomposition DDD.drawio"></div><p>Примеры: <a href=https://github.com/citerus/dddsample-core>[1</a>], <a href=https://github.com/VaughnVernon/IDDD_Samples>[2</a>], <a href=https://github.com/ddd-by-examples/library>[3</a>].</p><p>DDD - это полноценный подход к проектированию, описанный в одноимённой <a href=https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215>книге</a> Эрика Эванса.
Помимо этой книги есть ещё ряд очень хороших книг - <a href=https://pragprog.com/titles/swdddf/domain-modeling-made-functional/>Domain Modeling Made Functional</a>, <a href=https://www.oreilly.com/library/view/patterns-principles-and/9781118714706/>PPP of DDD</a>, <a href=https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577>Implementing Domain-Driven Design</a> суммарно на 2200 страниц, множество менее качественных книг и бессчётное количество постов в интернете.</p><p>Суть подхода можно охарактеризовать как то, что исходный код программы должен быть написан на языке предметной области</p><p>Мне самому DDD импонирует и в Эргономичном подходе я многое позаимствовал из DDD, в первую очередь - концепцию агрегатов.
Однако, вместо того, чтобы работать по DDD я начал делать Эргономичный подход.
Этому есть две основные причины - тяжеловесность и расплывчатость DDD.</p><p>Тяжеловесность DDD проявляется как в обучении, так и в применении.</p><p>DDD - это очень большая штука, на изучение которой требуется очень много времени.
Как минимум надо будет прочитать 1000 страниц оригинальной книги и PPP of DDD или Implementing DDD.
И лично мне этого не хватило - я прочитал все 4 книги по два раза (по разу от корки до корки, и ещё по разу разбираясь с отдельными концепциями) - и всё равно оцениваю своё понимание тактических шаблонов как "умеренное", а стратегических как "слабое".</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Тут строгий читатель может спросить "Какого фига ты тогда пишешь о том, чего не знаешь?".
Отвечаю.</p><p>Во-первых, DDD это такой слон в области проектирования, опусти я которого - другой (а возможно и тот же) строгий читатель спросит, почему я ничего не написал про DDD.</p><p>Во-вторых, я критикую DDD за сложность изучения и применения - а в этом, благодаря собственному опыту, я разбираюсь как раз очень хорошо.</p></aside><p>Тяжеловесность изучения так же усложняет и исполнение - DDD требует включенности (а соотвественно изучения) всей команды и экспертов предметной области.
Опять же мне в своей практике ни разу не удалось продать DDD даже команде, не говоря уж об экспертах предметной области.</p><p>Касательно декомпозиции, DDD предусматривает два уровня - ограниченные контексты и агрегаты.
Что это такое?
А вот поди разбери.</p><div class=quote-block><blockquote><p>A Bounded Context is an explicit boundary within which a domain model exists.
Inside the boundary all terms and phrases of the Ubiquitous Language have specific meaning, and the model reflects the Language with exactness.</p><p>Ограниченный контекст - это явная граница, внутри которой существует модель предметной области.
Внутри этой границы все термины и фразы Вездесущего языка имеют определённое значение и модель точно отражает Язык.</p><footer>— <cite>Vaughn Vernon, Implementing DDD</cite></footer></blockquote></div><p>Само определение ограниченного контекста является наглядной демонстрацией сложности и расплывчатости подхода.</p><p>Как декомпозировать задачу на ограниченные контексты тоже в двух словах не объяснить (мне по крайней мере).</p><p>Как вариант - границы контекста определяются языковыми границами.
Осталось выяснить самую малость - где проходят языковые границы.</p><p>Ещё вариант - выравнять контексты по организационной структуре компании.
Но что делать, если я занимаюсь продуктовой разработкой или автоматизирую работу одного отдела?</p><p>Руководства по декомпозиции ограниченных контекстов на модули DDD так же не предлагает.
В оригинальной книге этому посвящён целый раздел, но я бы описал его как "вода-вода, не используйте слои, вода-вода".
Если не слои, то что?
Ответа нет.
В первой книге.</p><p>Зато есть в Implementing DDD.</p><div class=quote-block><blockquote><p>Typically you’ll have one Module for one or a few Aggregates (10) that are cohesive, if only by reference.</p><p>Обычно у вас будет по модулю для одного или нескольких агрегатов, которые связаны хотя бы по ссылке.</p><footer>— <cite>Implementing DDD</cite></footer></blockquote></div><p>В целом ответ хорош и в объектно-ориентированной декомпозиции, агрегаты действительно будут играть одну из ключевых ролей.
Но он порождает три новых вопроса - что такое агрегат, как декомпозировать модель на агрегаты и как декомпозировать систему в которой больше интеграций, чем собственного состояния?
Мне чтобы найти и уложить в голове ответы на первые два вопроса пришлось проштудировать на несколько раз все книжки по DDD и потом написать <a href=https://azhidkov.pro/posts/22/04/220401-aggregates/>пост</a> об этом.
А ответа на третий вопрос просто нет.</p><p>Тем не менее, я пологаю, если преодолеть все сложности - "продать" подход команде и экспертам, обучить всех, изучить язык экспертов и найти в нём границы - то результирующая декомпозиция на ограниченные контексты и пакеты будет обладать высоким качеством.
В частности, я считаю что в силу своего фокуса на предметной области и экспертах, DDD может дать декомпозицию с наибольшей связанностью среди всех подходов.
А агрегаты и полнокровные сущности помогут существенно снизить сцепленность системы и повысить степень сокрытия информации.</p><p>Наконец, ограниченные контексты и возможность помещения нескольких агрегатов в один пакет дают хорошую масштабируемость декомпозиции "из коробки".</p><p>Итоговая оценка пакетирования по ограниченным контекстам и агрегатам:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации - хорошо</li><li>Сцепленность - хорошо</li><li>Связанность - очень хорошо</li><li>Масштабируемость - хорошо</li><li>Простота объяснения - плохо</li><li>Простота применения - очень плохо</li></ol></div><hr><p>Итак, мы пришли к выводу, что все распространённые подходы обладают существенными недостатками.
Пакетирование по слоям даёт откровенно низкокачественную декомпозицию.
Пакетирование по фичам и компонентам является скорее абстрактной идеей, которая требует значительных усилий по доработке для возможности эффективного применения на практике.
DDD очень тяжеловесен и сложен в изучении и применении.</p><p>Существует ли серебрянная пуля, которая позволит нам быстро и без больших усилий выполнять качественную декомпозицию систем?
Я утверждаю, что да и что она всегда была у нас под носом.
И имя ей - объектно-ориентированная декомпозиция</p></section><section class="doc-section level-1"><h2 id=_пакетирование_по_объектам_ака_объектно_ориентированная_декомпозиция><a class=link href=#_пакетирование_по_объектам_ака_объектно_ориентированная_декомпозиция>Пакетирование по объектам ака объектно-ориентированная декомпозиция</a></h2><div class=image-block><img src=/drafts/images/ergonomic-decomposition-OO.drawio.svg alt="ergonomic decomposition OO.drawio"></div><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>"Объектно-ориентированная декомпозиция" - это рабочее название, и я не уверен, что сохраню его.
Проблема этого названия в том, что сейчас термин "объектно-ориентированный" дефакто стал обозначать "использующий классы" (хотя <a href=http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html>это совсем не то, что имел ввиду Кей</a> вводя его), а у меня речь идёт про более крупные структуры, которые в коде можно с тем же успехом и на чисто функциональном языке реализовать.</p></aside><p>Как очевидно из названия, этот подход предполагает раскладку по пакетам разных объектов.
Тут может возникнуть вопрос - "Мне что, заводить по пакету на класс?".</p><p>Ответ - конечно же нет.
В данном контексте под объектом я понимаю не экземпляр класса, а более крупную структуру, которая может быть реализованна группой классов (группой экземпляров классов, если быть точнее).
Эту структуру я называю объектом, потому что она обладает всеми присущими ему характеристиками - состоянием, которое она абстрагирует и инкапсулирует за высокоуровневым поведением.
Идентичность тоже можно перенести на уровень пакетов, но на практике это требуется редко, поэтому я не стану на ней останавливаться.</p><p>Идея объектов-пакетов принадлежит не мне - я её подглядел в <a href=https://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350>Object-Oriented Software Engineering</a> Ивара Якобсона (одного из авторов UML).
В этой книге Якобсон оперирует тремя видами объектов - объекты анализа, объекты дизайна и объекты (модули) языка программирования.</p><p>И здесь я говорю об объектах дизайна, которые Якобсон описывает следующим образом:</p><div class=quote-block><blockquote><p>The design model will be composed of blocks which are the design objects.
These will make up the actual structure of the design model and show how the system is designed.
These blocks will later be implemented in the source code.</p><p>The blocks will abstract the actual implementation.
The implementation of the blocks may be one specific class in code, that is, one block is implemented by one class.
However, often, a block is implemented by several different classes.
The blocks are therefore a way of abstracting the source code.</p><p>Проектная модель будет состоять из блоков, которые являются объектами дизайна.
Они будут составлять фактическую структуру проектной модели и покажут как спроектирована система.
Позже эти блоки будут реализованы в исходном коде.</p><p>Эти блоки абстрагируют фактическую реализацию.
Реализацией блоков может быть один определённый класс в коде, то есть один блок реализуется одним классом.
Однако зачастую блоки реализуются несколькими разными классами.
Таким образом блоки являются способом абстракции исходного кода.</p><footer>— <cite>Ivar Jacobson, Object-Oriented Software Engineering</cite></footer></blockquote></div><p>Общая концепция ОО-подхода очень проста.
Есть операции - атомарные единицы поведения, которые могут быть вызванны извне (пользователем через UI или внешней системой через [REST] API).
Есть ресурсы, которые обеспечивают операции (в первую очередь коллекции в хранилищах данных, но это могут быть и файлы, и внешние системы, и внешние устройства).
Операции и обеспечивающие их ресурсы надо так поделить на объекты дизайна, чтобы каждый ресурс обеспечивал операции только одного объекта.
Наконец, ресурсы надо инкапсулировать в объектах дизайна - исключить возможность обращения к ресурсу напрямую снаружи объекта.</p><p>Интерфейс объекта дизайна может быть дополнен операциями, необходимым другим объектам.
Но в общем случае для взаимодействия объектов лучше использовать асинхронный обмен сообщениями и событиями через посредника (очередь).</p><p>Кратко методика проектирования объектов дизайна (ака декомпозиции на пакеты) состоит из трёх основных шагов:</p><div class="olist arabic"><ol class=arabic><li>Определить операции системы и ресурсы необходимые для их выполнения</li><li>Сгруппировать их таким образом, чтобы с ресурсами каждой группы взаимодействовали только операции этой группы.
Эти группы фактически определяют интерфейс и состояние объектов дизайна.<ol class=loweralpha type=a><li>Для защиты ресурсов, у каждого объекта дизайна выделяется набор классов, определяющих его интерфейс (обычно это класс сервиса и DTO), а всё остальное (сущности, репозитории, клиенты внешних систем, другие вспомогательные классы) делаются закрытыми (package private в Java, <a href=https://dev.to/0xkkocel/improving-kotlin-s-internal-with-archunit-4b3g>internal + ArchUnit правило</a> в Kotlin).</li><li>Часто оказывается так, что не получается однозначно отнести ресурс к одной группе.
В этом случае надо отнести ресурс к той группе (А), с операциями которой он более сцеплен.
А операциям из других групп предоставить доступ к ресурсу посредством дополнительной операции в группе А.</li></ol></li><li>Нормализовать количество и размер объектов:<ol class=loweralpha type=a><li>Если количество объектов получилось "слишком большим" (~10 и более) - сгруппировать связанные между собой объекты (объекты, которые используют операции друг друга).
Если таких нет, то стоит рассмотреть декомпозицию уже самой системы на несколько независимых на основании "здравого смысла" или более технических аспектов (по разработчикам, эксплуатационным требованиям, частоте релизов и т.п.).</li><li>Если в одном объекте количество операций или ресурсов получилось слишком большим (~10 и ~3 и более соответственно), то надо рассмотреть возможность разбить этот объект на несколько взаимодействующих через обмен сообщениями.
Если такой возможности нет, то стоит хотя бы ресурсы выделить во внутренние объекты (подпакеты)</li></ol></li></ol></div><p>Первый шаг я описал в <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>"посте с описанием построения диаграммы проекта True Story Project"</a>.</p><aside class="admonition-block note" role=note><h6 class="block-title label-only"><span class=title-label>Note:</span></h6><p>Пример, рассмотренный в этом посте, хорошо демонстрирует работу с внешними системами, но в силу специфики примера обходит стороной вопрос декомпозиции на ресурсы собственного состояния системы.
Общая идея работы с внутренним состоянием заключается в том, чтобы декомпозировать его на агрегаты DDD.
Сейчас у меня есть только <a href=https://azhidkov.pro/posts/22/04/220401-aggregates/#_методика_декомпозиции_модели_информации_на_агрегаты>общее описание</a> методики декомпозиции на агрегаты, но пост с примером проектирования системы с развесистым собственным состоянием есть у меня в планах.</p></aside><p>Второй и третий же шаги я опишу в следующем посте, для которого данный является прелюдией с обоснованием необходимости создания объектно-ориентированного подхода.</p><p>Эта методика относительно простая и механистическая, но даёт на удивление хорошие результаты.</p><p>Очевидно, что полученная декомпозиция обладает высокой степенью сокрытия информации - детали реализации (ресурсы) операций системы скрываются внутри объектов дизайна.
Так же это, совместно с рекомендацией по организации взаимодействия между объектами посредством обмена сообщениями, помогает и сцепленность свести к минимуму.</p><p>Вместе с низкой сцепленностью рука об руку идёт и высокая связанность (количество зависимостей внутри пакета), которая подтверждается локальностью изменений в проектах декомпозированных таким образом.</p><p>Наконец, масштабирование так же учтено и встроено в саму методики.</p><p>С критериями оценки самой методики тоже всё хорошо.
Объяснить её, конечно, сложнее, чем слоёную декомпозицию, но намного проще чем остальные методики из группы декомпозиций на основе предметной области.
То же касается и применения - проектирование объектов требует больше усилий, чем полное отсутствие усилий в случае слоёв, но эти усилия пренебрежимо малы на фоне остальных методик, оперирующих расплывчатыми понятиями фичи, компонента и языка предметной области.</p><p>Итоговая оценка пакетирования по объектам:</p><div class="olist arabic"><ol class=arabic><li>Сокрытие информации - очень хорошо</li><li>Сцепленность - хорошо</li><li>Связанность - хорошо</li><li>Масштабируемость - хорошо</li><li>Простота объяснения - средне</li><li>Простота применения - средне</li></ol></div></section><section class="doc-section level-1"><h2 id=_заключение><a class=link href=#_заключение>Заключение</a></h2><p>Все распространённые методики группировки классов по пакетам обладают существенными недостатками.
Группировка по слоям даёт откровенно плохие результаты.
Группировку по фичам и компонентам не понятно как выполнять и непонятно где этому научиться.
Группировку по ограниченным контекстам и агрегатам сложно изучить, а потом выполнить.</p><p>Для того чтобы решить эти проблемы я разработал методику объектно-ориентированной декомпозиции системы на пакеты.
Она проще в изучении и применении группировок по фичам, компонентам и ограниченным контекстам/агрегатам, но даёт результаты такого же качества.</p><p>В следующем посте я вернусь к <a href=https://azhidkov.pro/posts/22/06/220611-true-story-project/>серии постов</a> о диаграмме эффектов и подробно рассмотрю процесс выполнения объектно-ориентированной декомпозиции на конкретном примере.</p></section></article></section></div></main><script src=/js/app.js></script></body></html>