<!doctype html><html lang=ru-ru><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Алексей Жидков"><meta name=description content="https://azhidkov.pro/"><meta property="og:site_name" content="Алексей Жидков"><meta property="og:title" content="- Алексей Жидков"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://azhidkov.pro/drafts/ergo-approach/ergo-approach-v3/"><meta property="og:image" content="https://azhidkov.pro/"><meta name=twitter:card content="summary"><meta name=twitter:site content="https://azhidkov.pro/drafts/ergo-approach/ergo-approach-v3/"><meta name=twitter:image content="https://azhidkov.pro/"><base href=https://azhidkov.pro/drafts/ergo-approach/ergo-approach-v3/><title>- Алексей Жидков</title><link rel=canonical href=https://azhidkov.pro/drafts/ergo-approach/ergo-approach-v3/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700"><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css><link rel=stylesheet href=https://azhidkov.pro/css/custom.css><link rel=stylesheet href=https://azhidkov.pro/css/github.css><link rel=stylesheet href=https://azhidkov.pro/css/JetBrains-Mono.css><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=alternate href=https://azhidkov.pro/index.xml type=application/rss+xml title="Алексей Жидков"><link href=https://azhidkov.pro/index.xml rel=feed type=application/rss+xml title="Алексей Жидков"><meta name=generator content="Hugo 0.80.0"></head><body><main class=wrapper><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://azhidkov.pro/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://azhidkov.pro/favicon-16x16.png><link rel=manifest href=site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet type=text/css><nav class=navigation><section class=container style=height:100%><img src=https://azhidkov.pro/images/logo.svg class=logo>
<a class=navigation-title href=/>Алексей Жидков</a>
<input type=checkbox id=menu-control>
<label class="menu-mobile float-right" for=menu-control><span class="btn-mobile float-right">&#9776;</span><ul class=navigation-list><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/book/ergo>Книга</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/posts>Блог</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/portfolio>Портфолио</a></li><li class="navigation-item align-left"><a class=navigation-link href=https://azhidkov.pro/>Контакты</a></li><li class=mobile-menu-lang-separator-full><hr></li><li class=multilingual-separator><p>|</p></li><li class="navigation-item align-left"><a href=https://azhidkov.pro/en/>En</a></li></ul></label></section></nav><div class=content><section class="container page"><article><header><h1></h1></header><p>Я люблю писать программы и хочу, чтобы этот процесс приносил мне больше положительных эмоций, чем отрицательных.
На удивление, человеку, который платит за мою работу так же выгодно, чтобы разработка приносила мне больше положительных эмоций.</p><p>Отрицательные эмоции при разработке как правило возникают либо от того, что внесение изменений в программу требует неадекватно больших усилий, либо от того, что последствия изменений невозможно предсказать.
Первое влечёт раздражение и злость из-за необходимости делать выполнять много работы, для достижения небольшого результата.
Второе влечёт страх внесения регрессий.</p><p>И то и другое влечёт увеличение стоимости разработки само по себе.
Плюсом туда идёт время на прокрастинацию работы программистом из-за страха или раздражения.</p><p>Между тем, люди ещё в 70ых годах выяснили, что основным источником проблем (и как следствие увеличения стоимости) в развитии програм является сцепленность (coupling).
Очевидно, сцепленность является причиной как чрезмерно трудоёмких изменений, так и регрессий.</p><p>(<mark>todo: нужен переход от эмоций к сцепленности</mark>)</p><p>И не смотря на это, 50 лет спустя работа в большинстве чужих проектов сопровождалась для меня злостью и страхом.
Так получается, потому что в сейчас в мейнстримном подходе к разработке существует огромне количество практик, которые упрощают решение задачи в момент за счёт увеличения сцепленности системы.
Следствием этого являются описанные выше проблемы, которые приводят к увеличению итоговой стоимости разработки.</p><p>Для того чтобы минимизировать количество отрицательных эмоций при работе со своими проектами (а за одно и их стоимость для заказчиков), я нашёл альтернативные практики, которые минимизируют сцепленность системы
За это зачастую приходится платить усложнением задачи в моменте.
Но следствием этого является решение описанных выше проблем и минимизация итоговой стоимости разработки.</p><p>Объединив и подогнав друг к другу эти практики я получил "стратегическую" методику разработки програм - Эргономичный Подход.</p><p>У меня (и не только) есть эмпирическое ощущение, что инвестиции в дизайн начинают окупаться уже через 2-3 месяца от старта проекта, а в районе 6 месяцев "стратегические" проекты обгоняют в сроке релиза аналогичные по функциональности "тактические" проекты.</p><p>Большая часть этих практик давно известна и пропагандируется много известными инженерами и учёными:</p><div class="olist arabic"><ol class=arabic><li>Агрегаты из ДДД, вместо связного графа объектов</li><li>Неизменяемая модель данных и эпохальная модель времени из ФП, вместо императивной изменяемой модели</li><li>Фокус на чистых функциях из ФП, вместо повсеместного императивного программирования</li><li>Как следствие первых трёх пунктов - Spring Data JDBC, вместо Spring Data JPA</li><li>Функциональная декомпозиция из чистой архитектуры и ДДД, вместо механической декомпозиции по техническим аспектам кода</li><li>Тестирование бизнес сценариев из классического подхода Бека, вместо тестирования отдельных классов и методов</li><li>Тестирование модулей в конфигурации приближенной к боевой из классического подхода, вместо мокирования всех зависимостей</li><li>Разделение кода на чистое ядро и императивную оболочку из ФП (и ДДД и Чистой архитектуры), вместо разделения кода на слои представления, бизнес-логики и данных</li><li>Крафтовое управление зависимостями, вместо неуправляемого глобального Spring Component Scan</li><li>Крафтовая настройка инфраструктуры, вместо неуправляемых глобальных Spring Auto Configuraions</li></ol></div><p>Теперь давайте рассмотрим методику подробнее.
Глобально разработка по Эргономичному Подходу состоит из привычных этапов - системная аналитика, проектирование и реализация.</p><p>На этапе системной аналитики строятся ER-диаграмма модели информации, определяется список необходимых интеграций и АПИ системы.
Все три этих артефакта сильно связанны между собой и строятся они параллельно в процессе разбора и проработки требований.</p><p>После этого применяется моё ноухау - диаграмма эффектов.
Диаграмма эффектов объединяет в себе предыдущие три артефакта и является входом для этапа проектирования.
Изначально в диаграмму эффектов каждая сущность входит как отдельный ресурс, поэтому после построения диаграммы эффектов я приступаю к проектированию агрегатов и по мере обнаружения агрегатов, я заменяю ресурсы соответствующих сущностей на ресурс агрегата.
Спроектировав агрегаты я перехожу к этапу проектирования.</p><p>Этап проектирования я начинаю с того, чтобы декомпозировать диаграмму эффектов на модули таким образом чтобы:</p><div class="olist arabic"><ol class=arabic><li>инкапсулировать модификации ресурсов в одном модуле</li><li>инкапсулировать переиспользуемые ресурсы в одном модуле</li><li>минимизировать сцепленность модулей</li></ol></div><p>Затем я без фанатизма пытаюсь построить список сокрытия информации из декомпозиции по Парнасу.
Если в результате нахожу что-то существенное - отражаю это на диаграмме модулей.</p><p>После этого я проверяю получившуюся декомпозицию на предмет соответствия принципам:</p><div class="olist arabic"><ol class=arabic><li>Ацикличных зависимостей</li><li>Высокой функциональной связанности, низкой сцепленности</li><li>Стабильности зависимостей</li><li>Единства ответственности</li></ol></div><p>Если в процессе я вижу, что какие-то модули являются деталью реализации других модулей - я делаю их подмодулями.</p><p>Получив "достаточно хорошую" декомпозицию я перехожу к этапу реализации.</p><p>Который начинаю с того, что завожу по пакету для каждого модуля, а в пакете создаю как минимум Spring конфигурацию и сервис.</p><p>С тех пор, как я перешёл на тестирование сценариев использования, я стал сторонником ТДД, поэтому следующим шагом я пишу сценарный тест.
Который, естественно, падает.</p><p>Если я делаю первый юз кейс системы, то я создают точку входа.
При этом я не пользуюсь глобальными Spring Component Scan и AutoConfiguration - я в корневой конфигурации приложения импортирую конфигурации модулей этого приложения.
Если модулям нужна инфраструктура (например подключение к БД) - я для этого создаю отдельные конфигурации и импортирую их.
Компонент скан у меня вообще отключен.</p><p>После чего я перехожу к реализации операций системы, задействованных в падающем на данный момент тесте.
Для этого, как правило, надо реализовать два класса ресурса - отдельные элементы (сущности, ДТОшки, события и т.п.) и их коллекции (репозитории, REST-клиенты, топики в очередях событий).
Эти классы я стараюсь сделать package private, хотя если отдельные элементы надо выдавать наружу как есть, я не вижу ничего страшного в том, чтобы выставить их в публичный интерфейс модуля.</p><p>В реализации придерживаюсь структуры ориентированной на трансформации и функциональной архитектуры.
Их этого следует несколько вещей:</p><div class="olist arabic"><ol class=arabic><li>Отдельные элементы я делаю неизменяемыми</li><li>Коллекции я делаю максимально декларативными, идеал коллекции - интерфейс Spring Data репозитория.</li><li>в классе сервиса я оставляю только верхнеуровневое управление потоком данных</li><li>преобразования (если они есть) я уношу либо в классы отдельных элементов, либо в чистые функции.</li></ol></div><p>После того, как сценарный тест прошёл, я прислушиваюсь к себе достаточно ли мне этого для того чтобы спать спокойно.
Если недостаточно - я перехожу к модульным или юнит тестам.</p><p>Получив достаточную степень уверенности я отдаю код на ревью и, вмёржив его, перехожу к реализации следующего сценария.</p></article></section></div></main><script src=/js/app.js></script></body></html>