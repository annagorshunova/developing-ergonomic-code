<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Алексей Жидков</title><link>https://azhidkov.pro/posts/</link><description>Recent content in Posts on Алексей Жидков</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Mon, 21 Jun 2021 11:25:37 +0700</lastBuildDate><atom:link href="https://azhidkov.pro/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Многоликий принцип единственности ответственности</title><link>https://azhidkov.pro/posts/21/06/210626-srp-interpretations/</link><pubDate>Mon, 21 Jun 2021 11:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/06/210626-srp-interpretations/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Кажется, любой &amp;#34;солидный&amp;#34; программист знает что такое SOLID вообще и принцип единственности ответственности (SRP) в частности.
Спойлер, если вдруг не знаетеSOLID - это название принципов объектно-ориентированного дизайна, сформулированных Робертом Мартином, так же известным как анкл Боб. Принципы звучат следующим образом:
Single Responsibility Principle: A module should have one, and only one, reason to change.Open/Closed Principle:: A software artifact should be open for extension but closed for modification.</description></item><item><title>Анкл Боб не всегда прав</title><link>https://azhidkov.pro/posts/21/04/srp-ocp-conflict/</link><pubDate>Wed, 28 Apr 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/04/srp-ocp-conflict/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Свежий пост Анкл БобаПрочитал свежий пост Анкл Боба и я с ним категорически не согласен.
Краткое содержание поста:
Где-то в интернете спросили как зарефакторить код:
Анкл Боб сказал, что правильно инкапсулировать этот иф в фабрику:
И далее он пишет:
Every business rule that would once have depended on an if/else/switch statement now has its own particular method to call in the base class</description></item><item><title>Почему следует избегать использования JPA/Hibernate в продакшене</title><link>https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/</link><pubDate>Sat, 03 Apr 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/04/why-jpa-should-be-avoided/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Обновление от 22.08.21:
Раздел Плохой процедурный стиль программированияРаздел Что делать, если JPA невозможно избежатьРаздел Ссылки Дисклеймер - я люто ненавижу JPA/HibernateМои отношения с Hibernate (JPA тогда ещё не было) не сложились с самого начала - в далёком то ли 2005, то ли 2007, на собеседовании у меня спросили как замапить отношение 1-N в Hibernate. А я ответил &amp;#34;Я не знаю, что такое Hibernate&amp;#34;.</description></item><item><title>О декомпозиции систем</title><link>https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/</link><pubDate>Wed, 24 Mar 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/03/250326-project-decomposiotion/</guid><description>Дисклаймер: это небольшой линко-пост на тему, достойную главы книги
Наконец-то свершилась ваша мечта и вам досталось сделать проект с чистого листа. Наконец-то вы можете сделать всё правильно, а не воевать с легаси написанным сто лет назад людьми, которых вы никогда не видели.
Но как это сделать? Как сделать систему, за которую вас не будут проклинать ваши последователи?
Половину ответа я уже в каком-то виде описал в книге - это таблица эффектов приложения и компоненты.</description></item><item><title>Тесты, которым можно доверять</title><link>https://azhidkov.pro/posts/21/03/210321-project-l-testing/</link><pubDate>Sat, 13 Mar 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/03/210321-project-l-testing/</guid><description>Я сейчас делаю проект с чистого листа, в котором я основой и ведущий бакэндер. И, естественно, я его делаю в соответствии с Эргономичным Подходом.
Главным условием для того, чтобы кодовая база была эргономичной является набор тестов, которым можно доверять. Если тесты прошли - можно релизать. И никак иначе.
В этом посте я расскажу, как я организовал тестирование &amp;#34;Проекта Л&amp;#34;.
Проект ЛПроект под NDA, поэтому в подробностях я его описать не могу, но могу привести ряд ключевых характеристик:</description></item><item><title>Неэргономичный Jackson</title><link>https://azhidkov.pro/posts/21/02/210212-jackson-write-object-as-string/</link><pubDate>Tue, 23 Feb 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/02/210212-jackson-write-object-as-string/</guid><description>В последнее вермя несколько раз писал примерно такой код для сериализации объекта в json Jackson-ом:
public String renderToJson(Object dto) { try { return objectMapper.writeValueAsString(dto); } catch (IOException e) { throw new AssertionError(&amp;#34;Unexpected IOException converting object to json&amp;#34;); } } И мне это глаз резало - я генерирую строку в памяти, какой нафик IO??? Но задуматься времени не было.
А тут за чтением The modern way to perform error handling из глубин подсознания внезапно всплыл ответ:) И знаете что я вам скажу?</description></item><item><title>Типы функций: функции-мошенники</title><link>https://azhidkov.pro/posts/21/01/210126-fraud-functions/</link><pubDate>Tue, 26 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210126-fraud-functions/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь, здесь и здесь.
С второго взгляда терминология оказалась не такой уж чудесной, как показалась на первый взгляд, но я на этом посте засиделся, так что публикую как есть. В посте с итогами ещё раз попробую составить приличную терминологию.
Как я уже писал в прошлой статье, эффекты - это то ради чего пишутся программы, и тот критерий, по которому программы оцениваются.</description></item><item><title>Красная или синяя?</title><link>https://azhidkov.pro/posts/21/01/210122-pp-vs-fp/</link><pubDate>Fri, 22 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210122-pp-vs-fp/</guid><description>Статья не отредактирована после переезда с телеграфа. Оригинал
Привет! Чёт ~эта неделька опять выдалась сложная~ я прокрастинирую пост о грязных функциях и сайд эффектах, потому что там кой-чего не схоидтся. Поэтому сёня пост в бок с хейтом мейнстримного ``ООП&amp;#39;&amp;#39; - почитывал на досуге код на кложуре, и меня опять малёха бомбануло.
Меня тут осенило. Возьмём вот такой кусочек кода на кложуре (чисто функциональном языке): (my-app.users/reset-passworduser) Здесь вызываюется функция reset-password из неймспейса my-app.</description></item><item><title>Чистые и эффективные функции: Эффекты</title><link>https://azhidkov.pro/posts/21/01/210119-effects/</link><pubDate>Tue, 19 Jan 2021 09:19:22 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210119-effects/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь и здесь.
Сегодня расскажу о том, что я понимаю под эффектами и обработкой сигналов.
Что я понимаю под эффектами и сигналамиОбработка сигнала - акт чтения глобальной изменяемой памяти.
Отправка сигнала - акт записи глобальной изменяемой памяти.
Глобальная изменяемая память - область памяти, на которую в момент чтения/записи замаплено изменяемое поле объекта или структуры, достижимого из GC root.</description></item><item><title>Чистые и грязные функции, эффекты и обработка сигналов, сайдэффекты: чистые функции</title><link>https://azhidkov.pro/posts/21/01/210112-pure-functions/</link><pubDate>Tue, 12 Jan 2021 13:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210112-pure-functions/</guid><description>Note: Следить за обновлениями блога можно в моём канале: Эргономичный код
Начало темы здесь
Обращаю ваше внимание, что топик расширился - помимо анонсированных вчера грязных функций, вчера же я ещё &amp;#34;открыл&amp;#34; сигналы. Заголовок конечно длинноват, но пока так:) Но обо всём по порядку и сегодня у нас чистые функции.
Чистая функция - это функция без эффектов и сайдэффектов:) Или функция в математическом смысле - её результат определяется исключительно параметрами и у неё только один результат - возвращаемое значение.</description></item><item><title>Single Responsibility Principle considered harmful</title><link>https://azhidkov.pro/posts/21/01/210107-srp/</link><pubDate>Thu, 07 Jan 2021 07:25:37 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210107-srp/</guid><description>Наткнулся тут на эту статью и чёт меня малёха бомбануло.
Теоретически, принцип (Single Responsibility Principle ) возможно хороший и правильный, ток с ним есть одна проблема - анкл Боб 20 (двадцать) лет его объясняет и ни как объяснить не может.
Мне удалось отследить следующую историю формулировок этого принципа самим Мартином:
2003: &amp;#34;A class should have only one reason to change&amp;#34; - Agile Software Development, Principles, Patterns, and Practices2008: &amp;#34;The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change&amp;#34; - Clean Code2014: &amp;#34;Gather together the things that change for the same reasons.</description></item><item><title>Чистые и эффективные функции: Введение</title><link>https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/</link><pubDate>Tue, 05 Jan 2021 09:19:22 +0700</pubDate><guid>https://azhidkov.pro/posts/21/01/210105-pure-functions-and-effects-intro/</guid><description>В этом блоге и своей книге я постоянно повторяю мантру о &amp;#34;разделении эффектов и логики&amp;#34; и поэтому мне необходимо, чтобы читатели однозначно меня понимали. Однако когда я начал разбирать существующую терминологию, с удивлением обнаружил, что общепринятой вообще нет, а те варианты что есть не отражают важных мне нюансов. Поэтому я решил написать цикл статей об используемой мной терминологии.
С чистыми функциями всё более-менее просто, у них на вики есть внятное определение:</description></item></channel></rss>