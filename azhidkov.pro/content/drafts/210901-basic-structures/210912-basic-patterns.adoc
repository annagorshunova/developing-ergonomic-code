---
title: "Основные структуры дизайна програм"
description: "К каким структурам дизайна програм следует стремится, для того чтобы программа была поддерживаемой"
date: 2021-09-01T11:25:37+07:00
draft: false
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:table-caption!:

:fn-structured-design: footnote:[https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719[Структурный дизайн, Константин, Йордон]]

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--
== Введение

(#todo: слишком много хорошо - плохо:)#)
(#todo: как мне в ситуации, когда надо и научить и сделать хороший проект силами интернов#)

Я сейчас среди прочего отвечаю за интернатуру по Java в Сиберина.Про.
Интернатура устроена таким образом, что интерны, при первой возможности, подключаются к разработке проектов, предназначенных для проверки бизнес гипотез компании.
И так вышло, что сейчас мне надо разработать такой проект силами интернов.
Но если проект выстрелит, то он пойдёт в бой, поэтому его надо написать хорошо.
Поэтому мне надо научить интернов как писать хорошо.

Это я и делаю в этом посте.
Так как же сделать хорошо?

Сделать это просто - надо спроектировать программу так, чтобы он хорошо выглядела со всех ракурсов.
Сейчас же я наблюдаю существенный перекос в сторону одного из ракурсов - статической структуры реализации программы.

На мой же взгляд большее значение для хорошей программы имеет структура предметной области.

Кроме того, программисты сейчас забыли об одной из жемчужин 70ых годов - структурном дизайне.
С точки зрения статической структуры он потерял актуальность и уступил место чистой архитектуре.
Но когда дело доходит до динамической структуры во время выполнения программы, он всё ещё актуален.

Наконец, даже хорошая архитектура, будучи "скрытой за деревьями", быстро протухнет, т.к. бумажная документация моментально устареет, и новые члены команды не смогут восстановить архитектуру программы, скрытую за деталями реализации.

В этом посте, я кратко напомню существующие подходы к проектированию реализации программы и расскажу свои текущеие видения подхода к проектированию предметной области.
Наконец, изложу свои аргументы, почему программы следует разбивать на модули и пакеты исходя из структуры предметной области, а не реализации.

=== Структуры реализации

Под хорошими и я, и большинство других авторов, понимю программы, которые легко и безопасно модифицировать.
Как писать хорошие программы, проторазработчики стали задумываться как только размер программ вышел за пределы одного экрана.
Это случилось в 60-ые годы. (#todo: шуточка?#).

И к настоящему времени открыли целый ряд структур реализации, присущий хорошим программам:
. Структурный дизайн и (#todo: ориентация на трансформацию#)
. Слоёная архитектура
. Принцип инверсии зависимостей
. Чистая архитектура
. Концепция чистого ядра/императивной оболочки

(#todo: структурный дизай -> ДИП в статике, но в рантайме программы всё ещё имеют структрный дизайн#)


> Although I’m too young to have done any work in the early days of batch sys-
tems, I don’t sense that people thought much of layers in those days. You wrote
a program that manipulated some form of ﬁles (ISAM, VSAM, etc.), and that
was your application. No layers need apply.
The notion of layers became more apparent in the ’90s with the rise of client–
server systems
PoEAA

https://www.eecs.ucf.edu/~eurip/papers/dijkstra-the68.pdf

==== Структурный дизайн

Ещё в 70-ых годах Ларри Константин обнаружил{fn-structured-design} общую для дешёвых (#todo: красивый синоним#) програм структуру кода:

image::/posts/21/09/images/transform-oriented-structure-base-rus.svg[]

.. Слоёная архитектруа
.. Чистая архитектура
.. Функциональное ядро, императивная оболочка
.. Привязка ко спрингу
. Структура предметной области

=== Видите объект? А он есть
.. Данные
.. Поведение
... Простое
... Сложное
... Сложное с приватными данными
... Переиспользуемое
.. Основные связки
... Отсутствие циклов
... Связки данных
... Связка простого поведения с данными
... Связка сложного поведения с данными
... Связка сложного поведения с приватными данными и данными
... Связка переиспользуемого поведения
.. Домен как SDK предметной области
. Что вперёд - предметная область или реализация
.. Вперёд - предметная область, потому что за ней сложнее следить
.. Предыдущая работа
... Кричащая архитектура
... Архитектурно-очевидное кодирование (Risk Driven approach)
... Пакетирование по фичам
... Пакетирование по компонентам

=== Мой вариант

== Заключение

Итого, для того чтобы получить хорошую архитектуру необходимо:
. "Плясать от печки" - предметной области, в частности от ДДД-агрегатов;
. Делать архитектуру видимой с первого взгляда - отражать её в структуре пакетов;
. Не допускать циклов в зависимостях модулей
. Про каждую функцию и класс понимать куда они ложится в диаграмме структуры **чего?**, чистой архитектуры и арихтектуры предметной области.
. И убедиться, что они ложатся только на один элемент каждой из диаграм
. Рассматривать домен, как SDK предметной области
. Реализовывать домен в функциональном стиле (так чтобы его можно было покрыть юнит тестами без моков)
. Стараться уносить максимум бизнес правил в домен
. Следовать принципам чистой архитектуры при проектировании статической структуры программы
. Следовать принципам структурного дизайна при проектировании динамической структуры программы

== Ссылки
