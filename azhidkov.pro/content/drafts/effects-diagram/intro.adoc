---
title: "Диаграмма Эффектов: Спецификация v0.0.2"
description: "Душой информационной системы являются её эффекты. Именно на основании эффектов конечные пользователи выносят суждения о корректности работы системы. И при столь большой важности эффектов, в мире не существовало инструмента для визуализации и проектирования эффектов. Поэтому я придумал свой - диаграмму эффектов"
date: 2022-05-01T08:25:37+07:00
draft: false
---
:source-highlighter: roug
:rouge-theme: github
:icons: font
:sectlinks:
:imagesdir: /drafts/effects-diagram/images

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

[NOTE]
====
Этот пост является первой попыткой описать диаграмму формально, поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.
====

Это первый пост в серии, посвящённый диаграмме эффектов:

. "Спецификация": назначение диаграммы, основные концептуальные элементы и их визуальное представление
. "Пример построения диаграммы, проект True Story Project (TSP)" - процесс построения диаграммы эффектов реального проекта
. "Методика объектно-ориентированной декомпозиции" - рациональный подход к разбиению системы на модули с помощью диаграммы эффектов и его применение для декомпозиции проекта TSP
. "Методика перевода диаграммы в код" - процесс трансляции диаграммы в исходный код на примере проекта TSP

== Введение

Идентичность информационной системы определяется тем, как она взаимодействует с внешним миром.
Что, где и когда она сохраняет; что, откуда и когда она запрашивает; что, куда и когда она отправляет.
Это я называю наблюдаемым поведением.

Можно переписать приложение с Java на Haskell, сменить слоёную архитектуру на шестиугольную, реляционную базу данных заменить документной, а пользовательский интерфейс перевести с серверной генерации HTML на React Native - если наблюдаемое поведение системы останется неизменным, то это будет просто очередная версия всё той же системы.
Если же кардинально изменить её взаимодействие с внешним миром, то это будет уже другая система.

Именно на основании наблюдаемого поведения конечные пользователи выносят суждения о корректности работы программы.
Даже для того чтобы оценить корректность результата сложного вычисления, пользователю в первую очередь надо чтобы правильно сработал механизм отображения этого результата.


При всей значимости наблюдаемого поведения, я не знаю ни одного общепринятого инструмента для его проектирования и визуализации.
Поэтому изобрёл свой - диаграмму эффектов.

[NOTE]
====
При чём здесь эффекты?
При том, что наблюдаемое поведение состоит из эффектов.
И так короче.
====

== Концептуальная модель: триада События-Эффекты-Ресурсы

Концептуальная модель диаграммы эффектов состоит из трёх ключевых типов элементов: событий - триггеров работы системы, эффектов - атомарных действий системы и ресурсов - объектов (в https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82[философском смысле] этого слова) действий системы.

=== Эффект

Если не вдаваться в философию программирования, то *эффект* - это ввод-вывод.
Включая запись и чтение глобальных переменных (кучи).

Очевидно, глобально эффекты бывают двух видов - чтения и записи.
Первые изменяют состояние программы, вторые - состояние окружающего мира.

[NOTE]
====
Впереди - часть моей личной и не до конца оформленной версии философии программирования - её можно смело пропустить, без ущерба для основной части поста.

Так вот если всё-таки немного вдаться в философию, то в программировании эффект - это всегда *действие* по изменению состояния какого-то транзистора.
В эффекте чтения состояние транзистора памяти внешнего устройства через несколько промежуточных этапов попадает в регистр процессора (который является группой транзисторов).

В эффекте записи наоборот состояние регистра процессора переносится в транзистор внешнего устройства.
На этом эффект может быть завершён, в случае жёсткого диска, либо это состояние может быть "аналогизировано" - превращено в физический процесс (например, световую волну или движение ноги робота).
Так эффект работы программы становится наблюдаемым поведением.

Вообще в максималистичном понимании "неэффектов" не существует - любое действие в программе выражается в изменении состояния транзисторов.
В https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0[фон Нейманавской архитекутре], по крайней мере.

При этом существует функциональная парадигма программирования, которая характеризуется акцентом на функциях без эффектов.
Но даже идеально чистая вызывающая функция записывает данные в память, выделенную для стэка, и ожидает, что идеально чистая вызываемая функция их считает, а потом запишет свой результат.

Я ни разу не встречал формального определения того, что считается эффектом, а что "неэффектом".
Но, по-видимому, общепринятое мнение таково, что изменение регистра процессора и стэка программы эффектами не считается, а любые изменения начиная с кучи программы и далее - считаются.
То есть разница между эффектом и "неэффектом" в области видимости.
Или, другими словами, количеством наблюдателей поведения.

Высокоуровневый эффект может проходить через несколько этапов переноса, посредством чтения и записи.
Например, эффект "Отправить пуш уведомление" пройдёт такой путь: сначала информация переносится через кэши из процессора в память программы, потом в память ОС, потом в память сетевой карты, потом через память нескольких роутеров и серверов в память сетевой карты другого компьютера, там обратно в память программы, а оттуда, опять же через несколько слоёв, в память монитора, где состояние транзистора "аналогизиурется" в свечение пикселя.
И где-то попутно этот эффект заодно осядет на транзисторах диска БД пуш-сервиса.

Но возвращаемся на уровень абстракции разработчика информационных систем: эффект - это ввод-вывод плюс чтение-запись глобальных переменных.
====

=== Событие

Программы (особенно интерактивные) редко выполняют эффекты сплошным потоком - обычно программа выполняет набор эффектов в ответ на какое-то *событие* и засыпает до следующего события.
Таким событием может быть получение вызова удалённой процедуры в любом виде, появление нового сообщения в некоторой очереди, наступление определённого момента времени или истечение определённого периода времени.

По сути, события также являются эффектами (перенос Wi-Fi-сигнала, например, в память программы в виде DTO с данными пользователя), но эти эффекты обычно низкоуровневые и выполняются фреймворком или платформой.

=== Операция

Как правило, для реализации функции системы требуется несколько эффектов.
Как минимум что-то считать и потом записать обратно.
Группы эффектов, реализующих одну функцию системы, образуют *операции* системы.
Система может реагировать как несколькими операциями, в ответ на одно событие, так и одной операцией в ответ на несколько событий разных типов.

=== Ресурс

Наконец, у эффектов, которые являются действиями, есть объект - целевое состояние .
Это какая-то часть физического мира, с которой будет взаимодействовать устройство ввода-вывода в процессе реализации эффекта.
Чаще всего целевым состоянием выступают биты на носителях информации, но это могут быть и пиксели экрана, и динамик колонки и нога робота.
Эти кусочки физического мира представленны их абстракциями в системе - *ресурсами*.

Чёткое понимание триады События-Эффекты-Ресурсы - в ответ на какие события, какими эффектами на какие ресурсы система должна реагировать - крайне полезно на всех этапах жизненного цикла разработки системы.

На этапе оценки триада помогает осознать количество функций системы и примерную трудоёмкость реализации каждой из них.

На этапе проектирования операции и ресурсы становятся основными блоками, правильная декомпозиция которых создаст основу для системы с низкой сцепленностью.

На этапе реализации оценочная сложность операций (определяемая количеством и типом обеспечивающих её ресурсов) и их зависимости через ресурсы помогают определить порядок выполнения работ и те работы, которые могут быть выполнены параллельно.

Наконец, на этапе поддержки сцепленность операций через ресурсы помогает спрогнозировать последствия планируемого изменения и предотвратить внесение регрессий.

Изначально я осознал важность триады именно в контексте модификации сложных операций и представлял её в виде link:++{{<relref path="/book/ergo#_таблица_эффектов" lang="ru">}}++[таблицы эффектов].
Однако постепенно таблица трансформировалась в диаграмму, а я увидел её пользу для других этапов работы.
Это привело к тому, что триада стала моим способом размышлять о программах и легла в основу моей каждодневной работы.

== Реализация триады События-Эффекты-Ресурсы в коде

Все описанные выше элементы транслируются непосредственно в код: события и операции - в методы, ресурсы - в классы, эффекты - в вызовы методов.

[NOTE]
====
Тут есть небольшая шероховатость.
События на самом деле транслируются в метод, передаваемый фреймворку (см. ниже) и вызов из него метода операции.
По крайней мере если следовать принципам единственности ответственности и/или разделения аспектов (separation of concerns).
Но пока что я не вижу ни потребности, ни возможности отразить это в концептуальной модели.
Возможно, позже, я найду какую-то другую абстракцию для события - в конце концов, технически ничего не мешает передать метод операции напрямую фреймворку.
====

Операции всегда транслируются в методы классов слоя сервисов приложения - методы определяющие публичный интерфейс модуля.
При том при реализации желательно сохранить очевидность эффектов выполнения операции, присущую диаграмме.

События превращаются в методы, передаваемые фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера и т.д.
Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются:

. Получение запроса по сети (@RestController + @*Mapping в случае разработки на Spring).
  Сейчас популярностью пользуется протокол запросов в REST-стиле, но SOAP, gRPC, CORBA и т.п. так же попадают в эту категорию.
. Появление сообщения в очереди (@EventListener, @JmsListener).
  Это может быть как "вне-процессная" очередь, вроде ActiveMQ, так и "внутри-процессная" очередь вроде Spring ApplicationEventPublisher.
. Наступление определённого момента времени (@Scheduled).
  Два основных типа таких событий - наступление заранее известного момента времени (например, полуночи вторника) и истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).

Ресурсы же превращаются в структуру данных и коллекцию методов работы с ней - классы Spring Data агрегата и репозитория, классы события и ApplicationEventPublisher-а (или обёртки вокруг него), классы REST API модели и клиента и т.п.
В контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются:

. любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.
. REST API внешних сервисов
. любые очереди сообщений/шины данных
. изменяемые структуры данных, доступные через глобальные переменные

== Нотация

[NOTE]
====
Нотация с большой вероятностью претерпит косметические изменения в процессе бета-теста, а так же в связи с привлечением профессионального дизайнера к полировке визуального языка перед релизом 1.0.
====

Основу визуального языка диаграммы эффектов я позаимствовал в https://c4model.com/[модели C4].
Во-первых, мне нравится сам язык модели C4.
А во-вторых, диаграмму эффектов можно встроить в модель C4 на четвёртом уровне - вместо кода.
Кроме того, диаграмму третьего уровня (компонентов) я строю как раз на базе диаграммы эффектов.

Диаграмма эффектов бывает двух типов - краткая и полная.
Краткая содержит только обозначение эффектов и связанных ими операций и ресурсов.
Полная нотация дополнительно включает события и их источники, внешние системы, обеспечивающие реализацию ресурсов и более полное описание всех элементов.

Рассмотрим нотации с помощью минимального примера визуализации функциональности регистрации и аутентификации пользователей в произвольной системе.
После успешной регистрации пользователям необходимо отправлять приветственное письмо.
Начнём с краткой нотации.

=== Краткая нотация

В краткой нотации диаграмма выглядит следующим образом (картинка кликабельна):

image::short-notation-example.svg[link={imagesdir}/short-notation-example.svg]

Теперь рассмотрим отдельные элементы

==== Операции

Операции обозначаются прямоугольником с именем операции:

image::operation.svg[]

==== Ресурсы

Ресурсы обозначаются прямоугольником с именем ресурса и цветом отличным от цвета операции:

image::resource.svg[]

==== Эффекты


Эффект модификации ресурса обозначается "сильной" (более заметной) стрелкой от операции к ресурсу, с кратким описанием эффекта:

image::operation-resource-rw.svg[]

Эффект чтения ресурса обозначается стрелкой от ресурса к операции, с кратким описанием считываемых данных:

image::operation-resource-ro.svg[]

==== Эффекты вызова операций

Дополнительно есть особый вид стрелок для эффектов вызова операций в следствии взаимодействия с ресурсами.
Как правило, это ресурсы всевозможных шин событий и связанные с ними операции-обработчики.
Такие связи отображаются прерывистой стрелкой того же стиля, что и стрелка эффекта записи с кратким описанием связи:

image::resource-operation-rw.svg[]

==== Примечания

Дополнительно на диаграмму можно помещать заметки и примечания, используя любую удобную нотацию.
Я предпочитаю нотацию UML - "лист" с загнутым углом, связанный прерывистой линией с комментируемым элементом.

image::note.svg[]

Это все элементы, составляющие ядро диаграммы эффектов.

=== Полная нотация

Теперь рассмотрим ту же функциональность, описанную в полной нотации:

image::full-notation-example.svg[link={imagesdir}/full-notation-example.svg]

В полной нотации появляются:

. события
. описание операций и ресурсов в формате модели C4
. границы контейнера из C4.
  Обозначает границы процесса - всё что находится внутри этих границ выполняется в памяти визуализируемого приложения.
. внешние системы, базы данных и компоненты из C4.
  Внешние системы могут быть как источником события, так и средством реализации ресурса.

Расширять состав диаграммы можно постепенно, добавляя только те элементы, которые помогают в решении текущей задачи.

==== События

На мой взгляд, из дополнительных элементов наибольшую ценность имеют события.
В полной нотации они обозначаются стрелкой от внешней системы к операции с кругом на стартовом конце и описанием в формате C4.
Но в промежуточной версии, внешнюю систему можно опустить и "подвесить" стрелку:

image::event-operation.svg[]

==== Описания

Затем можно дополнить типом, способом реализации и описанием блоки операций и ресурсов:

image::descriptions.svg[]

==== Внешние системы

Границы системы и внешние системы полностью соответствуют нотации C4:

. Границы отображаются "приглушённым" прямоугольником с прерывистой границей и подписью с именем контейнера
. Неуправляемые внешние системы и компоненты и базы данных обозначаются "приглушёнными" прямоугольниками и символом "База Данных" соответственно
. Управляемые внешние системы и базы данных обозначаются прямоугольником и символом "База Данных"

Внешние системы связываются с операциями посредством событий:

image::event-sources.svg[]

А ресурсы связываются со внешними системам по средствам стрелок с описанием:

image::resource-impls.svg[]

Ресурс может быть связан со сторонним компонентом, работающем в том же процессе:

image::resource-component.svg[]

Здесь приведена, связь ресурса с эффектом вызова операции системы, в случае же если ресурс не обладает таким эффектом, то он соединяется со сторонним компонентом обычной стрелкой.

Выбор нотации зависит от решаемой задачи.
Если надо быстро разбить систему на модули, или спланировать модификацию сложной или незнакомой операции - можно обойтись краткой нотацией.
Если надо оценить проект для работы за фиксированную цену - лучше взять полную нотацию, чтобы минимизировать вероятность "потери" существенных деталей.

Ещё два критерия выбора нотации - срок жизни диаграммы и размер целевой аудитории диаграммы.
Если планируете выкинуть диаграмму после анализа и никому не будете её показывать - можно обойтись краткой нотацией.
Если же вы планируете возвращаться сами к диаграмме через длительный срок или публиковать её для ознакомлении без вашего руководства - стоит как минимум добавить события и описания ресурсов и операций.

Я сам обычно начинаю с промежуточной нотации - краткой с событиями, и дополняю её по мере необходимости.

== Инструментарий

Одним из плюсов базирования на визуальном языке модели C4 является то, что для диаграммы эффектов можно использовать https://c4model.com/#Tooling[любой инструмент с поддержкой C4].
А в силу простоты C4 таким инструментом может быть хоть графический редактор.
Тем не менее, поддержка привязки элементов сильно помогает, поэтому я сам сейчас использую https://www.diagrams.net/[десктопную версию draw.io].

== Заключение

Сущность информационной системы заключена в её поведении - эффектах на окружающий мир.

Самым эффективным способом отразить суть поведения системы является триада События-Эффекты-Ресурсы - какими эффектами на какие ресурсы в ответ на какие события система реагирует.

Для визуализации, анализа и проектирования этой триады я разработал диагрмму эффектов и с радостью делюсь с вами этим инструментом.
Надеюсь он поможет вам лучше понять душу ваших программ и точнее отразить её в более link:++{{< ref "posts/22/04/220409-ergo-approach-v10m1">}}++[эргономичном коде].

Но прежде чем приступить к визуализации триады, её надо понять.
В следующем посте я опишу процесс построения диаграммы эффектов (читай - понимания сути задачи) реального проекта.
