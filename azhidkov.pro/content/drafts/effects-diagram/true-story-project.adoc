---
title: "Диаграмма Эффектов v0.0.2: пример построения диаграммы эффектов"
description: "Этот пост ялвяется второй частью из серии постов о диаграмме эффектов и приводит пример построения диаграммы эффектов реального проекта"
date: 2022-05-02T08:25:37+07:00
draft: false
---
:source-highlighter: roug
:rouge-theme: github
:icons: font
:sectlinks:
:imagesdir: /drafts/effects-diagram/images

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

Это второй пост в серии, посвящённый диаграмме эффектов:

. (#todo: линка#) Вступление - описывает необходимость в диаграмме, основные элементы диаграммы и их визуальное представление
. Пример построения, проект True Story Project (TSP) - приводит пример построения диаграммы для реального проекта
. Декомпозиция системы на модули базе диаграммы эффектов - описывает методику декомпозиции системы на модули на базе диаграммы эффектов и иллюстрирует её на примере декомпозиции проекта TSP
. Перевод диаграммы в код - описывает процесс трансляции диаграммы в исходный код на примере проекта TSP

== Диаграмма эффектов системы актуализации данных в Яндекс.Картах и 2Гис (True Story Project, TSP)

Я сейчас заканчиваю небольшой проект по автоматизации обновления информации о компании в Яндекс.Картах и 2Гис.
Это идеальный проект для иллюстрации диаграммы эффектов - он небольшой, но включает все основные типы событий и ресурсов:

image::true-story-effects.svg[link={imagesdir}/true-story-effects.svg]

Все новые проекты я начинаю с диаграммы эффектов по ряду причин.

На этапе оценки диаграмма эффектов помогает определить основные блоки реализации, убедиться, что ничего не забыто и понятно как реализовать каждую из операций системы.
А формула `(<кол-во операций>+<кол-во ресурсов>) * 12 часов` даёт хорошее первое приближение трудоёмкости работы, если все операции и ресурсы типовые.

На этапе проектирования я использую диаграмму эффектов для разбиения системы на модули.

А затем, на этапе планирования работы, полученные модули, а так же явные и, что важнее, неявные связи между ними я использую для определения порядка выполнения работ и возможности их распараллеливания.

== Процесс построения диаграммы

Этот проект я делаю по "Time&Material", поэтому на самом деле сделал не полную диаграмму, приведённую выше, а краткую с событиями - её и будем строить в этом посте.

Итак, поехали.
На старте у меня было ТЗ, которое можно ужать до следующих пунктов:

. У заказчика есть проблема: ему необходимо держать информацию об его организациях в ряде геосервисов в актуальном состоянии
. Ключевым геосервисом являются Яндекс Карты, но дополнительно необходимо учитывать работу с 2Гис
. Организаций у заказчика существенно больше тысячи, поэтому фид необходимо обновлять по расписанию
. Интеграция с Яндекс Картами заключается в том, что робот Яндекса приходит на специально выделенный URL и забирает оттуда фид в https://yandex.ru/support/business-priority/branches/xml-feed-sprav.html#q1__6[проприетарном XML-формате]
. Яндекс требует, чтобы фид всегда был доступен по заданному URL, поэтому необходимо обеспечить постоянное хранение последнего сгенерированного фида
. Интеграция с 2Гисом выполняется посредствам отправки фида на Email, но уже в другом формате
. Список организаций необходимо получать из специального сервиса заказчика по REST API
. Ещё часть данных хранится во внутренней СУБД заказчика и извлекается с помощью JDBC и SQL-запроса, предоставленного заказчиком
. Наконец, фид может содержать ссылки на фотографии организаций, и управление этими фотографиями должен обеспечить разрабатываемый сервис.
Доступ к этой функциональности должен быть обеспечен посредством REST API.
Конкретное хранилище изображений можно выбрать на своё усмотрение.

Работу можно начать сразу с построения диаграммы эффектов, но я обычно в первом проходе составляю просто списки событий, операций и ресурсов, т.к. по мере вычитки ТЗ их состав наверняка будет меняться и уточняться.
Кроме того, при первой вычитке ТЗ я обычно строю ER-диаграмму, но в данном случае модель данных примитивная я не буду усложнять пример её построением.

Поэтому давайте пройдёмся по "ТЗ" и сделаем на его основе три артефакта: список операций системы, список событий системы и список ресурсов.

Из пункта №1 мы можем сделать вывод, что у нас будет ресурс *"Коллекция организаций"*, но пока не понятно, как он будет реализован - добавляем его в соответствующий список со знаком "?".

Пункт №2 говорит нам о том, что нам потребуются ещё 2 ресурса - *"Интеграция с Яндекс.Картами"* и *"Интеграция с 2Гис"* - так же добавляем список с вопросом.

Пункт №3 даёт нам событие *"Scheduler: Истёк срок действия фида"* и операцию *"Обновить фид"* - добавляем в списки событий и операций.
Уже сейчас понятно, что эта операция будет связана со всеми известными на данный момент ресурсами - можно это как-то отметить в списке, но я сейчас обычно обхожусь без обозначения связей, чтобы держать списки минимально простыми.

Пункт №4 проясняет нам интеграцию с Яндексом.
На самом деле у нас pull-модель - не мы "толкаем" фид в Яндекс, а он "вытягивает" фид из нашей системы.
Это даёт нам новые событие и операцию - *"HTTP: Запрос фида"* и операцию *"Выдать фид Яндекса"*.

Тут мы должны задуматься, как ресурс обеспечит реализацию операции - сейчас у нас такого нет, зато есть устаревший *"Интеграция с Яндекс.Картами"*.
Очевидно, нам нужен какой-то кэш, куда операция *"Обновить фид"* будет писать данные, а *"Выдать фид Яндекса"* их будет оттуда забирать - меняем название ресурса на *"Фид Яндекса"*.

Пункт №5 дальше уточняет этот ресурс - это должен быть какой-то персистентный кэш, помечаем в списке.

Пункт №6 проясняет способ реализации интеграции с 2Гис - уточняем его в списке.

Пункт №7 уточняет способ реализации ресурса *"Коллекция организаций"* - REST, уточняем его в списке.

Пункт №8 определяет ещё один ресурс операции *"Обновить фид"* - *"JDBC: Дополнительная информация"*, добавляем его в список.

Наконец, пункт №9 определяет новый ресурс *"Изображения"* и набор операций *"Загрузить изображение"*, *"Скачать изображение"*, *"Выдать список изображений организации"*, *"Удалить изображение"*, с набором соответствующих событий об обращениях к HTTP эндпоинтам.

В итоге у нас получились следующие списки.

События:

. Scheduler: Истёк срок действия фида
. HTTP: Запрос фида
. HTTP: Запрос загрузки нового изображения
. HTTP: Запрос изображения
. HTTP: Запрос списка изображений организации
. HTTP: Запрос удаления изображения

Операции:

. Обновить фид
. Выдать фид Яндекса
. Загрузить изображение
. Скачать изображение
. Выдать список изображений организации
. Удалить изображение

Ресурсы:

. REST: Коллекция организаций
. Персистентный Кэш?: Фид Яндекса
. Email Server: Интеграция с 2Гис
. JDBC: дополнительная информация
. ???: Изображения

Теперь построим первую версию диаграммы эффектов, просто перенося элементы и попутно отмечая связи между ними.
Как именно переносить - сверху вниз, снизу вверх или в случайном порядке - не так важно.
Я предпочитаю идти по событиям, но для каждого события целиком раскрывать инициируемые им эффекты.

Например, если начать с первого события *"Истёк срок действия фида"*, то мы раскрутим сразу половину диаграммы - само событие *"Истёк срок действия фида"*, операцию *"Обновить фид"*, ресурсы *"Коллекция организаций"*, *"Дополнительная информация"*, *"Изображения"*, *"Фид Яндекса"* и *"Интеграция с 2Гис"*
Добавляем всё это на диаграмму, связываем операции с ресурсами эффектами и получаем примерно такую картину:

image::update-feed-v1.svg[]

В этот момент я могу задуматься о том, как будет реализована операция *"Обновить фид"* - _"я пробегусь по списку организаций, для каждой организации подтяну дополнительную информацию и фотографии - все необходимые ресурсы есть, верхнеуровнево всё понятно"_, подумаю я.

Кроме того, мне надо будет проверить что внешние ресурсы предоставляют мне нужное API.
А при выборе способа реализации ресурса *"Изображения"*, который меня пока под вопросом, мне надо будет убедиться, что выбранный способ обеспечит возможность хранения привязки файлов фотографий к организациям.
Но я это пока просто помечу в заметках по проекту и продолжу строить диаграмму эффектов.

Однако эта диаграмма триггерит у меня одно из эвристических правил работы с эффектами - более одного эффекта-записи у операции часто указывает на нарушение одного из принципов:

. низкой сцепленности, высокой связности
. единственности ответственности
. открытости/закрытости

Это не всегда так, но в данном случае текущая версия диаграммы точно нарушает третий из них - добавление нового геосервиса потребует модификации существующего кода.
А у нас в бэклоге, по секрету, болтается ещё потенциальная интеграция с Гуглом.
Да и про низкую сцепленность и единственность ответственности тоже можно порассуждать, но не хочу размывать фокус поста.

Самым простым и универсальным способом расцепить эффекты записи является шина событий и в нашем случае она вполне себе подойдёт.
Для того чтобы провести этот "рефакторинг" нам надо добавить новый ресурс *"Тема (Topic) 'Сгенерирован новый фид'"* и соответствующее событие *"Оповещение о генерации нового фида"*, которое будет обрабатываться новыми операциям *"Обновить фид Яндекса"* и *"Отправить фид в 2Гис"*.
Добавив всё это на диаграмму (про списки можно уже забыть), получаем новую версию:

image::update-feed-v2.svg[link={imagesdir}/update-feed-v2.svg]

На этом ветка обработки события *"Истёк срок действия фида"* у наз заканчивается и мы можем переходить к следующему событию - *"Запрос фида"*.
Для этого события уже всё готово - осталось только привязать его к ресурсу *"Фид Яндекса"* через операцию *"Выдать фид Яндекса"*.

Далее мы аналогичным образом добавляем на диаграмму события запросов связанных с изображениями и получаем финальную версию диаграммы эффектов проекта True Story в краткой нотации с событиями:

image::true-story-effects-short.svg[link={imagesdir}/true-story-effects-short.svg]

Текущую ветку мы прошли до конца - можем вернуться к спискам, вычеркнуть то, что уже перенесли на диаграмму и обнаружить, что у нас остались только события и операции API управления фотографиями - переносим их на диаграмму и немного полируем раскаладку.

На диаграмме осталась пара вопросов - как реализовать ресурсы *"фид Яндекса"* и *"Коллекция фотографий"*.
Сами фотографии явно лучше хранить в хранилище BLOB-ов вроде Amazon S3.
Там же можно хранить и фид Яндекса - у этого ресурса тривиальное API сохранения и получения файла по ключу.

Но при ближайшем рассмотрении, выясняется, что с фотографиями есть нюанс - помимо операций по ключу есть и поиск по организации.
Теоретически это можно реализовать посредствам бакетов или "папок" S3, но на мой вкус это решение уже начинает дурно пахнуть.
А чуть позже, когда мы внимательнее изучим формат фида Яндекса, мы увидим что у фотографий есть ещё и мета информация в виде типа и тэгов - хранить в S3 это будет уже совсем плохой идеей.
Значит нам нужна более продвинутая СУБД, у меня по умолчанию - PostgreSQL.

Но хранить в PostgreSQL сотни гигабайт - тоже сомнительная затея.
Значит реализацию ресурса *"Коллекция фотографий"* будет состоять из двух частей - *"Коллекция файлов"* и *"Коллекция мета информации"*.
Модификации этих ресурсов должны быть атомарными, поэтому на диаграмме я не буду разделять ресурс, а добавлю примечание.

В итоге мы получаем финальный вариант диаграммы эффектов проекта TSP в краткой нотации (картинка кликабельна):

image::true-story-effects-short.svg[link={imagesdir}/true-story-effects-short.svg]

== Заключение

Построение диаграммы эффектов дало нам довольно много:

. В первую очередь мы чётко увидели что надо сделать - какие операции есть у системы и что они должны делать
. Мы получили список ключевых работ, которые необходимо выполнить для решения задачи - это можно взять за основу для оценки трудоёмкости работ
. Мы увидели часть реализации, в которой было легко допустить высокую сцепленность и смогли этого избежать
. Мы получили иллюстрацию, которая сформировала нам интуицию, чтобы декомпозировать систему на модули - вы же тоже видите на картинке модуль изображений, модуль фида, модули интеграции с Яндексом и 2Гисом?

Но и это ещё не всё.
Диаграмма эффектов так же даёт нам вводные для рациональной декомпозиции системы на модули и для планирования работ.
Что это за вводные я напишу в следующем посте.
