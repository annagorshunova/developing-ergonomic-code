---
title: "Эргономичный подход"
description: "Или как создавать программы, которые всем стейкхолдерам приносят больше положительных эмоций"
date: 2022-04-01T08:25:37+07:00
draft: false
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font

Я люблю писать программы и хочу, чтобы этот процесс приносил мне больше положительных эмоций, чем отрицательных.
На удивление, человеку, который платит за мою работу так же выгодно, чтобы разработка приносила мне больше положительных эмоций.

Отрицательные эмоции при разработке как правило возникают либо от того, что внесение изменений в программу требует неадекватно больших усилий, либо от того, что последствия изменений невозможно предсказать.
Первое влечёт раздражение и злость из-за необходимости делать выполнять много работы, для достижения небольшого результата.
Второе влечёт страх внесения регрессий.

И то и другое влечёт увеличение стоимости разработки само по себе.
Плюсом туда идёт время на прокрастинацию работы программистом из-за страха или раздражения.

Между тем, люди ещё в 70ых годах выяснили, что основным источником проблем (и как следствие увеличения стоимости) в развитии програм является сцепленность (coupling).
Очевидно, сцепленность является причиной как чрезмерно трудоёмких изменений, так и регрессий.

(#todo: нужен переход от эмоций к сцепленности#)

И не смотря на это, 50 лет спустя работа в большинстве чужих проектов сопровождалась для меня злостью и страхом.
Так получается, потому что в сейчас в мейнстримном подходе к разработке существует огромне количество практик, которые упрощают решение задачи в момент за счёт увеличения сцепленности системы.
Следствием этого являются описанные выше проблемы, которые приводят к увеличению итоговой стоимости разработки.

Для того чтобы минимизировать количество отрицательных эмоций при работе со своими проектами (а за одно и их стоимость для заказчиков), я нашёл альтернативные практики, которые минимизируют сцепленность системы
За это зачастую приходится платить усложнением задачи в моменте.
Но следствием этого является решение описанных выше проблем и минимизация итоговой стоимости разработки.

Объединив и подогнав друг к другу эти практики я получил "стратегическую" методику разработки програм - Эргономичный Подход.

У меня (и не только) есть эмпирическое ощущение, что инвестиции в дизайн начинают окупаться уже через 2-3 месяца от старта проекта, а в районе 6 месяцев "стратегические" проекты обгоняют в сроке релиза аналогичные по функциональности "тактические" проекты.

Большая часть этих практик давно известна и пропагандируется много известными инженерами и учёными:

. Агрегаты из ДДД, вместо связного графа объектов
. Неизменяемая модель данных и эпохальная модель времени из ФП, вместо императивной изменяемой модели
. Фокус на чистых функциях из ФП, вместо повсеместного императивного программирования
. Как следствие первых трёх пунктов - Spring Data JDBC, вместо Spring Data JPA
. Функциональная декомпозиция из чистой архитектуры и ДДД, вместо механической декомпозиции по техническим аспектам кода
. Тестирование бизнес сценариев из классического подхода Бека, вместо тестирования отдельных классов и методов
. Тестирование модулей в конфигурации приближенной к боевой из классического подхода, вместо мокирования всех зависимостей
. Разделение кода на чистое ядро и императивную оболочку из ФП (и ДДД и Чистой архитектуры), вместо разделения кода на слои представления, бизнес-логики и данных
. Крафтовое управление зависимостями, вместо неуправляемого глобального Spring Component Scan
. Крафтовая настройка инфраструктуры, вместо неуправляемых глобальных Spring Auto Configuraions

Теперь давайте рассмотрим методику подробнее.
Глобально разработка по Эргономичному Подходу состоит из привычных этапов - системная аналитика, проектирование и реализация.

На этапе системной аналитики строятся ER-диаграмма модели информации, определяется список необходимых интеграций и АПИ системы.
Все три этих артефакта сильно связанны между собой и строятся они параллельно в процессе разбора и проработки требований.

После этого применяется моё ноухау - диаграмма эффектов.
Диаграмма эффектов объединяет в себе предыдущие три артефакта и является входом для этапа проектирования.
Изначально в диаграмму эффектов каждая сущность входит как отдельный ресурс, поэтому после построения диаграммы эффектов я приступаю к проектированию агрегатов и по мере обнаружения агрегатов, я заменяю ресурсы соответствующих сущностей на ресурс агрегата.
Спроектировав агрегаты я перехожу к этапу проектирования.

Этап проектирования я начинаю с того, чтобы декомпозировать диаграмму эффектов на модули таким образом чтобы:

. инкапсулировать модификации ресурсов в одном модуле
. инкапсулировать переиспользуемые ресурсы в одном модуле
. минимизировать сцепленность модулей

Затем я без фанатизма пытаюсь построить список сокрытия информации из декомпозиции по Парнасу.
Если в результате нахожу что-то существенное - отражаю это на диаграмме модулей.

После этого я проверяю получившуюся декомпозицию на предмет соответствия принципам:

. Ацикличных зависимостей
. Высокой функциональной связанности, низкой сцепленности
. Стабильности зависимостей
. Единства ответственности

Если в процессе я вижу, что какие-то модули являются деталью реализации других модулей - я делаю их подмодулями.

Получив "достаточно хорошую" декомпозицию я перехожу к этапу реализации.

Который начинаю с того, что завожу по пакету для каждого модуля, а в пакете создаю как минимум Spring конфигурацию и сервис.

С тех пор, как я перешёл на тестирование сценариев использования, я стал сторонником ТДД, поэтому следующим шагом я пишу сценарный тест.
Который, естественно, падает.

Если я делаю первый юз кейс системы, то я создают точку входа.
При этом я не пользуюсь глобальными Spring Component Scan и AutoConfiguration - я в корневой конфигурации приложения импортирую конфигурации модулей этого приложения.
Если модулям нужна инфраструктура (например подключение к БД) - я для этого создаю отдельные конфигурации и импортирую их.
Компонент скан у меня вообще отключен.

После чего я перехожу к реализации операций системы, задействованных в падающем на данный момент тесте.
Для этого, как правило, надо реализовать два класса ресурса - отдельные элементы (сущности, ДТОшки, события и т.п.) и их коллекции (репозитории, REST-клиенты, топики в очередях событий).
Эти классы я стараюсь сделать package private, хотя если отдельные элементы надо выдавать наружу как есть, я не вижу ничего страшного в том, чтобы выставить их в публичный интерфейс модуля.

В реализации придерживаюсь структуры ориентированной на трансформации и функциональной архитектуры.
Их этого следует несколько вещей:

. Отдельные элементы я делаю неизменяемыми
. Коллекции я делаю максимально декларативными, идеал коллекции - интерфейс Spring Data репозитория.
. в классе сервиса я оставляю только верхнеуровневое управление потоком данных
. преобразования (если они есть) я уношу либо в классы отдельных элементов, либо в чистые функции.

После того, как сценарный тест прошёл, я прислушиваюсь к себе достаточно ли мне этого для того чтобы спать спокойно.
Если недостаточно - я перехожу к модульным или юнит тестам.

Получив достаточную степень уверенности я отдаю код на ревью и, вмёржив его, перехожу к реализации следующего сценария.
