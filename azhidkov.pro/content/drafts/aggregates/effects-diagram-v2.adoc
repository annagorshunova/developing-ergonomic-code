---
title: "Диаграмма Эффектов v0.0.1"
date: 2022-04-01T08:25:37+07:00
draft: false
---
:source-highlighter: roug
:rouge-theme: github
:icons: font

== Введение

Основными задачами разработчика информационных систем являются оценка, проектирование и собственно реализация ИС.
После чего эти самые информационные системы приходится ещё и поддерживать.

Для выполнения этих задач, разработчику необходимо понимать три вещи:

. События - на какие внешние раздражители система реагирует
. Операции - какими действиями она реагирует на события
. Ресурсы - что необходимо для обеспечения операций

На этапе оценки эта триада позволяет понять масштаб предстоящей работы.
На этапе проектирования она помогает увидеть ключевые блоки реализации и их взаимосвязи.
На этапе реализации триада (События-Операции-Ресурсы) определяет что необходимо сделать.
Наконец, на этапе модификации она помогает увидеть, какие ресурсы задействованы в целевой операции, и какие ещё операции обеспечиваются теми же ресурсами.
Это в свою очередь помогает спрогнозировать последствия планируемого изменения и предотвратить внесение ошибок.

Насколько я знаю, не существует общепринятого инструмента визуализации этой триады.
Поэтому изобрёл свой - диаграмму эффектов.
И этот пост является первой попыткой описать диаграмму формально.
Поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.

== Диаграмма эффектов v0.0.1

Диаграмма эффектов помогает рассмотреть систему с точки зрения операций (ответсвенностей, поведения) системы.
Каждая операция характеризуется набором событий, приводящей к её исполнению и набором ресурсов, необходимых для её исполнения.
События и операции связаны вызовами (не важно, синхронными или асинхронными).
Операции и ресурсы связаны обращениями на чтение и запись - эффектами.
(#todo: так почему всё-таки эффектов?#)
Вот собственно и вся нотация - три вида блоков, связанных тремя  видами стрелок.
Но по моему опыту это очень мощный инструмент, который очень лаконично отражает саму суть системы.

[NOTE]
====
При желании, вызовы так же можно разделить на команды и запросы.
Если операция содержит хоть одно обращение на запись, то все её вызовы являются командами, в противном случае - запросами.
====

В v0.0.1, все элементы транслируются непосредственно в код: события и операции в методы, а ресурсы - в классы.
Операции всегда транслируются в методы классов слоя сервисов приложения - методы определяющие публичный интерфейс модуля.
А вот события и ресурсы бывают разные.

Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются:

. Получение запроса по сети.
  Сейчас самым распространённым протоколом запросов явлется REST, но SOAP, gRPC, CORBA и т.п. так же попадают в эту категорию.
. Получение сообщения по очереди событий.
  Это может быть как и "внепроцессная" очередь, вроде ActiveMQ, так и "внутрипроцессная" очередь вроде Spring Application Event Publisher.
. Наступление определённого момента времени.
  Такие события так же бывают двух типов - наступление заранее известного момента времени (например, полуночи вторника) и истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).

В коде события превращаются в метод, передаваемый фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера и т.д.

В контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются ресурсы с состоянием:

. Любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.
  Реляционные (и любые нормализованные) базы данных дают довольно низкоуровневую картину, с которой не очень удобно работать, поэтому в качестве базовых блоков подобных ресурсов я предпочитаю использовать DDD Агрегаты
. REST API внешних сервисов
. Любые очереди сообщений/шины данных
. Коллекции файлов на диске
. Глобальные изменяемые структуры данных

Но ресурсами могут выступать и сложные/большие алгоритмы - библиотека для символьного дифференцирования, например.

В коде ресурсы превращаются в структуру данных и коллекцию методов работы с ней - Spring Data JDBC агрегат и Spring Data JDBC репозиторий, событие и Spring Application Publisher, REST API модель и клиент и т.п.

== Нотация

[NOTE]
====
Нотация - это то, что я точно существенно перетрясу с помощью специально обученных людей перед релизом версии 1.0.
====

События обозначаются жёлтой стрелкой с опциональным, но крайне желательным стереотипом с указанием способа их доставки:

image::/drafts/aggregates/images/event.svg[]

Если у события есть параметры, они включаются в имя события и обозначаются фигурными скобками.

Операции обозначаются зелёным прямоугольником:

image::/drafts/aggregates/images/operation.svg[]

Ресурсы обозначаются красным овалом с обозначением и опциональным, но крайне желательным стереотипом с указанием способа их реализации:

image::/drafts/aggregates/images/resource.svg[]

Связь события с операцией обозначается чёрной стрелкой от события к операции:

image::/drafts/aggregates/images/event-operation.svg[]

Эффект считывания ресурса обозначается синей стрелкой от ресурса к операции:

image::/drafts/aggregates/images/operation-resource-ro.svg[]

На самой стрелке указываются считываемые данные.

Эффект модификации ресурса обозначается красной стрелкой от операции к ресурсу:

image::/drafts/aggregates/images/operation-resource-rw.svg[]

На самой стрелке указываются либо записываемые данные, либо команда отправляемая ресурсу.

Дополнительно на диаграмму можно помещать заметки и примечания, используя любую удобную нотацию.
Я предпочитаю нотацию UML - "лист" с загнутым углом, связанный прерывистой линией с комментируемым элементом.

image::/drafts/aggregates/images/note.svg[]

Давайте рассмотрим диаграмму эффектов реального проекта и процесс её построения.

== Диаграмм эффектов микросервиса "Геосервисы"

Этот пример, хорош тем, что в нём представлены множество разных видов событий и ресурсов.
На старте у меня было ТЗ, которое можно ужать до следующих пунктов:

. У заказчика есть проблема: ему необходимо держать информацию об его организациях в ряде геосервисов в актуальном состоянии
. Ключевым геосервисом являются Яндекс Карты, но дополнительно необходимо учитывать работу с 2Гис
. Интеграция с Яндекс Картами заключается в том, что робот Яндекса приходит на специально выделенный URL и забирает оттуда фид в https://yandex.ru/support/business-priority/branches/xml-feed-sprav.html#q1__6[проприетарном XML-формате]
. Интеграция с 2Гисом выполняется посредствам отправки фида на Email, но уже в другом формате
. Организаций у заказчика существенно больше тысячи, поэтому фид необходимо генерировать по настраиваемому таймеру, по умолчанию раз в сутки
. Яндекс требует, чтобы фид всегда был доступен по заданному урлу, поэтому необходимо обеспечить постоянное хранение последнего сгенерированного фида
. Список организаций необходимо получать из специального сервиса заказчика по REST API
. Кроме того необходимо получать дополнительную информацию об организациях из внутренней СУБД заказчика с помощью JDBC и SQL-запроса, предоставленного заказчиком
. Наконец, фид может содержать ссылки на фотографии организаций, и управление этими фотографиями должен обеспечить разрабатываемый сервис посредством REST API.
Конкретное хранилище изображений можно выбрать на своё усмотрение.

Теперь можно перейти сразу к посторению диаграммы эффектов, но я обычно в первом проходе составляю просто списки событий, операций и ресурсов, т.к. по мере вычитки ТЗ их состав наверняка будет меняться и уточняться.
Кроме того, при первой вычитке ТЗ я обычно строю первую верисию ER-диаграммы, но в данном случае модель данных примитивная я не буду усложнять пример её построением.

Поэтому давайте пройдёмся по "ТЗ" и сделаем на его основе три артефакта: список операций системы, список событий системы и список ресурсов.

Из пунктов №1 и 2 ясно, что потребуются интеграции с Яндексом и 2Гисом, но пока не понятно как их реализовывать.
Их можно внести в список ресурсов на текущем этапе, чтобы не забыть, или можно подождать прояснения интеграций, потому как это ключевые интеграции и их будет очень сложно забыть.
Кроме того, из этих пунктов мы можем предположить, что на потребуется ресурс *"Коллекция организаций"* - его так же можно загодя добавить в список ресурсов, или подождать пока наберётся больше данных.

Пункт №3 проясняет способ интеграции с Яндексом - теперь можно удалить соответствующий ресурс и заменить его на операцию *"Предоставить фид Яндекса"* и событие *"(Получен HTTP-запрос) GET /feed/yandex"* (на текущем этапе не стоит трать время на проектирование хорошего REST API - достаточно просто уникально обозначить события).
На текущем этапе кажется, что эта операция может быть обеспечена ресурсом *"Коллекция организаций"*, поэтому новых ресурсов добавлять не будем.

Пункт №4 проясняет интеграцию с 2Гис и показывает, что нам потребуется событие *"Настал момент отправки фида в 2Гис"* (пока не понятно что это за момент) и ресурс *"Email-сервер"* - вносим их в соответствующие списки.

Пункты №5-6 помогают на внести ряд уточнений:

. Появляется новое событие *"Истёк срок действия фида"*, которое инициирует операцию *"Сгенерировать обновлённый фид"*.
. Событие *"Настал момент отправки фида в 2Гис"* на самом деле является событием *"Сгенерирован обновлённый фид"* - обновляем его в списке событий
. Нам требуется где-то хранить фид для Яндекса между его генерацией и запросом - добавляем ресурс *"Фид Яндекса"*

Пункт №7 определяет тип ресурса *"Коллекция организаций"* - REST, уточняем его в списке.

Пункты №8 определяет ещё один ресурс операции *"Построить фид"* - *"JDBC: Дополнительная информация"*, добавляем его в список.

Пункт №10 определяет новый ресурс *"Фотографии"* и набор операций *"Добавить фото организации"*, *"Получить фото"*, *"Получить список фото организации"*, *"Удалить фото"*, с набором соответствующих событий об обращениях к HTTP эндпоинтам.

В итоге у нас получились следующие списки.


События:

. HTTP: GET /feed/yandex
. Event Bus: Сгенерирован новый фид
. Scheduler: Истёк срок действия фида
. HTTP: POST /images/{org_id}
. HTTP: GET /images/{org_id}/{image_id}
. HTTP: GET /images/{org_id}
. HTTP: DELETE /images/{org_id}/{image_id}

Операции:

. Предоставить фид Яндекса
. Построить фид
. Добавить фото организации
. Получить фото
. Получить список фото организации
. Удалить фото

Ресурсы:

. REST: Коллекция организаций
. Email-сервер
. ???: Фид Яндекса
. JDBC: дополнительная информация
. ???: Фотографии

Теперь построим первую версию диаграммы эффектов, просто перенося элементы и попутно отмечая связи между ними.
Как именно переносить сверху вниз, снизу вверх или в случайном порядке - не так важно.
Я предпочитаю идти по событиям, но для каждого события целиком раскрывать его реализацию.

Например, если начать с события *"GET /feed/yandex"*, то следом идут операция *"Предоставить фид Яндекса"* и ресурс *"Фид Яндекса"*, связанные через эффект чтения.
Но откуда информация возьмётся в ресурсе?
Вследствии реакции на событие *"Сгенерирован новый фид"*, которое вызывает незамеченную ранее операцию *"Обновить фид Яндекса"* - добавляем их на диаграмму.
Операции *"Обновить фид Яндекса"* помимо ресурса *"Фид Яндекса"* потребуется и ресурс *"Библиотека работы с XML"*, но диаграмма эффектов потому и так называется, что фокусируется на ресурсах с состоянием.
Поэтому ресурсы без состояния я добавляю только в том случае, если они являются единственным ресурсом операции или в чём-то не ординарны - стоят денег, непонятно какую библиотеку выбрать или с ними связаны какие-то другие риски.
И т.к. тут у нас вторичный и вполне ординарный ресурс, я его опускаю, чтобы сохранить фокус.

Далее у нас есть два пути - развернуть вторую операцию события *"Сгенерирован новый фид"* или понять откуда у нас будет браться новый фид.
И так как первый путь короче - сначала быстро пройдём его, а потом вернёмся к самой сложной части - добавляем на диаграмму операцию *"Отправить фид в 2Гис"* и ресурс *"Email-Server"*.
Добавив ресурс, мы задумаемся, а не слишком ли он специфицирован?


Теперь возвращаемся к вопросу откуда у нас берётся новый фид.
Он генерируется операцией *"Построить фид"* в ответ на событие *"Истёк срок действия фида"* - добавляем их на диаграмму.
Чтобы закрыть гештальт с событием *"Сгенерирован новый фид"* - добавим "забытый" ресурс *"Spring Application Publisher"*.
И здесь мы приходим к одному из непроработанных мест в диаграмме эффектов - мне хочется отразить связь операции-ресурса-события, но она, кажется, плохо укладывается в текущую концепцию диаграммы.
Тем не менее, на мой взгляд эта связь очень важна, поэтому отразим её серой стрелкой от ресурса *"Spring Application Event Publisher" к событию *"Сгенерирован новый фид"*.

Но для того чтобы отравить это событие, нам нужен собственно новый фид, а для его построения нужны ещё ресурсы - *"Организации"*, *"Дополнительная информация"* и *"Фотографии"* - добавляем их на диаграмму.
В этот момент я могу задуматься о том, как будет реализована операция *"Сгенерировать новый фид"* - я пробегусь по списку организаций, для каждой организации подтяну дополнительную информацию и фотографии.
Мне надо проверить что внешние ресурсы предоставляют мне нужное API, а при выборе способа реализации ресурса *"Фотографии"*, который меня пока под вопросом, убедиться, что он обеспечит возможность хранения привязки файлов фотографий к организациям.

Эту ветку мы прошли до конца - можем вернуться к спискам, вычеркнуть то, что уже перенесли на диаграмму и обнаружить, что у нас остались только события и операции API управления фотографиями - переносим их на диаграмму и немного полируем раскаладку

На диаграмме осталась пара вопросов - как реализовать ресурсы хранения фида Яндекса и фотографий.
Сами фотографии явно лучше хранить в хранилище BLOB-ов вроде Amazon S3.
Там же можно хранить и фид Яндекса - у этого ресурса тривиальное АПИ сохранения и получения файла по ключу.
С фотографиями же сложнее - там помимо операций по ключу есть и поиск по организации.
Теоретически это можно реализовать посредствам бакетов или "папок" S3, но но мой вкус решение уже начинает дурно пахнуть.
А чуть позже, когда мы внимательнее изучим формат фида Яндекса, мы увидим что у фотографий есть мета информация в виде типа и тэгов - хранить в S3 это будет уже совсем плохой идеей.
Значит нам нужна более продвинутая СУБД, у меня по умолчанию - PostgreSQL.
Но хранить в PostgreSQL сотни гигабайт - тоже сомнительная затея.
Значит ресурс *"Фотографии"* будет состоять из двух - *"Содержимое"* и *"Мета информация"*.
Но модификации этих ресурсов по хорошему должны быть атомарными, поэтому я не буду разделять ресурс, а добавлю на диаграмму примечание.
Что в итоге даст нам финальный вариант диаграммы эффектов микросервиса "Геосервисы" (картинка кликабельна):

image::/drafts/aggregates/images/geoservices-effects-diagram.drawio.svg[link=/drafts/aggregates/images/geoservices-effects-diagram.drawio.svg]

== Заключение

При первичном анализе и проектировании проекта, построение диаграммы эффектов и тщательная медитация над ней даёт много полезной информации - общее видение реализации системы, масштаб планируемых работ и их трудоёмкость, примерный план работ.

Построение диаграммы эффектов так же является полезным упражнением и при планировании модификации сложной или незнакомой системы - диаграмма поможет понять назначение модифицируемого кода и какой другой код может быть сломан в результате модификаций.

Однако самым крутым применением диаграммы эффектов является объектно-ориентированная декомпозиция системы на модули на её базе.
Разбор декомпозиции микросервиса "Геосервисы" на модули приведён в следующем посте.
