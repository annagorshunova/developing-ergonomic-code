---
title: "Диаграмма Эффектов v0.0.1"
description: "Душой информационной системы являются её эффекты. Именно на основании эффектов конечные пользователи выносят суждения о корректности работы системы. И при столь большой важности эффектов, в мире не существовало инструмента для визуализации и проектирования эффектов. Поэтому я придумал свой - диаграмму эффектов"
date: 2022-04-01T08:25:37+07:00
draft: false
---
:source-highlighter: roug
:rouge-theme: github
:icons: font
:sectlinks:

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

[NOTE]
====
Этот пост является первой попыткой описать диаграмму формально, поэтому в описании возможны неточности и пробелы, а детали и нотация наверняка изменятся в будущем.
====


== Введение

Эффекты, на ряду с моделью информации, являются душой информационной системы - что-то сохранить в БД, что-то запросить из внешнего сервиса, что-то запросить из нескольких источников, объединить это и записать куда-то, в общем как-то по взаимодействовать с окружающим миром.

Можно переписать приложение с Java на Haskel, сменить слои на шестиугольную архитектуру, реляционную базу данных заменить документной, а пользовательский интерфейс перевести с Web 1.0-ого на React Native - если эффекты системы останутся неизменными, то и новая система будет просто вариацией на тему условной библиотеки.
Если же существенно изменить эффекты системы, то это будет уже другая система.

Наконец, именно на основании эффектов конечные пользователи выносят суждения о корректности работы системы.
Даже если функция системы включает в себя сложные вычисления, корректность их результата конечный пользователь сможет оценить только если корректно отработал эффект отображения результата - воздействие на органы чувств пользователя, в конечном итоге.

При всей значимости эффектов я не знаю ни одного общепринятого инструмента их визуализации.
Поэтому изобрёл свой - диаграмму эффектов.

== Терминология

Системы очень редко выполняют *эффекты* сплошным потоком - обычно система выполняет набор эффектов в ответ на какое-то *событие* и засыпает до следующего события.
Таким событием может быть получение вызова удалённой процедуры в любом виде, появление нового сообщения в некоторой очереди, наступление определённого момента времени или истечение определённого периода времени.

Как правило, для реализации функции системы требуется несколько эффектов, как минимум что-то считать и потом записать обратно.
Группы эффектов реализующих одну функцию системы образуют *операции* системы.
Система может реагировать как несколькими операциями, в ответ на одно событие, так и одной операцией в ответ на несколько событий (разных типов).

Наконец, у эффектов есть целевое состояние - какая-то часть физического мира, которая изменит своё состояние или наоборот состояние которой будет оцифровано и предоставлено программе результате выполнения эффекта.
Чаще всего целевым состоянием выступают биты на носителях информации, но это могут быть и пиксели экрана, и динамик колонки и нога робота.
Эти кусочки физического мира представленны их абстракциями в системе - *ресурсами*.

Чёткое понимание триады События-Эффекты-Ресурсы - в ответ на какие события, какими эффектами на какие ресурсы система должна реагировать - крайне полезно на всех этапах жизненного цикла разработки системы.

На этапе оценки триада помогает осознать количество функций системы и примерную трудоёмкость реализации каждой из них.

На этапе проектирования операции и ресурсы становятся основными блоками, правильная декомпозиция которых создаст основу для системы с низкой сцепленностью.

На этапе реализации зависимости операций через ресурсы и их оценочная сложность (определяемая количеством и типом обеспечивающих её ресурсов) помогают определить порядок выполнения работ и те работы, которые могут быть выполнены параллельно.

Наконец, на этапе поддержки сцепленность операций через ресурсы помогают спрогнозировать последствия планируемого изменения и предотвратить внесение регрессий.

Визуализация триады События-Эффекты-Ресурсы является основным предназначением диаграммы эффектов.

== Диаграмма эффектов v0.0.1

Диаграмма эффектов помогает увидеть целостную картину поведения системы - как и на какие события она реагирует.
Для этого она представляет систему с точки зрения операций (ответственностей, поведения) системы.
Каждая операция характеризуется набором событий, приводящей к её исполнению и набором ресурсов, необходимых для её исполнения.
События и операции связаны вызовами (не важно, синхронными или асинхронными).
Операции и ресурсы связаны обращениями на чтение и запись - эффектами.

Все элементы транслируются непосредственно в код: события и операции - в методы, ресурсы - в классы, стрелки - в вызовы методов.
Операции всегда транслируются в методы классов слоя сервисов приложения - методы определяющие публичный интерфейс модуля.
При том при реализации этих методов следует стремиться к тому, чтобы все вызовы соответствующие эффектам оказались в самих методах, а не погребённых где-то в недрах реализации.
Перевод диаграммы эффектов в код я рассмотрю в одном из ближайших постов.

Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются:

. Получение запроса по сети.
  Сейчас популярностью пользуется протокол запросов в REST-стиле, но SOAP, gRPC, CORBA и т.п. так же попадают в эту категорию.
. Появление сообщения в очереди.
  Это может быть как и "вне-процессная" очередь, вроде ActiveMQ, так и "внутри-процессная" очередь вроде Spring Application Event Publisher.
. Наступление определённого момента времени.
  Два основных типа таких событий - наступление заранее известного момента времени (например, полуночи вторника) и истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).

В коде события превращаются в метод, передаваемый фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера и т.д.

В контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются такие:

. Любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.
. REST API внешних сервисов
. Любые очереди сообщений/шины данных
. Глобальные изменяемые структуры данных

В коде ресурсы превращаются в структуру данных и коллекцию методов работы с ней - Spring Data JDBC агрегат и Spring Data JDBC репозиторий, событие и Spring Application Publisher, REST API модель и клиент и т.п.

== Нотация

[NOTE]
====
Нотация - это то, что я точно существенно перетрясу с помощью специально обученных людей перед релизом версии 1.0.
====

"Визуальный язык" диаграммы эффектов я взял из https://c4model.com/[модели C4].
Во-первых мне нравится сам язык, а во-вторых, диаграмму эффектов можно встроить в модель C4, на четвёртом уровне - вместо кода.
Кроме того, диаграмму третьего уровня (компонентов) я строю как раз базе диаграммы эффектов.

Диаграмма эффектов бывает двух типов - краткая и полная.
Краткая содержит только обозначение эффектов и связанных ими операций и ресурсов.
Полная нотация дополнительно включает события и их источники, внешние системы, обеспечивающие реализацию ресурсов и более полное описание всех элементов.

Рассмотрим нотации с помощью минимального примера визуализации функциональности регистрации и аутентификации пользователей в произвольной системе.
После успешной регистрации пользователям необходимо отправлять приветственное письмо.
Начнём с краткой нотации.

=== Краткая нотация

В краткой нотации диаграмма выглядит следующим образом (картинка кликабельна):

image::/drafts/aggregates/images/short-notation-example.svg[link=/drafts/aggregates/images/short-notation-example.svg]

Теперь рассмотрим отдельные элементы

==== Операции

Операции обозначаются светло-голубым прямоугольником с именем операции:

image::/drafts/aggregates/images/operation.svg[]

==== Ресурсы

Ресурсы обозначаются голубым прямоугольником с именем ресурса:

==== Эффекты

image::/drafts/aggregates/images/resource.svg[]

Эффект модификации ресурса обозначается жирной красной стрелкой от операции к ресурсу, с кратким описанием эффекта:

image::/drafts/aggregates/images/operation-resource-rw.svg[]

Эффект чтения ресурса обозначается синей стрелкой от ресурса к операции, с кратким описанием считываемых данных:

image::/drafts/aggregates/images/operation-resource-ro.svg[]

==== Эффекты вызова операций

В краткой нотации так же есть специальный вид стрелок для отражения того факта, что взаимодействие с ресурсом может повлечь выполнение операции.
Как правило, это ресурсы всевозможных шин событий и связанные с ними операции-обработчики.
Такие связи отображаются красной прерывистой линией с кратким описанием связи:

image::/drafts/aggregates/images/resource-operation-rw.svg[]

==== Примечания

Дополнительно на диаграмму можно помещать заметки и примечания, используя любую удобную нотацию.
Я предпочитаю нотацию UML - "лист" с загнутым углом, связанный прерывистой линией с комментируемым элементом.

image::/drafts/aggregates/images/note.svg[]

На этом элементы входящие в краткую нотацию заканчиваются.

=== Полная нотация

Теперь рассмотрим ту же функциональность, описанную в полной нотации:

image::/drafts/aggregates/images/full-notation-example.svg[link=/drafts/aggregates/images/full-notation-example.svg]

В полной нотации появляются:

. события
. описание операций и ресурсов в формате модели C4
. границы контейнера из C4.
  Обозначает границы процесса - всё что находится внутри этих границ должно выполняться в памяти визуализируемого приложения.
. внешние системы, базы данных и компоненты из C4.
  Внешние системы могут быть как источником события, так и средством реализации ресурса.

Расширять состав элементов можно постепенно, добавляя только те элементы, что помогают в решении текущей задачи.

==== События

На мой взгляд, из дополнительных элементов наибольшую ценность имеют события.
В полной нотации они обозначаются стрелкой от внешней системы к операции с кругом на стартовом конце и описанием в формате C4.
Но в промежуточной версии, внешнюю систему можно опустить и "подвесить" стрелку:

image::/drafts/aggregates/images/event-operation.svg[]

==== Описания

Затем можно дополнить операции и ресурсы - типом, способом реализации  и описанием:

image::/drafts/aggregates/images/descriptions.svg[]

==== Внешние системы

Границы системы и внешние системы полностью соответствуют нотации C4:

. Границы отображаются серым прямоугольником с прерывистой границей и подписью с именем контейнера
. Неуправляемые внешние системы и компоненты и базы данных обозначаются серыми прямоугольниками и символом "База Данных" соответственно
. Управляемые внешние системы и базы данных обозначаются голубым прямоугольником и символом "База Данных"

Внешние системы связываются с операциями посредством событий:

image::/drafts/aggregates/images/event-sources.svg[]

А ресурсы связываются со внешними системам по средствам стрелок с описанием:

image::/drafts/aggregates/images/resource-impls.svg[]

Ресурс может быть связан со сторонним компонентом, работающем в том же процессе:

image::/drafts/aggregates/images/resource-component.svg[]

Здесь приведена, связь ресурса с эффектом вызова операции системы, в случае же если ресурс не обладает таким эффектом, то соединяются со сторонним компонентом обычной стрелкой.

Выбор нотации зависит от решаемой задачи.
Если надо быстро разбить систему на модули, или спланировать модификацию сложной или незнакомой операции - можно обойтись краткой нотацией.
Если надо оценить проект для работы за фиксированную цену - лучше взять полную нотацию, чтобы минимизировать вероятность "потери" существенных деталей.

Одним из плюсов базирования на визуальном языке модели C4 является то, что для диаграммы эффектов можно использовать любой инструмент с поддержкой C4.
А в силу простоты C4 таким элементом может быть хоть графический редактор.
Тем не менее, поддержка привязки элементов сильно помогает, поэтому я сам сейчас использую https://www.diagrams.net/[десктопную версию draw.io].

Давайте рассмотрим диаграмму эффектов реального проекта и процесс её построения.

== Диаграмма эффектов системы актуализации данных в Яндекс.Картах и 2Гис (True Story Project, TSP)

Я сейчас заканчиваю небольшой проект по автоматизации обновления информации о компании в Яндекс.Картах 2Гис.
Это идеальный проект для иллюстрации диаграммы эффектов - он небольшой, но включает все основные типы событий и ресурсов:

image::/drafts/aggregates/images/true-story-effects.svg[link=/drafts/aggregates/images/true-story-effects.svg]

Все новые коммерческие проекты я начинаю с диаграммы эффектов по целому ряду причин.

На этапе оценки диаграмма эффектов помогает определить основные блоки реализации, убедиться, что ничего не забыто и понятно как реализовать каждую из операций системы.
А формула `(<кол-во операций>+<кол-во ресурсов>) * 12 часов` даёт хорошее первое приближение трудоёмкости работы.

Затем я использую диаграмму эффектов для разбиения системы на модули.
Полученные модули и явные и, что важнее, неявные связи между ними я использую для определения порядка выполнения работ и работ, которые могут выполняться параллельно.

Итак, поехали.
На старте у меня было ТЗ, которое можно ужать до следующих пунктов:

. У заказчика есть проблема: ему необходимо держать информацию об его организациях в ряде геосервисов в актуальном состоянии
. Ключевым геосервисом являются Яндекс Карты, но дополнительно необходимо учитывать работу с 2Гис
. Интеграция с Яндекс Картами заключается в том, что робот Яндекса приходит на специально выделенный URL и забирает оттуда фид в https://yandex.ru/support/business-priority/branches/xml-feed-sprav.html#q1__6[проприетарном XML-формате]
. Интеграция с 2Гисом выполняется посредствам отправки фида на Email, но уже в другом формате
. Организаций у заказчика существенно больше тысячи, поэтому фид необходимо регулярно обновлять
. Яндекс требует, чтобы фид всегда был доступен по заданному URL, поэтому необходимо обеспечить постоянное хранение последнего сгенерированного фида
. Список организаций необходимо получать из специального сервиса заказчика по REST API
. Ещё часть данных хранится во внутренней СУБД заказчика и извлекается с помощью JDBC и SQL-запроса, предоставленного заказчиком
. Наконец, фид может содержать ссылки на фотографии организаций, и управление этими фотографиями должен обеспечить разрабатываемый сервис.
Доступ к этой функциональности должен быть обеспечен посредством REST API.
Конкретное хранилище изображений можно выбрать на своё усмотрение.

Работу можно начать сразу с построения диаграммы эффектов, но я обычно в первом проходе составляю просто списки событий, операций и ресурсов, т.к. по мере вычитки ТЗ их состав наверняка будет меняться и уточняться.
Кроме того, при первой вычитке ТЗ я обычно строю первую версию ER-диаграммы, но в данном случае модель данных примитивная я не буду усложнять пример её построением.

Поэтому давайте пройдёмся по "ТЗ" и сделаем на его основе три артефакта: список операций системы, список событий системы и список ресурсов.

Из пунктов №1 и 2 ясно, что потребуются интеграции с Яндексом и 2Гисом, но пока не понятно как их реализовывать.
Кроме того, из этих пунктов мы можем предположить, что нам потребуется ресурс *"Коллекция организаций"* (Organizations) - его  можно загодя добавить в список ресурсов.

[NOTE]
====
Так как все элементы диаграммы эффектов в последствии превратятся в код, а в коде имена пишутся на английском, на диаграмме я использую английский язык.
Кроме того, в среднем длина английской фразы меньше длины русского аналога, что является приятным бонусом для диаграммы.
Но чтобы не возводить лишний барьер, в посте я буду использовать русские имена, а при их первом появлении - указывать английский аналог.
====

Пункт №3 проясняет способ интеграции с Яндексом - теперь можно удалить соответствующий ресурс и заменить его на операцию *"Предоставить фид Яндекса"* (getYandexFeed) и событие *"(Получен HTTP-запрос) GET /feed/yandex"* (сейчас нет смысла тратить время на проектирование хорошего REST API - достаточно просто уникально обозначить события).
На текущем этапе кажется, что эта операция может быть обеспечена ресурсом *"Коллекция организаций"*, поэтому новых ресурсов добавлять не будем.

Пункт №4 проясняет интеграцию с 2Гис и показывает, что нам потребуется событие *"Настал момент отправки фида в 2Гис"* (пока не понятно что это за момент) и ресурс *"Email сервер"* (Email Server) - вносим их в соответствующие списки.

Пункты №5-6 помогают нам внести ряд уточнений:

. Появляется новое событие *"Истёк срок действия фида"* (FeedExpired), которое инициирует операцию *"Сгенерировать обновлённый фид"* (rebuildFeed).
. Событие *"Настал момент отправки фида в 2Гис"* на самом деле является событием *"Сгенерирован обновлённый фид"* (NewFeedGenerated) - обновляем его в списке событий
. Нам требуется где-то хранить фид для Яндекса между его генерацией и запросом - добавляем ресурс *"Фид Яндекса"* (Yandex Feed)

[NOTE]
====
В этом примере у меня случайно получился удачный порядок требований, который естественным образом привёл меня к расцепке операции генерации фида и его доставки геосервисам через событие.
Однако могло получиться и по другому.
Могло бы получиться так, что операция rebuildFeed оказалась связанной эффектами записи уже с двумя ресурсами сильно разными - YandexFeed и Email Server.

Это стало бы нарушением принципа единственности ответственности и благодаря диаграмме эффектов это нарушение сразу стало бы очевидным.

Вообще у меня есть эвристическое правило, что операция должна иметь один модифицирующий эффект и все операции с двумя и более такими эффектами я всегда подвергаю тщательному анализу.

А если бы на текущем этапе я не заметил бы ни нарушения SRP, ни собственного эвристического правила, то диаграмма эффектов привела бы меня сюда снова на этапе декомпозиции системы на модули.
Но об этом я напишу во врезке соответствующего поста.
====

Пункт №7 уточняет способ реализации ресурса *"Коллекция организаций"* - REST, уточняем его в списке.

Пункт №8 определяет ещё один ресурс операции *"Построить фид"* - *"JDBC: Дополнительная информация"* (Additional Information), добавляем его в список.

Наконец, пункт №9 определяет новый ресурс *"Фотографии"* (Photos) и набор операций *"Добавить фото организации"*, *"Получить фото организации"*, *"Получить список фото организации"*, *"Удалить фото организации"*, с набором соответствующих событий об обращениях к HTTP эндпоинтам.

В итоге у нас получились следующие списки.

События:

. HTTP: GET /feed/yandex
. Event Bus: Сгенерирован новый фид
. Scheduler: Истёк срок действия фида
. HTTP: POST /images/{org_id}
. HTTP: GET /images/{org_id}/{image_id}
. HTTP: GET /images/{org_id}
. HTTP: DELETE /images/{org_id}/{image_id}

Операции:

. Предоставить фид Яндекса
. Построить фид
. Добавить фото организации
. Получить фото
. Получить список фото организации
. Удалить фото

Ресурсы:

. REST: Коллекция организаций
. Email-сервер
. ???: Фид Яндекса
. JDBC: дополнительная информация
. ???: Фотографии

Теперь построим первую версию диаграммы эффектов, просто перенося элементы и попутно отмечая связи между ними.
Как именно переносить - сверху вниз, снизу вверх или в случайном порядке - не так важно.
Я предпочитаю идти по событиям, но для каждого события целиком раскрывать его реализацию.

Например, если начать с события *"GET /feed/yandex"*, то следом идут операция *"Предоставить фид Яндекса"* и ресурс *"Фид Яндекса"*, связанные через эффект чтения - добавляем на диаграмму.
Но откуда информация возьмётся в ресурсе?
Вследствии реакции на событие *"Сгенерирован новый фид"*, которое вызывает незамеченную ранее операцию *"Обновить фид Яндекса"* - добавляем их на диаграмму.

Операции *"Обновить фид Яндекса"* помимо ресурса *"Фид Яндекса"* потребуется и ресурс *"Библиотека работы с XML"*, но диаграмма эффектов потому и так называется, что фокусируется на ресурсах с состоянием.
Поэтому ресурсы без состояния я добавляю только в том случае, если они являются единственным ресурсом операции или в чём-то неординарны - стоят денег, непонятно какую библиотеку выбрать или с ними связаны какие-то другие риски.
И т.к. тут у нас вторичный и вполне ординарный ресурс, я его опускаю, чтобы сохранить фокус.

Далее у нас есть два пути - развернуть вторую операцию события *"Сгенерирован новый фид"* (отправку в 2Гис) или понять откуда у нас будет браться новый фид.
И так как первый путь короче - сначала быстро пройдём его, а потом вернёмся к самой сложной части - добавляем на диаграмму операцию *"Отправить фид в 2Гис"* и ресурс *"Email-Server"*.
Добавив ресурс, мы задумаемся, а не слишком ли он специфицирован?
Кажется да, поэтому Email-Server делаем стереотипом способа реализации, а саму операцию обозначаем как *"Механизм отправки фида в 2Гис"*.

Теперь возвращаемся к вопросу откуда у нас берётся новый фид.
Он генерируется операцией *"Построить фид"* в ответ на событие *"Истёк срок действия фида"* - добавляем их на диаграмму.
Но событие *"Сгенерирован новый фид"* является внутренним - мы сами должны позаботиться о его отправке.
И для этого нам нужен ресурс.
На текущем этапе кажется, что стандартного Spring Application Event Publisher будет вполне достаточно для решения этой задачи - добавим ресурс *"\<<Spring Application Event Publisher>>: Топик сгенерирован новый фид"*.

Здесь мы подходим к одному из не до конца проработанных мест в диаграмме эффектов - мне хочется отразить тот факт, что событие *"Сгенерирован новый фид"* публикуется операцией *"Сгенерировать новый фид"*, но у меня нет ощущения, что эта связь хорошо ложится на текущую концепцию диаграммы.
Тем не менее, на мой взгляд эта связь очень важна, поэтому отразим её серой стрелкой от ресурса *"Топик сгенерирован новый фид"* к событию *"Сгенерирован новый фид"*.

Для того чтобы породить событие *"Сгенерирован новый фид"*, нам нам надо этот самый новый фид сгенерировать, а для его генерации нужны ресурсы - *"Организации"*, *"Дополнительная информация"* и *"Фотографии"* - добавляем их на диаграмму.

В этот момент я могу задуматься о том, как будет реализована операция *"Сгенерировать новый фид"* - я пробегусь по списку организаций, для каждой организации подтяну дополнительную информацию и фотографии - все необходимые ресурсы есть.

Кроме того, мне надо будет проверить что внешние ресурсы предоставляют мне нужное API.
А при выборе способа реализации ресурса *"Фотографии"*, который меня пока под вопросом, мне надо будет убедиться, что выбранный способ обеспечит возможность хранения привязки файлов фотографий к организациям.
Но я это пока просто помечу в заметках по проекту и продолжу строить диаграмму эффектов.

Текущую ветку мы прошли до конца - можем вернуться к спискам, вычеркнуть то, что уже перенесли на диаграмму и обнаружить, что у нас остались только события и операции API управления фотографиями - переносим их на диаграмму и немного полируем раскаладку.

На диаграмме осталась пара вопросов - как реализовать ресурсы *"фид Яндекса"* и *"Коллекция фотографий"*.
Сами фотографии явно лучше хранить в хранилище BLOB-ов вроде Amazon S3.
Там же можно хранить и фид Яндекса - у этого ресурса тривиальное API сохранения и получения файла по ключу.

Но при ближайшем рассмотрении, выясняется, что с фотографиями есть нюанс - помимо операций по ключу есть и поиск по организации.
Теоретически это можно реализовать посредствам бакетов или "папок" S3, но на мой вкус это решение уже начинает дурно пахнуть.
А чуть позже, когда мы внимательнее изучим формат фида Яндекса, мы увидим что у фотографий есть ещё и мета информация в виде типа и тэгов - хранить в S3 это будет уже совсем плохой идеей.
Значит нам нужна более продвинутая СУБД, у меня по умолчанию - PostgreSQL.

Но хранить в PostgreSQL сотни гигабайт - тоже сомнительная затея.
Значит реализацию ресурса *"Коллекция фотографий"* будет состоять из двух частей - *"Коллекция файлов"* и *"Коллекция мета информации"*.
Модификации этих ресурсов должны быть атомарными, поэтому на диаграмме я не буду разделять ресурс, а добавлю примечание.

В итоге мы получаем финальный вариант диаграммы эффектов микросервиса "Геосервисы" (картинка кликабельна):

image::/drafts/aggregates/images/geoservices-effects-diagram.drawio.svg[link=/drafts/aggregates/images/geoservices-effects-diagram.drawio.svg]

== Заключение

При первичном анализе и проектировании проекта, построение диаграммы эффектов и тщательная медитация над ней даёт много полезной информации - общее видение реализации системы, масштаб планируемых работ и их трудоёмкость, примерный план работ.

Построение диаграммы эффектов так же является полезным упражнением и при планировании модификации сложной или незнакомой системы - диаграмма поможет понять назначение модифицируемого кода и какой другой код может быть сломан в результате модификаций.

Однако самым крутым применением диаграммы эффектов является объектно-ориентированная декомпозиция системы на модули на её базе.
Разбор декомпозиции микросервиса "Геосервисы" на модули приведён в следующем посте.
