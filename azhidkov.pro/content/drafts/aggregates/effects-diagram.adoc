---
title: "Диаграмма Эффектов v0.0.1"
date: 2022-02-12T13:25:37+07:00
draft: false
---
:source-highlighter: roug
:rouge-theme: github
:icons: font

== Введение

Сейчас самым распространённым способом декомпозиции ПО является декомпозиция по техническим аспектам - сервисы, сущности, исключения и т.п.
И хотя огромное количество авторов - начиная с Константина и Парнаса в 70-ых, продолжая Эвансом и Мартином в 00-ых и заканчивая большим количеством менее известных инженеров сейчас - критикует такой способ декомпозиции, никто из них не даёт практической методики выполнения альтернативной декомпозиции.
Поэтому для себя и своих команд я разработал методику, заполняющую этот пробел - методику декомпозиции систем на базе эффектов.
В основе этой методики лежит диаграмма эффектов.

== Диаграмма эффектов v0.0.1

[NOTE]
====
Пока что я придерживаюсь мнения, что диаграмма эффектов - это моё ноухау.
Я знаю как минимум один очень похожий подход, описанный в https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition[Improving Design Decomposition] и https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution[Functional Decomposition for Software Architecture Evolution], но этот пост является первой попыткой описать мою версию диаграммы более-менее формально.
Поэтому в описании возможны неточности и пробелы, а детали могут меняться в будущем.
====

Диаграмма эффектов помогает рассмотреть систему с точки зрения операций (ответсвенностей, поведения) системы.
Каждая операция характеризуется набором событий, приводящей к её исполнению и набором ресурсов, необходимых для её исполнения.
События и операции связаны вызовами (не важно, синхронными или асинхронными).
Операции и ресурсы связаны обращениями на чтение и запись.
При желании, вызовы так же можно разделить на команды и запросы.
Если операция содержит хоть одно обращение на запись, то все её вызовы являются командами, в противном случае - запросами.
Вот собственно и вся нотация - три вида блоков, связанных тремя-четырьмя (#todo: четырьмя?#) видами стрелок.

В v0.0.1, операция - это всегда метод в слое сервисов приложения.
А вот события и ресурсы бывают разные.

Если говорить о бакэндах информационных систем, то самыми распространёнными видами событий являются следующие:

. Получение HTTP-запроса.
  Это может быть как чистый HTTP-запрос, так и запрос по более высоко-уровневому протоколу вроде SOAP.
. Получение сообщения по очереди событий.
  Это может быть как и "внепроцессная" очередь, вроде ActiveMQ, так и "внутрипроцессная" очередь вроде Spring Application Event Publisher.
. Наступление определённого момента времени.
  Такие события так же бывают двух типов - наступление заранее известного момента времени (например, полуночи вторника) и истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).

В конечном итоге, источники событий исходят из прерываний процессора, поэтому в более широком контексте событиями является всё, что приводит к порождению прерывания: нажатие кнопки мыши, получение пакета по сети, завершение операции чтения с диска и т.п.

В коде же события превращаются в метод, передаваемый фреймворку для последующего вызова - метод Spring-ового RestController-а, Swing-овый EventListener, реализация Runnable для таймера.

Опять же в контексте бэкэндов информационных систем, самыми распространёнными видами ресурсов являются следующие:

. Любые постоянные коллекции данных - таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.
  Реляционные (и любые нормализованные) базы данных дают довольно низкоуровневую картину, с которой не очень удобно работать, поэтому в качестве базовых блоков подобных ресурсов я предпочитаю использовать ДДД Агрегаты
. РЕСТ АПИ внешних сервисов
. Любые очереди сообщений/шины данных
. Коллекции файлов на диске
. Глобальные изменяемые структуры данных

Иногда (в контексте информационных систем) встречается обособленный вид ресурсов - сложный алгоритм, представленный чистой функцией.
От остальных ресурсов он отличается отсутствием состояния.

В коде ресурсы превращаются в структуру данных и коллекцию методов работы с ней - Spring Data JDBC агрегат сущность и Spring Data JDBC репозиторий, событие и Spring Application publisher, REST API модель и клиент и т.п.

== Примеры

Диаграмма эффектов микросервиса генерации фида с информацией об организации для яндекс карт и два гиса (картинка кликабельна):

image::/drafts/aggregates/images/effects-diagram-example-1.svg[link=/drafts/aggregates/images/effects-diagram-example-1.svg]

== Алгоритм построения

== Применение

Я разработал и сейчас применяю диаграмму эффектов как основной инструмент декомпозиции системы на модули.
На первом этапе я переношу сущности ER-диаграммы на диаграмму эффектов в качестве ресурсов.
Затем информацию о том, какие сущности модифицируются какими операциями я использую как один из параметров процесса проектирования агрегатов - сущности которые всегда модифицируются вместе являются кандидатом на агрегат, операции, которые меняют сущности входящие в разные агрегаты являются кандидатом на перепроектирование.

Получив диаграмму эффектов с агрегатами в качестве ресурсов, я строю декомпозицию системы на модули таким образом, чтобы:

. Операции, изменяющие ресурс и сам ресурс были в одном модуле
. Операции обращались только к ресурсам из того же модуля

100%-ое достижение этих свойств редко возможно, поэтому я допускаю их нарушение, если это делает дизайн более "разумным" на мой субъективный взгляд.

== Заключение
