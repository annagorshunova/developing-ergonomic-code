---
title: "SOLID: SRP, моя версия"
date: 2021-05-21T13:25:37+07:00
draft: true
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:toc:

== SOLID

(#todo: выкосить столото#)
[sidebar]
****
Формулировки принципов SOLID:

. [big]##**S**##ingle Responsibility Principle: A module should have one, and only one, reason to change.
. [big]##**O**##pen/Closed Principle:: A software artifact should be open for extension but closed for modification.
. [big]##**L**##iskov Substitution Principle:: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T
. [big]##**I**##nterface Segregation Principle:: Clients should not be forced to depend upon interfaces that they do not use.
. [big]##**D**##ependency Inversion Principle::
A. High level modules should not depend upon low level modules. both should depend upon abstractions.
+
B. Abstractions should not depend upon details. details should depend upon abstractions.
****

SOLID - это единственные принципы дизайна, дать определение которым могут 90% разработчиков.
Однако вокруг них много мифов и карго культа, а о части важных вещей Мартин просто слукавил или умолчал.

Этим постом я открываю серию публикаций о SOLID.
Серию в которой я [line-through]#святее Папы# расскажу про SOLID то, чего рассказал сам Мартин.

И первый секрет заключается в том, что не все принципы SOLID одинаково полезны:

. SRP является самым важным, но и самым сложным для применения.
  SRP имеет наибольшее значение для качества дизайна систем, но именно этот принцип нарушается чаще других;
. DIP, автоматически влекущий за собой OCP, так же очень важен, но прост в применении;
. OCP в контексте разработки прикладных программ, несёт преимущественно утилитарную функцию и только в редких случаях его стоит учитывать при дизайне всей системы;
. LSP в контексте разработки прикладных программ, имеет очень низкую актуальность и практически не влияет на дизайн;
. ISP актуален только при разработке *очень* больших систем или работе с языками с долгой компиляцией вроде C++ или Scala.

Серию я разобью на три части:

. SRP - требует наибольшего количества пояснений, поэтому в одиночку занимает весь объём, разумный для поста;
. DIP и OCP - неразрывно связаны друг и имеют архитектурное значение, поэтому я рассмотрю их вместе и во вторую очередь;
. LSP и ICP - я рассмотрю в последнюю очередь, т.к. они имеют наименьшие актуальность и влияние на дизайн.

Но прежде чем перейти собственно к SRP я дам определения нескольких терминов, которые мне потребуются.

== Терминология

Опубликованный интерфейс (Published interface):: интерфейс класса, который используется за пределами кодовой базы, в которой он определён.

Термин введён Мартином Фаулером в книге Refactoring.
Разница между опубликованным интерфейсом и приватной реализации намного больше, чем между публичными и приватными полями и методами.
Этому есть две причины:

. опубликованный интерфейс необходимо делать максимально гибким, чтобы он подходил максимальному количеству клиентов;
. в опубликованный интерфейс можно вносить только обратно-совместимые изменения, поэтому ошибки допущенные в нём остаются на всю жизнь интерфейса.

Из этого следует, что разработка опубликованного интерфейса требует намного больших усилий (существует эвристика, что в три раза больше), чем приватного кода.
Поэтому при разработке кода надо понимать является ли он частью опубликованного интерфейса.

Если вы сэкономите на опубликованном интерфейсе, то обречёте себя на жизнь полную неудобств и ограничений из-за ошибок в интерфейсе.
И есть риск сэкономленные ресурсы потратить в пустую, если вы не обеспечите нужную гибкость своему интерфейсу и  внешние клиенты не смогут им пользоваться.

Если же вы будете писать приватный код, стольже тащательно, как и опубликованный, то эти вложения врят ли когда-нибудь окупятся.

Связность (Cohesion):: степень связанности внутренних элементов модуля

Связанность (Coupling):: степень связанности модулей системы

image::/posts/21/05/images/cohesion-and-coupling.png[]

Связанность - это важное свойство системы.
Без связанности модули - это россыпь независимых компонент, и имено связанность собирает их в систему.
Но чрезмерная связанность модулей системы превращает её в Big Ball of Mud, что усложняет понимание и развитие системы.
В результате разработчик не в состоянии уместить в голове последствия тех или иных изменений, что в свою очередь ведёт к большому количеству неожиданных регрессий.

== Проект Л

Примеры для этого поста я так же взял из своего последнего link:++{{<ref "posts/21/03/210321-project-l-testing#_проект_л" >}}++[Проекта Л].

Плюс с тех пор в проекте появилась новая фича существенная для этого - аппрув пользователей.
Теперь существующий пользователь базовой системы может залогиниться в Проекте Л, только после того как оставит запрос на доступ, который должен быть одобрен.

Наконец, мы можем перейти непосредственно к SRP.

== SRP

SRP это самый актуальный и универсальный принцип, и именно следование SRP спасает системы от превращения в Big Ball of Mud.
Но в то же время SRP является самым неоднозначным и расплывчатым принципом, которому непонятно как следовать.

=== Формулировки

Сам Мартин формулирует его тремя разными способами:

[quote, Robert C. Martinn, Clean Code]
____
The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change
____

[quote, Robert C. Martinn, The Single Responsibility Principle]
____
Gather together the things that change for the same reasons.
Separate those things that change for different reasons.
____

[quote, Robert C. Martinn, Clean Architecture]
____
A module should be responsible to one, and only one, actor
____

Плюс есть ещё одна очень распространённая в народе формулировка:
[quote, народ]
____
Класс должен делать одну вещь
____

У всех этих формулировок одна общая проблема: любой нетривиальный кусочек кода, имеет более одной причины для изменения, эктора перед которым он отвечает и вещей, которые он делает.
Совсем не факт, что два разработчика, выберут одни и те же причины для изменений, в качестве силы направляющей дизайн.
А если они встретятся на ревью, то будут спорить до тех пор, пока не придёт лид и не разрешит этот спор административным решением.
Вполне возможно вообще третьим.

Ещё большую неоднозначность вносит тот факт, что одна причина для измений на более высоком уровне абстракции, может разделиться на несколько на более низком.

=== SRP в контексте чистой архитектуры

Для того чтобы разобраться с SOLID вообще и SRP в частности, нам надо обратиться к их образцово показательному применению - Чистой Архитектуре.

image::/posts/21/05/images/clean-arch.svg[]

==== Три классических причины для изменений

Для рассмотрения SRP я упрощу базовую диаграмму, выкинув неважные для него детали:

image::/posts/21/05/images/clean-arch-srp-simplified.svg[]

Из упрощённой диаграммы очевидно, что код следует разбивать как минимум по трём зонам ответственности:

. Представление;
. бизнес правила;
. хранение данных.

Однако даже в этом случае остаётся пространство для разночтений.

Я, даже не будучи специалистом по UI, могу назвать пачку разных подходов к реализации представления, помимо представленного на диаграмме MVP - MVC, MVVM, MVI, MVU.
Но так я не специалист по UI, я не стану разбирать эту чать.
А вот бизнес правила и хранение данных - это моя вотчина и их я рассмотрю подробно.

Глядя на эту диаграмму, многие скажут, что это стандартная практика и все так делают.
Но мой опыт показывает что, обычно разработчики отождествляют сущности со структурами данных, управляемых ORM-ом и относят их к слою данных.

Однако Мартин, относит сущности именно к слою бизнес правил и они вместе с интеракторами образуют ядро приложения.

==== Ядро приложения

По Мартину сущности содержат "ядерные" бизнес правила:

[quote, Роберт Мартин, Clean Architecture]
____
An Entity is an object within our computer system that embodies a small set of critical business rules operating on Critical Business Data.
The Entity object either contains the Critical Business Data or has very easy access to that data.
The interface of the Entity consists of the functions that implement the Critical Business Rules that operate on that data.
____

Интерактору же отводится роль оркестрации исполнения операции системы:
[quote, Роберт Мартин, Clean Architecture]
____
These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their Critical Business Rules to achieve the goals of the use case
____

При этом на практике я вижу, что разработчики создают по одному сервису на "сущность" (таблицу или модель REST API), и всю логику затрагивающую эту сущность собирают в сервисе.
При этом сама сущность вырождается в примитивную структуру данных, для передачи по сети серверу БД или REST API.

Такие структуры данных - совсем не то, о чём пишет Мартин:

> "... The interface of the Entity consists functions that implement the Critical Business Rules that operate on that [Critical Business] data".

При этом есть ещё один любопытный нюанс - все остальные элементы волне себе конкретные (вплоть до PDF View) и понятно что они делают.
А что делают Financial Entities?
Что-то.
Что-то очень важное, критическое и уникальное для конкретного приложения, в конкретный момент его жизни.
Сущности и интеракторы - это единственное место, где разработчики вынуждены решать уникальные задачи.
По моей практике именно качество проектирования сущностей и интеракторов отличает хорошие системы, от систем с архитектурным стилем Big Ball of Mud.

На какие классы разбить бизнес правила *вашей* системы я не знаю.
Но я знаю ряд правил программирования, которые помогают мне бороться с тенденцией систем скатываться к Big Bull of Mud.

=== У бизнес правил и ввода-вывода разные причины для изменений

Теперь давайте вернёмся немного назад и ещё раз посмотрим на оригинальную диаграмму с новым пониманием того, что такое сущности:

image::/posts/21/05/images/clean-arch.svg[]

Если рассматривать сущности как контейнеры для бизнес правил, важной становится ещё одна деталь - сущности не зависят ни от чего.
Это значит, что они не делают никакого ввода-вывода.
Что в свою очередь нас приводит к ещё одной перспективе на подход к разделению ответственности - необходимо разделять код с эффектами (содержащий ввод-вывод) и код с бизнес правилами.
С этой точки зрения система делится на три другие другие части:

. Оболочка отвечающая за ввод-вывод (представление и хранение данных из первого разбиения);
. чистые бизнес правила (точки входа в бизнес логику из первого разделения);
. интеракторы "склеивающие" ввод-вывод и бизнес правила (реализация бизнес логики из первого разделения).

=== Признаки нарушения SRP

. Мёрж-конфликты.
  Если разработчики, работающие над разными задачами оказались в одном файле, то у этого файла более одной причины для изменений;
. Регрессии вида "случайно сломали фичу А, когда чинили фичу Б".
  Если код задействован в двух разных фичах, которые ожидают от него разного поведения, то этот код несёт две ответственности;
  Если разработчик следует SRP, то обнаружив такой баг, он не "полечит его на месте", а разобьёт исходный код на три части - общая часть для обеих фич и специфичная для каждой из фич;
. Регрессии вида "рефакторили фичу А в классе А1, но забыли обновить класс А2"
  Это пример нарушения второй (на самом деле первой) части SRP о которой часто забывают - "Gather together the things that change for the same reasons";
  И в этом случае для следования SRP классы (или их части) А1 и А2 надо наоборот собрать в один.
. Невозможность переиспользования кода из-за лишних побочных эффектов.
  Если код реализует бизнес правило и сразу записывает результат работы в БД, то этот код смешивает ответственности сущности и интерактора;
. ВТФ - код "какой-то кривой" или требует странных приседаний.
  Например как сериализация объекта в строку с помощью Jackson:
+

[source,java]
----
public String renderToJson(Object dto) {
    try {
        return objectMapper.writeValueAsString(dto);
    } catch (IOException e) {
        throw new AssertionError("Unexpected IOException converting object to json");
    }
}
----

+
Глядя на эту обёртку у меня возникает только одна мысль: "Что за ВТФ? Я сериализую объект в строку в памяти, почему я при этом должен обрабатывать невозможные ошибки ввода-вывода?".
Потому что в более низкоуровневом методе `_writeValueAndClose(JsonGenerator g, Object value)` Jackson нарушает SRP по средствам смешения бизнес правила по рендерингу объектов в поток символов и запись этого потока куда-либо.

=== Чего стоит соблюдение SRP и чего стоит его нарушение

Соблюдение SRP стоит довольно дорого.
Как минимум бесконечных войн на ревью на тему того, сколько ответственностей у класса.

Для соблюдения SRP придётся постоянно следить за тем, чтобы классы не превращались в божественные, а методы были реализованы в терминах одного уровня абстракции.
Так же придётся постоянно следить, за тем чтобы в методах не появлялись побочные (лишние) эффекты.

И всё равно в коде будут появляться классы-"божки", а в методы просачиваться абстракции других уровней и побочные эффекты.
Обнаружив это придётся рефакторить код.
Зачастую серьёзно.

Многим для соблюдения SRP придётся освоить декларативный стиль программирования.

Однако усилия того стоят, потому как речь идёт о том, скатится ли ваша система к Big Ball of Mud или нет.
А от этого в свою очередь зависит и удовлетворение разработчиков от работы с кодом, и удовлетворение заказчиков от скорости и стоимости разработки, и удовлетворение пользователей от стабильности продукта.
