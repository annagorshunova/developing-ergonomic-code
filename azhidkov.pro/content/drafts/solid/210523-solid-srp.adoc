---
title: "SOLID: SRP, моя версия"
date: 2021-05-21T13:25:37+07:00
draft: true
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:toc:

== SOLID

(#todo: выкосить столото#)
[sidebar]
****
Формулировки принципов SOLID:

. [big]##**S**##ingle Responsibility Principle: A module should have one, and only one, reason to change.
. [big]##**O**##pen/Closed Principle:: A software artifact should be open for extension but closed for modification.
. [big]##**L**##iskov Substitution Principle:: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T
. [big]##**I**##nterface Segregation Principle:: Clients should not be forced to depend upon interfaces that they do not use.
. [big]##**D**##ependency Inversion Principle::
A. High level modules should not depend upon low level modules. both should depend upon abstractions.
+
B. Abstractions should not depend upon details. details should depend upon abstractions.
****

SOLID - это единственные принципы дизайна, дать определение которым могут 90% разработчиков.
Однако вокруг них много мифов и карго культа, а о части важных вещей Мартин просто слукавил или умолчал.

Этим постом я открываю серию публикаций о SOLID.
Серию в которой я [line-through]#святее Папы# расскажу про SOLID то, чего рассказал сам Мартин.

И первый секрет заключается в том, что не все принципы SOLID одинаково полезны:

. SRP является самым важным, но и самым сложным для применения.
  SRP имеет наибольшее значение для качества дизайна систем, но именно этот принцип нарушается чаще других;
. DIP, автоматически влекущий за собой OCP, так же очень важен, но прост в применении;
. OCP в контексте разработки прикладных программ, несёт преимущественно утилитарную функцию и только в редких случаях его стоит учитывать при дизайне всей системы;
. LSP в контексте разработки прикладных программ, имеет очень низкую актуальность и практически не влияет на дизайн;
. ISP актуален только при разработке *очень* больших систем или работе с языками с долгой компиляцией вроде C++ или Scala.

Серию я разобью на три части:

. SRP - требует наибольшего количества пояснений, поэтому в одиночку занимает весь объём, разумный для поста;
. DIP и OCP - неразрывно связаны друг и имеют архитектурное значение, поэтому я рассмотрю их вместе и во вторую очередь;
. LSP и ICP - я рассмотрю в последнюю очередь, т.к. они имеют наименьшие актуальность и влияние на дизайн.

Но прежде чем перейти собственно к SRP я дам определения нескольких терминов, которые мне потребуются.

== Терминология

Опубликованный интерфейс (Published interface):: интерфейс класса, который используется за пределами кодовой базы, в которой он определён.

Термин введён Мартином Фаулером в книге Refactoring.
Разница между опубликованным интерфейсом и приватной реализации намного больше, чем между публичными и приватными полями и методами.
Этому есть две причины:

. опубликованный интерфейс необходимо делать максимально гибким, чтобы он подходил максимальному количеству клиентов;
. в опубликованный интерфейс можно вносить только обратно-совместимые изменения, поэтому ошибки допущенные в нём остаются на всю жизнь интерфейса.

Из этого следует, что разработка опубликованного интерфейса требует намного больших усилий (существует эвристика, что в три раза больше), чем приватного кода.
Поэтому при разработке кода надо понимать является ли он частью опубликованного интерфейса.

Если вы сэкономите на опубликованном интерфейсе, то обречёте себя на жизнь полную неудобств и ограничений из-за ошибок в интерфейсе.
И есть риск сэкономленные ресурсы потратить в пустую, если вы не обеспечите нужную гибкость своему интерфейсу и  внешние клиенты не смогут им пользоваться.

Если же вы будете писать приватный код, стольже тащательно, как и опубликованный, то эти вложения врят ли когда-нибудь окупятся.

Связность (Cohesion):: степень связанности внутренних элементов модуля

Связанность (Coupling):: степень связанности модулей системы

image::/posts/21/05/images/cohesion-and-coupling.png[]

Связанность - это важное свойство системы.
Без связанности модули - это россыпь независимых компонент, и имено связанность собирает их в систему.
Но чрезмерная связанность модулей системы превращает её в Big Ball of Mud, что усложняет понимание и развитие системы.
В результате разработчик не в состоянии уместить в голове последствия тех или иных изменений, что в свою очередь ведёт к большому количеству неожиданных регрессий.

== Проект Л

Примеры для этого поста я так же взял из своего последнего link:++{{<ref "posts/21/03/210321-project-l-testing#_проект_л" >}}++[Проекта Л].

Плюс с тех пор в проекте появилась новая фича существенная для этого - аппрув пользователей.
Теперь существующий пользователь базовой системы может залогиниться в Проекте Л, только после того как оставит запрос на доступ, который должен быть одобрен.

Наконец, мы можем перейти непосредственно к SRP.

== SRP

SRP это самый актуальный и универсальный принцип, и именно следование SRP спасает системы от превращения в Big Ball of Mud.
Но в то же время SRP является самым неоднозначным и расплывчатым принципом, которому непонятно как следовать.

=== Формулировки

Сам Мартин формулирует его тремя разными способами:

[quote, Robert C. Martinn, Clean Code]
____
The Single Responsibility Principle (SRP) states that a class or module should have one, and only one, reason to change
____

[quote, Robert C. Martinn, The Single Responsibility Principle]
____
Gather together the things that change for the same reasons.
Separate those things that change for different reasons.
____

[quote, Robert C. Martinn, Clean Architecture]
____
A module should be responsible to one, and only one, actor
____

Плюс есть ещё одна очень распространённая в народе формулировка:
[quote, народ]
____
Класс должен делать одну вещь
____

У всех этих формулировок одна общая проблема: любой нетривиальный кусочек кода, имеет более одной причины для изменения, эктора перед которым он отвечает и вещей, которые он делает.
Совсем не факт, что два разработчика, выберут одни и те же причины для изменений, в качестве силы направляющей дизайн.
А если они встретятся на ревью, то будут спорить до тех пор, пока не придёт лид и не разрешит этот спор административным решением.
Вполне возможно вообще третьим.

Ещё большую неоднозначность вносит тот факт, что одна причина для измений на более высоком уровне абстракции, может разделиться на несколько на более низком.

=== SRP в контексте чистой архитектуры

Для того чтобы разобраться с SOLID вообще и SRP в частности, нам надо обратиться к их образцово показательному применению - Чистой Архитектуре.

image::/posts/21/05/images/clean-arch.svg[]

==== Три классических причины для изменений

Для рассмотрения SRP я упрощу базовую диаграмму, выкинув неважные для него детали:

image::/posts/21/05/images/clean-arch-srp-simplified.svg[]

Из упрощённой диаграммы очевидно, что код следует разбивать как минимум по трём зонам ответственности:

. Представление;
. бизнес правила;
. хранение данных.

Однако даже в этом случае остаётся пространство для разночтений.

Я, даже не будучи специалистом по UI, могу назвать пачку разных подходов к реализации представления, помимо представленного на диаграмме MVP - MVC, MVVM, MVI, MVU.
Но так я не специалист по UI, я не стану разбирать эту чать.
А вот бизнес правила и хранение данных - это моя вотчина и их я рассмотрю подробно.

Глядя на эту диаграмму, многие скажут, что это стандартная практика и все так делают.
Но мой опыт показывает что, обычно разработчики отождествляют сущности со структурами данных, управляемых ORM-ом и относят их к слою данных.

Однако Мартин, относит сущности именно к слою бизнес правил и они вместе с интеракторами образуют ядро приложения.

==== Ядро приложения

По Мартину сущности содержат "ядерные" бизнес правила:

[quote, Роберт Мартин, Clean Architecture]
____
An Entity is an object within our computer system that embodies a small set of critical business rules operating on Critical Business Data.
The Entity object either contains the Critical Business Data or has very easy access to that data.
The interface of the Entity consists of the functions that implement the Critical Business Rules that operate on that data.
____

Интерактору же отводится роль оркестрации исполнения операции системы:
[quote, Роберт Мартин, Clean Architecture]
____
These use cases orchestrate the flow of data to and from the entities, and direct those entities to use their Critical Business Rules to achieve the goals of the use case
____

При этом на практике я вижу, что разработчики создают по одному сервису на "сущность" (таблицу или модель REST API), и всю логику затрагивающую эту сущность собирают в сервисе.
При этом сама сущность вырождается в примитивную структуру данных, для передачи по сети серверу БД или REST API.

Такие структуры данных - совсем не то, о чём пишет Мартин:

> "... The interface of the Entity consists functions that implement the Critical Business Rules that operate on that [Critical Business] data".

При этом есть ещё один любопытный нюанс - все остальные элементы волне себе конкретные (вплоть до PDF View) и понятно что они делают.
А что делают Financial Entities?
Что-то.
Что-то очень важное, критическое и уникальное для конкретного приложения, в конкретный момент его жизни.
Сущности и интеракторы - это единственное место, где разработчики вынуждены решать уникальные задачи.
По моей практике именно качество проектирования сущностей и интеракторов отличает хорошие системы, от систем с архитектурным стилем Big Ball of Mud.

На какие классы разбить бизнес правила *вашей* системы я не знаю.
Но я знаю ряд правил программирования, которые помогают мне бороться с тенденцией систем скатываться к Big Bull of Mud.

=== Мои правила

Эти правила я выработал за 16 лет разработки новых и поддержки легаси систем.
В отличие "причины для изменений" большинство этих правил объективны и их нарушение очевидно.
Однако как и в случае SRP, рефакторинг кода, необходимый для "выправления" кода, уже будет субъективен и два разных разработчика сделают его по разному.
Тем не менее, условные цикл в зависимостях или восемь параметров конструктора - это факт, который невозможно оспорить.

==== Правило ацикличности зависимостей

**Объекты, классы, модули и системы должны образовывать ацикличный граф.**

Я не допускаю циклов в зависимостях.
Ни в динамических (на уровне объектов), ни в статических (на уровне классов и модулей).
Для контроля за динамическими зависимостями я практически не использую мутабельные поля - в моём последнем проекте на 10K строк нет ни одного изменяемого поля и 5 (пять) изменяемых локальных переменных.
По одной переменной на 2 тысячи строк кода.

Для контроля за статическими зависимостями я использую Dependency Structure Matrix (https://en.wikipedia.org/wiki/Design_structure_matrix[1], https://www.jetbrains.com/help/idea/dsm-analysis.html[2]).

image::/posts/21/05/images/dsm-censored.png[]

DSM - это квадратная матрица и строками и колонками которой выступают модули или классы, в зависимости от степени "приблежения".
Число в ячейке - это количество упоминаний "строки" в коде "колонки".
Например на число 17 этой диаграмме в первой выделенной ячейке означает что в байткоде пакета "proxy", пакет "invoices" упоминается 17 раз.
В кодовой базе без циклов, эта матрица будет нижне-треугольной (все ячейки выше диагонали будут пустые).

Так же обратите внимание на имена пакетов - это тема отдельного поста, но отражение домена в пакетах системы так же несёт свой вклад в соблюдение SRP.
В частности, если система разбита на функциональные компоненты, то на матрице становятся видны функциональные слои системы.
Обычно можно выделить как минимум три слоя - периферийная (вспомогательная) функциональность системы (auth, \*\**, ops, proxy), ядро системы (invoices, tickets, \***, users) и инфраструктура системы (db, web, \***, event_bus, infra).
Интересно что модуль user настолько близко подошёл к инфраструктуре системы по количеству входящих зависимостей, что провалился в её слой по алфавитному порядку.
Как правило в системах есть две-три такие ядерные сущности, которые притягивают к себе функциональность как чёрные дыры и для них критически важно соблюдение SRP.

У Мартина тоже есть принцип ацикличности зависимостей, но он включил его в набор принципа дизайна пакетов (чтобы не понималось под словом пакет).
На мой же взгляд это правило фундаментальным и применимо на всех уровнях от отдельных методов, до метасистем.

==== Правило пяти параметров конструктора

**У класса должно быть не более пяти (максимум семи) параметров конструктора**

Я слежу за количеством параметров конструктора.
Общее правило - их должно быть не больше пяти, максимум семи.
Параметров из других модулей должно быть не больше трёх.
Все конфигурационные параметры считаются одним параметром (если их больше двух, то их всегда можно объединить в одном классе).
На количество зависимостей на инфраструктуру я смотрю сквозь пальцы, но если один класс и определяет границы транзакций, и занимается распараллеливанием работы, и выполняет обращения по сети и пишет что-то на диск - то это повод присмотреться к нему повнимательнее.

Например, AuthService - класс самым большим количеством параметров:
[source,kotlin]
----
class AuthService(
    override val transactor: Transactor, <1>

    private val baseSystemApi: BaseSystemApi, <2>
    private val usersService: UsersService, <2>

    private val lobbyTokensRepo: LobbyTokensRepository, <3>
    private val approvalRequestsRepo: ApprovalRequestsRepo, <3>

    private val checkApprove: Boolean, <4>
    jwtSecretKey: String, <4>
) {
    suspend fun login(creds: Credentials) = // ...
    suspend fun logout(token: Token) = // ...
    suspend fun exchangeToken(token: String): PersistedUser = // ...
}
----

Сейчас у него семь зависимостей:

<1> одна инфраструктурная зависимость
<2> две зависимости на другие модули
<3> две внутренние зависимости
<4> два параметра

И чтобы дальше не было с этим классом, я не буду добавлять ему новый параметр.
Если какой-то новый метод потребуется дополнительный параметр - я его унесу в другой класс, в том же модуле.
Если потребуется дополнительный параметр, я все параметры соберу в AuthConfig.
Если в одной из функций потребуется новая зависимость - там уже зависит от того, что за требования и что за зависимость, но в крайнем случае, я вижу варианты, как перетряхнуть код так, чтобы выкинуть usersService и approvalRequestsRepo из AuthService.

==== Правило инкапсуляции состояния

**Одна область изменяемого состояния должна изменяться только из одного класса (максимум модуля)**

Я слежу за тем, чтобы одна область link:++{{<ref "posts/21/01/210119-effects#_что_я_понимаю_под_эффектами_и_сигналами" >}}++[изменяемого состояния] менялась только в одном классе и чтобы класс менял только одну область изменяемого состояния.
Изменяемое состояние - это и изменяемые поля, и неизменяемые ссылки на изменяемые структуры данных и ссылки на классы шлюзов (репозитории и клиенты внешних систем), предоставляющие операции записи.

У этого правила есть одно исключение: их может быть больше при условии, что все методы всегда (в идеальном случае атомарно) обновляют все эти области.

И одно послабление: одну область изменяемого состояния можно менять из разных классов одного компонента (пакета).

Например, у базовой системы Проекта Л есть следующая особенность реализации:

[start=0]
. Запросы аутентифицируются токеном в заголовке;
. в ответ на любой запрос, система вместе с успешным ответом может передать новый токен;
. последующие запросы должны использовать новый токен.

Кроме того ещё несколько ограничений, повлиявших на дизайн:

. эту особенность реализации аутентификации необходимо скрыть от фронта;
. аутентификация пользователей должна сохраняться при перезапуске бэка Проекта Л;
. один запрос фронта как правило требует выполнения нескольких запросов к базовой системе (каждый из которых может вернуть новый токен).

Пункты 1 и 2 требуют хранения токена отдельно от бэка (в БД), а 3 пункт требует кэширования токенов.

[NOTE]
====
Немного пояснений по особенностям реализации:

. кэшировать токен в JPA PersistanceContext нельзя, потому что это приведёт к выполнению сетевых вызовов внутри транзакции;
. у проекта вообще нет PersistanceContext, т.к. в перспективе ожидается высокая нагрузка и он сделан на реактивном стэке;
. из-за реактивного стэка и не получилось и воспользоваться стандартным Спринговым тулингом для кэширования.
====

Все эти требования, особенности и ограничения я инкапсулировал в одном классе - BaseAppApi.

[source,kotlin]
----
class BaseAppApi(
    private val tokenRepo: BaseAppTokensRepo
) {
    private val tokenCache = AtomicReference<Map<BaseAppUserKey, BaseAppToken>>(emptyMap())

    suspend fun logout(key: BaseAppUserKey) {
        tokenRepo.deleteByKey(key)
        tokenCache.updateAndGet { old -> old.minus(key) }
    }
    private suspend fun updateToken(token: BaseAppToken) {
        tokenRepo.save(token)
        tokenCache.updateAndGet { old -> old.plus(token.key to token) }
    }
}
----

Этот класс управляет двумя кусочками изменяемого состояния - репозиторием токенов и их кэшем.
Но эти кусочке меняются всегда вместе.

Как правило такие неразрывно связанные области состояния являются той или иной формой кэша.
Либо непосредственно кэшем, как в этом примере, либо какими-то производными данными полученными из первоисточника (денормализованное представление в БД, например).

==== Правило расширения за счёт расширения

**Новая функциональность должна добавляться за счёт добавления нового кода, а не изменения старого.**

При добавлении новой функциональности, я стараюсь добавлять новые модули, а не менять старый.

Например в Проекте Л, по среди его реализации заказчик попросил добавить аппрув пользователей.
Многие бы просто добавили флажёк в таблицу users.
Но это решение имеет целый ряд проблем.

Во-первых, пользователи это как правило одна из тех чёрных дыр, которые притягивают зависимости и состояние.
Если за флажками пользователей не следить, то по одному-два за раз их может накопиться два-три десятка.
А это элементарно слишком много для человека.

Плюс все эти флажки постоянно пишут разные модули, возможно задуманные как работающие параллельно.
Но на практике, из-за того что они пишут в одну и ту же строку, СУБД будет вынуждать их работать последовательно.

Наконец, эти тридцать полей надо банально передавать по сети туда-сюда.

Во-вторых, аппрув пользователей - это вспомогательная и временная функциональность.
И если её сделать флажком пользователя, то при её удалении придётся менять ядерный модуль системы.

В результате я сделал аппрув внутренним компонентом компонента авторизации:

image::/posts/21/05/images/approval-comp.svg[]

Это решение так же позволило мне отдать задачу по реализации административной панели стороннему разработчику буквально с парой требований:

. схема таблицы;
. описание функциональности по примитивной аутентификации и изменению одного поля этой таблицы.

Разработчику при этом не пришлось тратить время на погружение в контекст проекта.

При этом я не на 100% отвязал ядро приложения от функциональности аппрува - при её удалении надо будет менять AuthService.
Но для того чтобы это сделать мне бы пришлось заводить какую-то абстрактную цепочку валидаторов и я решил, что это будет оверкил в данном случае.

==== Правило локальности изменений

**Код, который меняется в одном месте должен быть расположен максимально близко**

Я слежу за тем, чтобы код меняющийся в одно время находился в одном месте.

Это правило я проиллюстрирую на примере нарушения в том же аппруве.

Для того, чтобы минимизировать стоимость реализации и отвязать ядро приложения от административной панели, я решил его сделать отдельным приложеним на Grails.

Из-за этого мне пришлось продублировать описание структуры таблицы запросов на аппрув:


[source,kotlin]
----
@Table("approval_requests")
data class ApprovalRequest(
    @Id
    val email: String,
    val approved: Boolean? = null,
    @Version
    val version: Long = 0
)
----

[source,groovy]
----
class ApprovalRequests {

    String email
    Boolean approved
    Integer id

    static transients = ['id']

    static constraints = {
        email maxSize: 320
        approved nullable: true
    }

    static mapping = {
        table 'approval_requests'
        id column: 'email', generator: 'assigned', type: "string", name: "email"
        version false
    }
}
----

Чем мне это грозит?
Если вдруг мне когда-нибудь потребуется добавить дату создания запроса, то с большой долей вероятности я забуду это сделать в административной панели, породив регрессию.

==== Правило тестов

. Тесты должны быть;
. тесты должны создавать тестирумые объекты без DI-контейнера;
. тесты должны использовать моки классов только для симуляции ошибок.

Я пишу тесты.
В тестах я не использую DI-контейнер (на самом деле под конец проекта пришлось добавить Spring для получения Spring Data репозиториев и ограничений по времени).
И не мокаю классы.
Совсем.
У меня даже библиотеки такой в зависимостях нет.

Ручное создание экземпляра тестируемого класса (и всего графа его зависимостей) является отличной лакмусовой бумажкой - если это делать сложно, то с высокой долей вероятности класс несёт слишком много ответственностей.

==== Правило высокой связности и низкой связанности

Я разбиваю систему на модули с высокой связностью и низкой связанностью.

image::/posts/21/05/images/tickets-tracker-dsm.png[]

На диаграмме есть техническая проблема: "\<\->" это цикл между классом TicketsTracker и свободными функциями из того же файла.
Если их рассматривать как единое целое (чем они и являются), то с точки зрения связности и связанности тут всё довольно хорошо - одна входящая зависимость, 6 внутренних зависимостей, 3 внешних зависимости, одна из которых на инфраструктуру, вторая на "ядерного" пользователя, а третья на "справочный" тираж.

Высокой связностью должны обладать и структуры данных.
Не должно быть такого, что в разных юз кейсах (например, отправка запроса и получение ответа) заполняются разные подмножества полей структуры.

Я как-то встречал класс, который использовался для отправки и получения пары десятков видов сообщений по трём разным каналам.
В результате у этого класса было 56 (пятьдесят шесть) полей и лично я банально боялся с ним связываться.

==== Правило разделения команд и запросов

Я я стремлюсь соблюдать Command-query separation - вопрос не должен менять ответ.
В строгой интерпретации, это значит, что метод должен либо возвращать значение отличное от void (Unit и т.п.) либо выполнять эффект.
На практике я часто возвращаю значение с результатом выполнения в методах с эффектами, но строго слежу за тем, чтобы методы воспринимающиеся как чистые не выполняли неожиданных эффектов.

=== У бизнес правил и ввода-вывода разные причины для изменений

Теперь давайте вернёмся немного назад и ещё раз посмотрим на оригинальную диаграмму с новым пониманием того, что такое сущности:

image::/posts/21/05/images/clean-arch.svg[]

Если рассматривать сущности как контейнеры для бизнес правил, важной становится ещё одна деталь - сущности не зависят ни от чего.
Это значит, что они не делают никакого ввода-вывода.
Что в свою очередь нас приводит к ещё одной перспективе на подход к разделению ответственности - необходимо разделять код с эффектами (содержащий ввод-вывод) и код с бизнес правилами.
С этой точки зрения система делится на три другие другие части:

. Оболочка отвечающая за ввод-вывод (представление и хранение данных из первого разбиения);
. чистые бизнес правила (точки входа в бизнес логику из первого разделения);
. интеракторы "склеивающие" ввод-вывод и бизнес правила (реализация бизнес логики из первого разделения).

=== Декомпозиция системы на модули

В этом посте я рассматриваю только один аспект декомпозиции системы - на какие части надо разбивать код, отвечающий за одну операцию системы.
Таких операций и данных, которыми они манипулируют в любой нетривиальной системе будет много и в этом разрезе систему тоже надо декомпозировать.

Но этот пост и без того огромен, поэтому вопрос декопозиции системы на модули я сейчас не буду рассматривать и дам только ссылки, где можно об этом почитать:

. http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod[Принципы дизайна пакетов] Анкл Боба;
. Черновики разделов link:https://azhidkov.pro/book/ergo/#_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%BE%D0%B2[Таблица Эффектов] и link:https://azhidkov.pro/book/ergo/#_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B[Принципы проектирования системы] моей книги
. Научные статьи https://www.researchgate.net/publication/283566310_Improving_Design_Decomposition[Improving Design Decomposition] и https://www.researchgate.net/publication/326260296_Functional_Decomposition_for_Software_Architecture_Evolution[Functional Decomposition for Software Architecture Evolution]
. Глава 6. Creating Components книги https://pragprog.com/titles/vmclojeco/clojure-applied/[Clojure Applied]

=== Признаки нарушения SRP

. Мёрж-конфликты.
  Если разработчики, работающие над разными задачами оказались в одном файле, то у этого файла более одной причины для изменений;
. Регрессии вида "случайно сломали фичу А, когда чинили фичу Б".
  Если код задействован в двух разных фичах, которые ожидают от него разного поведения, то этот код несёт две ответственности;
  Если разработчик следует SRP, то обнаружив такой баг, он не "полечит его на месте", а разобьёт исходный код на три части - общая часть для обеих фич и специфичная для каждой из фич;
. Регрессии вида "рефакторили фичу А в классе А1, но забыли обновить класс А2"
  Это пример нарушения второй (на самом деле первой) части SRP о которой часто забывают - "Gather together the things that change for the same reasons";
  И в этом случае для следования SRP классы (или их части) А1 и А2 надо наоборот собрать в один.
. Невозможность переиспользования кода из-за лишних побочных эффектов.
  Если код реализует бизнес правило и сразу записывает результат работы в БД, то этот код смешивает ответственности сущности и интерактора;
. ВТФ - код "какой-то кривой" или требует странных приседаний.
  Например как сериализация объекта в строку с помощью Jackson:
+

[source,java]
----
public String renderToJson(Object dto) {
    try {
        return objectMapper.writeValueAsString(dto);
    } catch (IOException e) {
        throw new AssertionError("Unexpected IOException converting object to json");
    }
}
----

+
Глядя на эту обёртку у меня возникает только одна мысль: "Что за ВТФ? Я сериализую объект в строку в памяти, почему я при этом должен обрабатывать невозможные ошибки ввода-вывода?".
Потому что в более низкоуровневом методе `_writeValueAndClose(JsonGenerator g, Object value)` Jackson нарушает SRP по средствам смешения бизнес правила по рендерингу объектов в поток символов и запись этого потока куда-либо.

=== Чего стоит соблюдение SRP и чего стоит его нарушение

Соблюдение SRP стоит довольно дорого.
Как минимум бесконечных войн на ревью на тему того, сколько ответственностей у класса.

Для соблюдения SRP придётся постоянно следить за тем, чтобы классы не превращались в божественные, а методы были реализованы в терминах одного уровня абстракции.
Так же придётся постоянно следить, за тем чтобы в методах не появлялись побочные (лишние) эффекты.

И всё равно в коде будут появляться классы-"божки", а в методы просачиваться абстракции других уровней и побочные эффекты.
Обнаружив это придётся рефакторить код.
Зачастую серьёзно.

Многим для соблюдения SRP придётся освоить декларативный стиль программирования.

Однако усилия того стоят, потому как речь идёт о том, скатится ли ваша система к Big Ball of Mud или нет.
А от этого в свою очередь зависит и удовлетворение разработчиков от работы с кодом, и удовлетворение заказчиков от скорости и стоимости разработки, и удовлетворение пользователей от стабильности продукта.
