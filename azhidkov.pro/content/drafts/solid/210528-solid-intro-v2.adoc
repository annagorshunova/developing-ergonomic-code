---
title: "SOLID: Введение"
date: 2021-05-21T13:25:37+07:00
draft: true
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font

== SOLID

Кажется, все знают, что такое SOLID.

.Если вдруг не знаете - кликните здесь
[%collapsible]
====
SOLID - это название принципов объектно-ориентированного дизайна, сформулированных Робертом Мартином, так же известного как анкл Боб.
Принципы звучат следующим образом:

. [big]##**S**##ingle Responsibility Principle: A module should have one, and only one, reason to change.
. [big]##**O**##pen/Closed Principle:: A software artifact should be open for extension but closed for modification.
. [big]##**L**##iskov Substitution Principle:: What is wanted here is something like the following substitution property: If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T
. [big]##**I**##nterface Segregation Principle:: Clients should not be forced to depend upon interfaces that they do not use.
. [big]##**D**##ependency Inversion Principle::
A. High level modules should not depend upon low level modules. both should depend upon abstractions.
+
B. Abstractions should not depend upon details. details should depend upon abstractions.
====

В университетах рассказывают принципы SOLID.
По крайней мере лично я рассказывал.
На собеседованиях спрашивают принципы SOLID.
По крайней мере я спрашиваю.
#При ревью аппелируют к принципам SOLID.#
#По крайней мере я апеллирую.#
Каждый уважающий себя блоггер от IT пишет посты о SOLID.
По крайней мере я пишу.

(#todo: коммент#)

А теперь давайте проведём мысленный эксперимент и представим, что SOLID-а нет в мире.
Что изменится?
Я утверждаю, что по большому счёту ничего.
Люди не будут холиварить о нём и... всё.

Судя по тому что я вижу, большинство коммерческого софта и так игнорируют SOLID в любой из его интерпретаций и его дизайн так и останется плохим.
А та небольшая часть софта, что спроектирована хорошо, отталкивается от других идей и методик и останется хорошей.

Давайте теперь разберём каждый из принципов с точки зрения плохого и хорошего софта.
Под плохим софтом я буду понимать типовую слоёную архитектуру с обилием императивного кода, и ORM-а вроде JPA.
Под хорошим софтом я буду понимать шестиугольную архитектуру с ядром в функциональном стиле, следующую тактическим паттернам DDD и декомпозирующем систему на ограниченные контексты или компоненты эргономичного подхода.

(#todo: mocks#)

=== SRP

(#todo: разбиение кода на более мелкие кусочки позволяет переиспользовать эти кусочки. но тут тоже важе не перестараться. отложить разделение логики, может быть черевато, так как, потусив с условным UI-ем она успевает прирости к нему, и разделить их будет тяжело#)

==== Пояснение влияния примениня принципа на дизайн

https://hackernoon.com/you-dont-understand-the-single-responsibility-principle-abfdd005b137

==== Дизайн плого софта

===== Что он всё равно нарушает и делает по другому

===== А там где не нарушает, это берётся из слоёной архитектуры

==== Дизайн хорошего софта

===== То в чём он совпадает, он берёт из другого места

=== OCP

==== LSP

=== DIP

DIP это единственный принцип SOLID, про который я не могу сказать ничего плохого, и который повсеместно применяется.

==== Пояснение

Говоря простым языком, DIP это просто техника по разрыву зависимостей.
Допустим, у вас есть класс A, который использует класс B.
Но вы не хотите, чтобы класс A статически зависил от класса B.
На это может быть целый ряд причин:

. у вас в требованиях написанно, что во второй версии у вас будет альтернативная (#todo: версия#) функциональности, реализуемой сейчас классом B;
. класс A реализует бизнес требования (то, что можно обсудить с заказчиком), а класс B реализует техническую функцию (то, что нельзя обсудить с заказчиком).
  Для того чтобы класс А остался понятным заказчику, его надо изолировать от деталей класса B, поэтому вы выделили B в отдельный модуль, который зависит от модуля класса A, а не наоборот
. ваш DI или Mock фреймворк умеет работать только с интерфейсами.
. Вы просто боитесь, что класс Б поменяется
. Класс Б зависит от того, о чём не должен знать класс А (потому что оно поменяется)
. Циклическая зависимость между модулями классов A и B.

Для того, чтобы разорвать статическую связь между классами A и B, но оставить возможность объектам класса A в рантайме изпользовать объекты класса B, необходимо выделить интерфейс C, реализовать его в классе B, и использовать в классе A.

Это и есть инверсия зависимости.

И эта техника используется повсеместно и в плохом и в хорошем софте.

==== Дизайн плохого софта

==== Дизайн хорошего софта


---

== SOLID

. Вроде бы лучше, чем ничего, но по факту кажется всё-таки ничего.
. Проиграли битву слоёной архитектуре.
  Потому что в одном случае очевидно, что делать, а в другом - хрен пойми.
. Вообще не особо понятно, что такое СОЛИД:
.. Изначально были олди
.. потом формулировки или пояснения постоянно менялись
.. Вроде бы SOLID появился в районе 2004, года, но после 2002 Мартин их ни разу подробно и все вместе не описывал
. Приколочены к программированию с классами

---

== The Good

Заставили людей вообще хоть как-то задуматься о проектировании.

Всего 50 страничек, в отличие от

. 1370 страниц Object-Oriented Software Construction, Майера
. 546 страниц Object Oriented Software Engineering: a use case driven approach, Якобсона
. 497 страниц Working with objects  The OOram Software Engineering Method, Ринскауга
. 707 страниц Object-Oriented Analysis and Design with Applications, Буча

Свежие (в начале 2000ых), да ещё и Аджайл, в отличие от

. Сокрытия информации 71ого года
. Разделения проблем 74ого года

== The Bad

== The Ugly

Ранние статьи
Agile
http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html
Чистая архитектура
https://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html
