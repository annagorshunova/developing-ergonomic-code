---
title: "Подходы к декомпозиции бэкендов информационных систем (Черновик)"
description: "(#todo: коммент#)"
date: 2022-08-09T08:25:37+07:00
draft: false
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font
:sectlinks:
:imagesdir: /drafts/images

[NOTE]
--
Следить за обновлениями блога можно в моём канале: https://t.me/ergonomic_code[Эргономичный код]
--

[quote, Grady Booch, Object-Oriented Analysis and Design with Applications,role=epigraph]
____
a class is a necessary but insufficient vehicle for decomposition

Класс - это необходимое, но недостаточное средство декомпозиции
____


Количество классов в реализации даже небольшой программы на один человеко-месяц исчисляется десятками.
В средних программах на несколько человеко-лет счёт идёт уже на тысячи.
А человек может одновременно оперировать 7-ю +/- 2 объектами.
Поэтому все нетривиальные программы требуют декомпозиции своей реализации на более крупные блоки чем классы - я буду называть такие блоки пакетами.

Сейчас чаще всего можно встретить два основных подхода к декомпозиции систем:

. Пакетирование по слоям и техническим аспектам (далее просто "по слоям" для краткости)
. Пакетирование на основе предметной области, представленное группой вариантов:
.. Пакетирование по фичам
.. Пакетирование по компонентам
.. Ограниченные контексты и пакетирование по агрегатам из предметно-ориентированного дизайна (DDD)

Однако мне в полной мере не подошёл ни один из этих подходов и я разработал ещё один подход к декомпозиции системы на пакеты, основывающийся на предметной области.
Его текущее рабочее название - объектно-ориентированный.

Естественным образом, все варианты подходов на базе предметной области дают схожую декомпозицию.
Но в отличие от остальных подходов, для объектно-ориентированного существует простая и понятная методика, которая позволяет быстрее получить хороший результат.
Сам факт существования и суть методики делает подход более инженерным, чем остальные подходы в группе, которые больше напоминают исскуство или ремесло.

В этом посте я определю критерии сравнения подходов, оценю по ним распространённые подходы и кратко представлю используемый мной подход.

[NOTE]
====
В области группировки кода вообще и классов в частности есть ещё много разных идей и подходов - http://jodypaul.com/SWE/HAL/hal.html[разделение Парнаса], https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719[структурный дизайн Константина], https://www.youtube.com/watch?v=N7agCpAYp1Q[принципы дизайна пакетов Мартина], https://ieeexplore.ieee.org/document/914968[подходы на основе кластерного анализа], многие книги (https://www.amazon.com/Designing-Object-Oriented-Software-Rebecca-Wirfs-Brock/dp/0136298257[Designing object-oriented software], https://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062[Applying UML and Patterns], https://www.amazon.com/Designing-Object-Oriented-Applications-Method/dp/0132038374[Designing Object Oriented C++ Applications Using The Booch Method]) по ООП/Д затрагивают этот вопрос.

Однако по моей оценке на основе того что я вижу в интернете и на конференциях - все они не получили распространения на практике и чтобы сократить и без того огромный пост, я не буду их рассматривать.

Отмечу лишь, что две из них (разделение Парнаса и структурный дизайн) - дали нам универсальные критерии оценки дизайна программ - сокрытие информации и сцепленность/связанность соотвественно.
И я их возьму за основу для критериев оценки подходов.
====

== Критерии

Подходы я буду сравнивать по двум аспектам - насколько хорошие декомпозиции они дают и насколько легко их применять.

Качество декомпозиции я буду оценивать по следующим критериям:
. Сокрытие информации.
  Какую информацию подход скрывает
. Сцепленность.
  Какое количество связей между пакетами порождает подход.
. Связанность.
  Какое количество связей внутри пакета порождает подход.
. Масштабируемость
  Насколько большие системы могут быть декомпозированы с помощью подхода

Оценка сцепленности только по количеству связей внутри пакета, может быть легко "хакнута" - например, если в слоёной декомпозиции слой сервисов сделать высоко сцепленным.
В этом случае формально слой сервисов будет обладать высокой связанностью, но фактически он будет обладать высокой сцепленностью внутренних элементов.

Для того чтобы это обойти, для оценки сцепленности я дополнительно буду оценивать локальность изменений.
Локальность изменений, в свою очередь, я буду оценивать по двум критериям:
. Сколько в среднем пакетов затрагивает одно изменение.
  В идеальной декомпозиции это число должно быть равно 1.
. Можно ли найти https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0[топологическую сортировку], определяющую такой порядок, что при удалении пакетов в соответствии с ним, система продолжает на каждом шаге:
.. Собираться
.. Быть полезной для конечного пользователя

Лёгкость применения я буду оценивать по таким критериям:

. Простота обучения.
  Насколько просто обучить человека подходу.
. Простота исполнения.
  Есть ли у подхода методика выполнения и насколько она проста

== Пакетирование по слоям и техническим аспектам

image::ergonomic-decomposition-Layers.drawio.svg[]

[NOTE]
====
В этом посте я буду рассматривать только декомпозицию выделенных бэкендов, которые предоставляют API для фронтэнда.
В этом случае контроллеры выступают в роли тонких адаптеров обращений по протоколу сетевого взаимодействия (REST, SOAP, всевозможные протоколы RPC и т.д.) в вызовы методов сервисов.
====

https://github.com/ardalis/CleanArchitecture/tree/main/src/Clean.Architecture.Core[Пример]

Этот подход настолько прост и существует настолько давно, что кажется это уже коллективное бессознательное нашей индустрии.
Я пытался найти авторитетный источник, в котором бы вводилась эта концепция, но потерпел крах.

Тем не менее, в моей практике этот подход является самым распространённым и, думаю, он знаком всем разработчикам, имеющим хотя бы полгода коммерческого опыта за плечами.
Способ группировки заключается в том, что команда выбирает несколько аспектов реализации (самые частые примеры - контроллеры, сервисы, репозитории/дао, сущности, дто, фабрики, исключения, перечисления) и группирует классы по ним.
Классы, которые не удаётся однозначно отнести к одному из этих аспектов, сваливают в специальную группу, которую обычно называют utils или common.

В слоёной архитектуре существует только одно ограничение - более "низкие" слои не могут зависеть от более "высоких".
Это ограничение становится менее ясным, когда на одном уровне смешивают и архитектурную декомпозицию (контроллеры, сервисы, репозитории, сущности) и техническую (исключения, перечисления, фабрики).
В этом случае для технических "слоёв" становится невозможно определить их порядок.
Например, что является более "высоким" слоем/уровнем - исключения или перечисления?

Такая декомпозиция теоретически должна скрывать способ реализации технических аспектов, например, способ работы с БД.
Однако на практике, детали реализации слоёв "link:++{{< ref "posts/22/07/abstraction-wars">}}++[протекают]" через границы, результатом чего становится отсутствие какого-бы то ни было сокрытия информации вообще.

Для слоёной декомпозиции естественной является высокая сцепленность системы.
Самый "толстый" слой сервисов содержит в себе только код, а все структуры данных (сущности, дто, исключения, перечисления) и код работы с ними (репозитории, фабрики, билдеры) находятся в других пакетах.
В итоге каждый класс в пакете сервисов начинает зависеть от множества классов в соседних пакетах, тем самым, по определению, повышая сцепленность.

Кроме того, даже единственное ограничение на зависимости между слоями чаще нарушают, чем соблюдают, ещё больше повышая сцепленность системы за счёт внесения циклов в зависимости.

В итоге декомпозиция по слоям представляет собой сочетание врождённой высокой сцепленности между пакетами и белого пятна в проектировании внутри пакетов.
Эта гремучая смесь приводит к превращению системы в печально известный Big Ball of Mud (большой ком грязи) уже к концу первого года своей жизни.

Если связанность оценивать только по количеству связей внутри пакета, то откровенно плохо реализованная система с десятками зависимостей в каждом сервисе и связным графом сущностей может показаться высоко связанной.
Однако истинная связанность таких систем легко демонстрируется с помощью <<Критерии, дополнительных критериев>>, введённых специально для этого случая.

Большинство нетривиальных изменений таких систем будет затрагивать множество пакетов.
А единственный пакет, который может быть удалён первым без поломки сборки проекта - пакет контроллеров - сразу же сделает всю систему бесполезной для пользователя.
Если рассмотреть слоёную декомпозицию с этих точек зрения, то становится очевидно, что она обладает логической связанностью - чуть лучшей связанностью, чем случайная.

С точки зрения масштабируемости слоёная декомпозиция так же даёт плохие результаты.
Постоянно развиваемая система довольно быстро доходит до 20-30 классов одного типа (то есть в одном пакете) и снова возникает проблема их группировки.

Хорошо, если команда осознано выбрала слоёную декомпозицию, для сокращения времени разработки первой версии.
В этом случае, достигнув пределов масштабирования слоёной архитектуры, команда может провести качественную декомпозицию.

Однако на практике слоёную декомпозицию не выбирают.
Чаще всего это единственный известный и понятный разработчикам способ декомпозиции.
И разработчиков сложно в этом винить, декомпозиции систем действительно нигде не учат - меня самого не учили в университете, и соответствующих курсов я ни разу не видел.
И это не только моё мнение, с ним согласен например и https://ru.wikipedia.org/wiki/%D0%9E%D1%83%D1%81%D1%82%D0%B5%D1%80%D1%85%D0%B0%D1%83%D1%82,_%D0%94%D0%B6%D0%BE%D0%BD[Джон Оустерхаут], автор https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201[A Philosophy of Software Design]:

[quote, John Ousterhout,"A Philosophy of Software Design, с. 9"]
____
I have not been able to identify a single class in any university where problem decomposition is a central topic.
We teach for loops and object-oriented programming, but not software design.

У меня до сих пор не получилось найти хотя бы один курс в каком-либо университете, где бы декомпозиция задач была бы основной темой.
Мы учим циклам и объектно-ориентированному программированию, но не проектированию ПО.
____

Поэтому, как правило, дальнейшая декомпозиция внутри пакетов-слоёв выполняется методом "как бог на душу положит" первым разработчиком, который решил, что "пакет слишком разросся".

Если слоёная декомпозиция даёт столь плохие результаты, как она стала самой распространённой?
Секрет кроется во второй группе критериев оценки методики - простоте обучения и исполнения.

Слоёная декомпозиция не требует практически никакой квалификации и мышления и может быть автоматизирована даже без применения нейронных сетей - просто путём поиска нескольких ключевых подстрок в строке определения класса.

Этим же определяется и простота исполнения - опытный разработчик выполняет слоёную декомпозицию буквально спинным мозгом не затрачивая ни секунды на проектирование.

[NOTE]
====
Хочу отметить, что я не являюсь противником разделения кода на слои как такового - в моих проектах есть и контроллеры, и сервисы, и репозитории.
Более того, во всех моих системах последних семи лет за пользовательский интерфейс, бизнес-логику и хранение данных отвечают разные программы - веб- или мобильное приложение, бэкенд сервер и СУБД соотвественно.
А если бы я делал программу, реализующую все три аспекта, то я бы её в первую очередь разбил по слоям.
Однако для программ, сфокусированных только на одном из этих аспектов, слои работают откровенно плохо.
====

Итоговая оценка пакетирования по слоям:

. Сокрытие информации - плохо
. Сцепленность - плохо
. Связанность - плохо
. Масштабируемость - плохо
. Простота объяснения - очень хорошо
. Простота применения - очень хорошо

== Пакетирование по фичам

image::ergonomic-decomposition-Features.drawio.svg[]

https://github.com/mmpodkanski/computer-shop-back/tree/main/src/main/java/io/github/mmpodkanski/computershop[Пример].

Найти источник идеи пакетирования по слоям у меня тоже не получилось, но этой теме посвящено множество постов:

. http://www.javapractices.com/topic/TopicAction.do?Id=205[Package by feature, not layer]
. https://medium.com/sahibinden-technology/package-by-layer-vs-package-by-feature-7e89cde2ae3a[Package by Layer vs Package by Feature]
. https://dzone.com/articles/how-changing-java-package
. https://medium.com/expedia-group-tech/package-by-feature-not-by-layer-5ba04a070003[https://medium.com/expedia-group-tech/package-by-feature-not-by-layer-5ba04a070003]
. https://dzone.com/articles/package-by-feature-is-demanded[Package by Feature Is Demanded]
. https://www.raywenderlich.com/books/real-world-android-by-tutorials/v1.0/chapters/2-starting-from-the-beginning[Starting from the Beginning]
. Продолжать можно очень долго

Хотя ни один из них я не могу назвать ни авторитетным, ни исчерпывающим.

В этом подходе, приложение декомпозируют на пакеты по фичам - для каждой фичи создаётся пакет, и весь код реализующий фичу попадает в этот пакет.
При том каждый пакет имеет явно выделенный публичный интерфейс, а всё остальное скрывается.

Но тут мы сразу упираемся в главный недостаток этого подхода - его сложно объяснить, а исполнить ещё сложнее.

Декомпозиция по фичам только звучит просто (и то не для всех).
Когда же вы сядете и попытаетесь декомпозировать по фичам, у вас тут же возникнет множество вопросов: "А фича это вообще что такое?", "Как мне из требований получить набор фич?", "Судя по примерам, фича - это таблица. Мне что, заводить по пакету на каждую таблицу?", "А что делать с таблицами связками?", "Что делать с функциями, которые затрагивают две и более таблицы - в какой пакет их помещать?", "А что делать с функциями, которые работают не с таблицами, а с REST API?", "А с S3?", "А куда мне положить DSL создания Excel файлов для нескольких фич? В utils?".
Ответы на все эти вопросы придётся искать самостоятельно, потому как все посты ограничиваются поверхностным описанием идеи.

Найти ответы, конечно же, можно - я нашёл и у меня получился объектно-ориентированный подход к пакетированию.
Но мне для этого потребовалось 5 лет вялотекущих размышлений, 2 года активной работы в этом направлении и эксперименты в пяти коммерческих проектов.
Не у всех есть желание и возможность этим заниматься - когда давят сроки, лучше декомпозировать на проверенные годами слои.

Но если преодолеть все сложности и не остановиться на полпути, то наградой будет декомпозиция высокого качества по нашим критериям - принципы низкой сцепленности/высокой связанности и сокрытия информации практически во всех постах предлагаются как главенствующие.

С масштабируемостью дела обстоят хуже.
При декомпозиции по фичам, быстро рости будет не количество классов в пакетах, а количество самих пакетов
И если ничего не предпринять, то уже количество пакетов быстро дорастёт до 20-30 штук и проблема декомпозиции системы снова встанет в полный рост.
В постах же эта проблема либо не упоминается вовсе, либо упоминается лишь вскользь
В результате разработчик снова остаётся с ней один на один.
Но благодаря поискам ответов на изначальные вопросы, разработчик хорошо прокачает свой скилл проектирования и в этом случае будет высокий шанс того, что получившаяся декомпозиция окажется высокого качества.

Итоговая оценка пакетирования фичам:

. Сокрытие информации - хорошо
. Сцепленность - хорошо
. Связанность - хорошо
. Масштабируемость - средняя
. Простота объяснения - плохо
. Простота применения - плохо

== Пакетирование по компонентам

image::ergonomic-decomposition-Components.drawio.svg[]

Примеры: https://github.com/techtribesje/techtribesje[[1]], https://github.com/ttulka/blog-code-samples/tree/master/myshop[[2]].

Пакетирование по компонентам - первый подход в нашем списке, для которого есть конкретный http://www.codingthearchitecture.com/2013/04/08/mapping_software_architecture_to_code.html[источник] (так же см. http://www.codingthearchitecture.com/2014/05/29/software_architecture_vs_code.html[1], http://www.codingthearchitecture.com/2014/06/01/an_architecturally_evident_coding_style.html[2], http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html[3], https://github.com/techtribesje/techtribesje[4], а так же главу 34 "Missing Chapter" из https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164[Clean Architecture]).

Пакетирование по компонентам очень похоже на пакетирование по фичам, поэтому я не буду на нём подробно останавливаться и лишь обозначу отличия.

Браун дистанцируется от пакетирования по фичам в первую очередь тем, что у него контроллеры вынесены в отдельный пакет.
По его задумке это должно повысить сокрытие информации о реализации сервисов
Однако он это делал для классических контроллеров из MVC, которые собирают модель для представления из нескольких сервисов и для нашего случая с контроллерами API в этом смысла нет.

Зато есть другое отличие - модель данных выделена в собственный пакет.
В тексте это явно не проговорено, но видно из http://www.codingthearchitecture.com/images/20130408-package-by-component.png[иллюстрации] и https://github.com/techtribesje/techtribesje/tree/master/techtribes-core/src/je/techtribes/domain[кода примера].
И вот это уже, на мой взгляд проблема, так как из-за этого за границы компонента начинает утекать структура его данных и это создаёт предпосылки для сцепленности через общее окружение.

Уже в процессе редактуры этого поста я наткнулся на твит Брауна:

[quote, Simon Brown, https://twitter.com/simonbrown/status/969112668132073473?s=20&t=w8c5RikLz3zFdS7X4APvNw]
____
Each non-UI component isn’t a “feature”, it’s something else...
like a domain concept or aggregate root (including DB access), integration point to the outside world, technical service, etc.

Каждый "non-UI" компонент не является "фичей", это что-то другое...
как концепт предметной области или корень агрегата (включаю доступ к БД), точка интеграции с внешним миром, технический сервис и т.д.
____

Основываясь на этом твите, можно предположить, что понимание Брауна подхода к декомпозиции эволюционировало и теперь пакетирование по компонентам по сути совпадает с пакетированием по объктам.
Но это не точно.

И хотя с описанием пакетирования по компонентам дела обстоят лучше, чем с описанием пакетирования по фичам, чёткой методики выявления компонентов Браун так же не предлагает.
Поэтому итоговая оценка такая же.

Итоговая оценка пакетирования компонентам:

. Сокрытие информации - средне
. Сцепленность - средне
. Связанность - хорошо
. Масштабируемость - средняя
. Простота объяснения - плохо
. Простота применения - плохо

== Ограниченные контексты и пакетирование по агрегатам из предметно-ориентированного дизайна (DDD)

image::ergonomic-decomposition-DDD.drawio.svg[]

Примеры: https://github.com/citerus/dddsample-core[[1]], https://github.com/VaughnVernon/IDDD_Samples[[2]], https://github.com/ddd-by-examples/library[[3]].

DDD - это полноценный подход к проектированию, описанный в одноимённой https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[книге] Эрика Эванса.
Помимо этой книги есть ещё ряд очень хороших книг - https://pragprog.com/titles/swdddf/domain-modeling-made-functional/[Domain Modeling Made Functional], https://www.oreilly.com/library/view/patterns-principles-and/9781118714706/[PPP of DDD], https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577[Implementing Domain-Driven Design] суммарно на 2200 страниц, множество менее качественных книг и бессчётное количество постов в интернете.

Суть подхода можно охарактеризовать как то, что исходный код программы должен быть написан на языке предметной области

Мне самому DDD импонирует и в Эргономичном подходе я многое позаимствовал из DDD, в первую очередь - концепцию агрегатов.
Однако, вместо того, чтобы работать по DDD я начал делать Эргономичный подход.
Этому есть две основные причины - тяжеловесность и расплывчатость DDD.

Тяжеловесность DDD проявляется как в обучении, так и в применении.

DDD - это очень большая штука, на изучение которой требуется очень много времени.
Как минимум надо будет прочитать 1000 страниц оригинальной книги и PPP of DDD или Implementing DDD.
И лично мне этого не хватило - я прочитал все 4 книги по два раза (по разу от корки до корки, и ещё по разу разбираясь с отдельными концепциями) - и всё равно оцениваю своё понимание тактических шаблонов как "умеренное", а стратегических как "слабое".

[NOTE]
====
Тут строгий читатель может спросить "Какого фига я пишу о чём не знаю?".
Отвечаю.

Во-первых, DDD это такой слон в области проектирования, опусти я которого - другой (а возможно и тот же) строгий читатель спросит, почему я ничего не написал про DDD.

Во-вторых, я критикую DDD за сложность изучения и применения - а в этом, благодаря собственному опыту, я разбираюсь как раз очень хорошо.
====

Тяжеловесность изучения так же усложняет и исполнение - DDD требует включенности (а соотвественно изучения) всей команды и экспертов предметной области.
Опять же мне в своей практике ни разу не удалось продать DDD даже команде, не говоря уж об экспертах предметной области.

Касательно декомпозиции, DDD предусматривает два уровня - ограниченные контексты и агрегаты.

[quote, attribution, Implementing DDD]
____
Ограниченный контекст - это явная граница, внутри которой существует модель предметной области.
Внутри этой границы все термины и фразы Вездесущего языка имеют определённое значение и модель точно отражает Язык.
____

Само определение ограниченного контекста является наглядной демонстрацией сложности и расплывчатости подхода.

Как декомпозировать задачу на ограниченные контексты тоже в двух словах не объяснить (мне по крайней мере).

Как вариант - границы контекста определяются языковыми границами.
Осталось выяснить самую малость - где проходят языковые границы.

Ещё вариант - выравнять контексты по организационной структуре компании.
Но что делать, если я занимаюсь продуктовой разработкой или автоматизирую работу одного отдела?

Руководства по декомпозиции ограниченных контекстов на модули DDD так же не предлагает.
В оригинальной книге этому посвящён целый раздел, но я бы описал его как "вода-вода, не используйте слои, вода-вода".
Если не слои, то что?
Ответа нет.
В первой книге.

Зато есть в Implementing DDD.
[quote, , Implementing DDD]
____
Обычно у вас будет по модулю для одного или нескольких агрегатов, которые связаны хотя бы по ссылке.
____

В целом ответ хорош и в объектно-ориентированной декомпозиции, агрегаты действительно будут играть одну из ключевых ролей.
Но он порождает два новых вопроса - как декомпозировать модель на агрегаты и как декомпозировать систему в которой больше интеграций, чем собственного состояния?
На первый вопрос в DDD найти ответ довольно сложно, а ответа на второй вопрос просто нет.

Тем не менее, я пологаю, если преодолеть все сложности - "продать" подход команде и экспертам, обучить всех, изучить язык экспертов и найти в нём границы - то результирующая декомпозиция на ограниченные контексты и пакеты будет обладать высоким качеством.
В частности, я считаю что в силу своего фокуса на предметной области и экспертах, DDD может дать декомпозицию с наибольшей связанностью среди всех подходов.
А агрегаты и полнокровные сущности помогут существенно снизить сцепленность системы и повысить степень сокрытия информации.

Наконец, ограниченные контексты и возможность помещения нескольких агрегатов в один пакет дают хорошую масштабируемость декомпозиции "из коробки".

Итоговая оценка пакетирования по ограниченным контекстам и агрегатам:

. Сокрытие информации - хорошо
. Сцепленность - хорошо
. Связанность - очень хорошо
. Масштабируемость - хорошо
. Простота объяснения - плохо
. Простота применения - очень плохо

---

Итак, мы пришли к выводу, что все распространённые подходы обладают существенными недостатками.
Пакетирование по слоям даёт откровенно низкокачественную декомпозицию.
Пакетирование по фичам и компонентам является скорее абстрактной идеей, которая требует значительных усилий по доработки для возможности эффективного применения на практике.
DDD является очень тяжеловесной методикой, которую сложно изучать и применять.

Существует ли серебрянная пуля, которая позволит нам быстро и без больших усилий выполнять качественную декомпозицию систем?
Я утверждаю, что да и что она всегда была у нас под носом.
И имя ей - объектно-ориентированная декомпозиция

== Пакетирование по объектам ака объектно-ориентированная декомпозиция

image::ergonomic-decomposition-OO.drawio.svg[]

Пост с примером я ещё не написал.

[NOTE]
====
"Объектно-ориентированная декомпозиция" - это рабочее название, и я не уверен, что оно сохранится.
Дело в том, что сейчас термин "объектно-ориентированный" дефакто стал обозначать "использующих классы", хотя http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html[это совсем не то, что имел ввиду Кей] вводя его.
====

Как очевидно из названия, этот подход предполагает раскладку по пакетам разных объектов.
Тут может возникнуть вопрос - "Мне что, заводить по пакету на класс?".

Ответ - конечно же нет.
В данном контексте под объектом я понимаю не экземпляр класса, а более крупную структуру, которая может быть реализованна группой классов (группой экземпляров классов, если быть точнее).
Эту структуру я называю объектом, потому что она обладает характеристиками объекта - состоянием, которое она абстрагирует и инкапсулирует за высокоуровневым поведением.
Идентичность тоже можно перенести на уровень пакетов, но это требуется редко, поэтому я пока опущу её.

Идея объектов-пакетов принадлежит не мне - я её подглядел в https://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350[Object-Oriented Software Engineering] Ивара Якобсона (одного из авторов UML).
В этой книге Якобсон оперирует тремя видами объектов - объекты анализа, объекты дизайна и объекты (модули) языка программирования.

В объектно-ориентированном подходе я говорю об объектах дизайна, которые Якобсон описывает следующим образом:
[quote, Ivar Jacobson, Object-Oriented Software Engineering]
____
The design model will be composed of blocks which are the design objects.
These will make up the actual structure of the design model and show how the system is designed.
These blocks will later be implemented in the source code.

The blocks will abstract the actual implementation.
The implementation of the blocks may be one specific class in code, that is, one block is implemented by one class.
However, often, a block is implemented by several different classes.
The blocks are therefore a way of abstracting the source code.

Проектная модель будет состоять из блоков, которые являются объектами дизайна.
Они будут составлять фактическую структуру проектной модели и покажут как спроектирована система.
Позже эти блоки будут реализованы в исходном коде.

Эти блоки абстрагируют фактическую реализацию.
Реализацией блоков может быть один определённый класс в коде, то есть один блок реализуется одним классом.
Однако зачастую блоки реализуются несколькими разными классами.
Таким образом блоки являются способом абстракции исходного кода.
____

Общая концепция ОО-подхода очень проста.
Есть операции - атомарные единицы поведения, которые могут быть вызванны извне (пользователем через UI или внешней системой через [REST] API).
Есть ресурсы, которые обеспечивают операции (в первую очередь коллекции в хранилищах данных, но это могут быть и файлы, и внешние системы, и внешние устройства).
Операции и обеспечивающие их ресурсы надо так поделить на объекты дизайна, чтобы каждый ресурс обеспечивал операции только одного объекта.
Наконец, ресурсы надо инкапсулировать в объектах дизайна - исключить возможность обращения к ресурсу напрямую снаружи объекта.

Интерфейс объекта дизайна может быть дополнен операциями, необходимым другим объектам.
Но в общем случае для взаимодействия объектов лучше использовать асинхронный обмен сообщениями и событиями через посредника (очередь).

Кратко методика проектирования объектов дизайна (ака декомпозиции на пакеты) состоит из трёх основных шагов:

. Определить операции системы и ресурсы необходимые для их выполнения
. Разбить их на объекты таким образом, чтобы с каждым ресурсом взаимодействовал один объект.
  Для защиты ресурсов, у каждого объекта дизайна выделяется набор классов, определяющих его интерфейс (обычно это класс сервиса и DTO), а всё остальное (сущности, репозитории, клиенты внешних систем, другие вспомогательные классы) делаются закрытыми (package private в Java, https://dev.to/0xkkocel/improving-kotlin-s-internal-with-archunit-4b3g[internal + ArchUnit правило] в Kotlin).
. Нормализовать количество и размер объектов:
.. Если количество объектов получилось "слишком большим" (~10 и более) - сгруппировать связанные между собой объекты.
   Если таких нет, то стоит рассмотреть декомпозицию уже самой системы на несколько независимых
.. Если в одном объекте количество операций или ресурсов получилось слишком большим (~10 и ~3 и более соответственно), то надо рассмотреть возможность разбить этот объект на несколько взаимодействующих через обмен сообщениями.
   Если такой возможности нет, то стоит хотя бы ресурсы выделить во внутренние объекты (подпакеты)

Первый шаг я описал в link:++{{< ref "posts/22/06/220611-true-story-project">}}++["посте с описанием построения диаграммы проекта True Story Project"].
Пример, рассмотренный в этом посте, хорошо демонстрирует работу с внешними системами, но в силу специфики примера обходит стороной вопрос декомпозиции на ресурсы собственного состояния системы.
Общая идея работы с внутренним состоянием заключается в том, чтобы декомпозировать его на агрегаты DDD.
Сейчас у меня есть только link:++{{< ref "posts/22/04/220401-aggregates#_методика_декомпозиции_модели_информации_на_агрегаты">}}++[общее описание] методики декомпозиции на агрегаты, но пост с примером проектирования системы с развесистым собственным состоянием есть у меня в планах.

Второй и третий же шаги я опишу в следующем посте, для которого данный является прелюдией с обоснованием необходимости создания объектно-ориентированного подхода.

Эта методика относительно простая и механистическая, но даёт на удивление хорошие результаты.

Очевидно, что полученная декомпозиция обладает высокой степенью сокрытия информации - детали реализации (ресурсы) операций системы скрываются внутри объектов дизайна.
Так же это, совместно с рекомендацией по организации взаимодействия между объектами посредством обмена сообщениями, помогает и сцепленность свести к минимуму.

Вместе с низкой сцепленностью рука об руку идёт и высокая связанность (количество зависимостей внутри пакета), которая подтверждается локальностью изменений в проектах декомпозированных таким образом.

Наконец, масштабирование так же учтено и встроено в саму методики.

С критериями оценки самой методики тоже всё хорошо.
Объяснить её, конечно, сложнее, чем слоёную декомпозицию, но намного проще чем остальные методики из группы декомпозиций на основе предметной области.
То же касается и применения - проектирование объектов требует больше усилий, чем полное отсутствие усилий в случае слоёв, но эти усилия пренебрежимо малы на фоне остальных методик, оперирующих расплывчатыми понятиями фичи, компонента и языка предметной области.

Итоговая оценка пакетирования по объектам:

. Сокрытие информации - очень хорошо
. Сцепленность - хорошо
. Связанность - хорошо
. Масштабируемость - хорошо
. Простота объяснения - средне
. Простота применения - средне

== Заключение

Все распространённые методики группировки классов по пакетам обладают существенными недостатками.
Группировка по слоям даёт откровенно плохие результаты.
Группировку по фичам и компонентам не понятно как выполнять и непонятно где этому научиться.
Группировку по ограниченным контекстам и агрегатам сложно изучить, а потом выполнить.

Для того чтобы решить эти проблемы я разработал методику объектно-ориентированной декомпозиции системы на пакеты.
Она проще в изучении и применении группировок по фичам, компонентам и ограниченным контекстам/агрегатам, но даёт результаты такого же качества.

В следующем посте я вернусь к link:++{{< ref "posts/22/06/220611-true-story-project">}}++[серии постов] о диаграмме эффектов и подробно рассмотрю процесс выполнения объектно-ориентированной декомпозиции на конкретном примере.
