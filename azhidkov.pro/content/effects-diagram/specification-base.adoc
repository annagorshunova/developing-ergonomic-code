:rouge-theme: github
:icons: font
:sectlinks:

== История изменений

=== v0.0.2

. Изменение условного обозначения событий: отказ от представления отдельными блоками в пользу стрелок.
. Переход к использованию визуального языка C4 Model.

=== v0.0.1

Опубликована первая версия.

== Введение

Диаграмма эффектов — инструмент для разработчиков, предназначенный для визуализации поведения информационной системы через описание её взаимодействия с внешним миром.

Диаграмма эффектов полезна на всех этапах разработки ПО — от первичного анализа до планирования работ и поддержки. Она позволяет с минимальными затратами:

* получить целостную картину реализации будущей системы;
* оценить трудоёмкость разработки;
* декомпозировать систему на модули;
* определить порядок выполнения работ;
* уменьшить количество регрессий при внесении изменений в систему.

== Концептуальная модель

В основе концептуальной модели диаграммы лежат *эффекты* — атомарные единицы взаимодействия системы с окружающим миром.
Группы эффектов, которые обеспечивают атомарные функции системы, объединяются в *операции*.
Элементы окружающего мира, с которыми могут взаимодействовать операции, представлены внутри системы *ресурсами*.
Выполнение операций инициируется *событиями*.

=== Эффект

*Эффект* — это акт чтения или изменения некоторого состояния.
Это может быть состояние внешнего устройства, доступное через операции ввода-вывода, или глобальная память программы, доступная напрямую.

*Эффекты чтения* характеризуются тем, что считывание одного и того же состояния в разные моменты времени может дать разные результаты.
А *эффекты изменения* (или записи) характеризуются тем, что изменённое состояние можно наблюдать за пределами текущего потока выполнения.

Примеры эффектов:

* чтение и запись статической переменной;
* чтение и запись файла;
* выборка или обновление данных в таблице реляционной БД;
* отправка HTTP-запросов.

Более подробно понятие эффекта рассмотрено в <<Приложение 3. Философия эффекта,Приложении 3. Философия эффекта>>.

=== Операция

Как правило, для реализации функции системы требуется несколько эффектов. Группа эффектов, реализующих одну функцию системы, образует *операцию системы*.

=== Ресурс

Эффекты воздействуют на объект — целевое состояние.
Это та часть физического мира, с которой будет взаимодействовать устройство ввода-вывода в процессе реализации эффекта.
Чаще всего в качестве целевого состояния выступают биты на носителях информации, но это могут быть и пиксели экрана, и динамик колонки, и актуатор робота.
Эти части физического мира представлены в системе как *ресурсы*.

=== Событие

Программа выполняет набор эффектов в ответ на *событие*.
Таким событием может быть получение вызова удалённой процедуры, появление нового сообщения в очереди сообщений, наступление определённого момента времени и т.д.

Система может реагировать как несколькими операциями в ответ на одно событие, так и одной операцией в ответ на несколько событий разных типов.

== Применение

Диаграмма эффектов даёт чёткое представление об операциях системы, необходимое на всех этапах жизненного цикла разработки.

. На этапе *поддержки и развития* диаграмма позволяет описать текущее наблюдаемое поведение системы и спрогнозировать, как оно поменяется после внесения изменений в систему. Благодаря этому можно заметить нежелательные изменения и, таким образом, избежать регрессий.

. На этапе *анализа требований* к системе диаграмма эффектов помогает переформулировать требования в абстракциях будущей программы.

. На этапе *оценки* диаграмма позволяет точнее определить состав работ (на основе списка операций) и трудоёмкость (на основе списка событий, требуемых эффектов и целевых ресурсов).

. На этапе *проектирования системы* операции и ресурсы диаграммы становятся ключевыми блоками, правильная декомпозиция которых поможет создать основу для системы с низкой сцепленностью.

. На этапе *реализации* взаимосвязь операций через ресурсы помогает определить порядок выполнения работ и те работы, которые могут быть выполнены параллельно.

== Нотация

В основе визуального языка диаграммы эффектов лежит язык https://c4model.com/[модели C4].
Это позволяет встраивать диаграмму эффектов в модель C4 на четвёртом уровне — в качестве диаграммы кода.

Нотация диаграммы эффектов бывает двух типов — краткая и полная.

=== Краткая нотация

В краткой нотации используются 4 элемента, которые составляют ядро диаграммы эффектов:

* операции;
* ресурсы;
* эффекты;
* примечания.

=== Полная нотация

В полной нотации добавляются элементы:

* события;
* описания операций и ресурсов в формате модели C4;
* границы контейнера из C4;
* внешние системы, базы данных и компоненты из C4.

Расширять состав диаграммы можно постепенно, добавляя только те элементы, которые помогают в решении текущей задачи.

=== Критерии выбора нотации

*Краткая нотация* подойдёт, если:

* требуется быстро разбить систему на модули;
* необходимо спланировать модификацию сложной или незнакомой операции;
* диаграмму будет использовать только автор в течение непродолжительного времени и повторное возвращение к ней не планируется.

*Полная нотация* рекомендуется, если:

* нужно оценить проект для работы за фиксированную цену и минимизировать вероятность потери существенных деталей;
* планируется опубликовать диаграмму или использовать её через длительный срок после создания.

=== Пример диаграммы эффектов

Оба вида нотации рассматриваются на примере визуализации процесса регистрации и аутентификации пользователей в произвольной системе. После успешной регистрации пользователям отправляется приветственное письмо.

Диаграмма эффектов с использованием краткой нотации:

image::short-notation-example.png[link={imagesdir}/short-notation-example.png]

Диаграмма эффектов с использованием полной нотации:

image::full-notation-example.png[link={imagesdir}/full-notation-example.png]

=== Элементы диаграммы эффектов

==== Операции

Операции обозначаются прямоугольником с именем операции:

image::operation.png[]

==== Ресурсы

Ресурсы обозначаются прямоугольником с именем ресурса и цветом, отличным от цвета операции:

image::resource.png[]

==== Эффекты

*Эффект модификации ресурса* обозначается утолщённой линией красного цвета со стрелкой от операции к ресурсу и сопровождается кратким описанием эффекта:

image::operation-resource-rw.png[]

*Эффект чтения ресурса* обозначается обычной линией со стрелкой от ресурса к операции и сопровождается кратким описанием считываемых данных:

image::operation-resource-ro.png[]

*Эффекты косвенного вызова операций* взаимодействия с ресурсами обозначаются утолщённой прерывистой линией со стрелкой и сопровождаются кратким описанием связи:

image::resource-operation-rw.png[]

Как правило, эти эффекты реализуются через ресурсы всевозможных шин событий и связанные с ними операции-обработчики.

==== Примечания

На диаграмму можно помещать заметки и примечания. Рекомендуемое обозначение *примечаний* — «лист» с загнутым углом, связанный прерывистой линией с комментируемым элементом, но можно использовать и обозначения из других нотаций.

image::note.png[]

==== События

*События* обозначаются обычной линией с кругом в начале и стрелкой на конце. Стрелка направлена от внешней системы к операции и сопровождается описанием в формате C4.

В промежуточной версии диаграммы изображение внешней системы можно опустить:

image::event-operation.png[]

==== Описания

Для блоков операций можно указать тип, способ реализации и описание:

image::descriptions.png[]

==== Границы контейнера и внешние системы

Элементы, обозначающие границы системы и внешние системы, полностью соответствуют нотации C4:

* границы системы обозначаются прямоугольником с указанием имени контейнера, для контура прямоугольника используется светло-серая прерывистая линия;
* управляемые внешние системы и базы данных обозначаются прямоугольником и символом «База данных»;
* неуправляемые внешние системы и компоненты обозначаются прямоугольниками светло-серого цвета;
* неуправляемые базы данных обозначаются светло-серым символом «База данных».

==== Связь внешних систем с другими элементами диаграммы

Внешние системы связываются с *операциями* посредством *событий*:

image::event-sources.png[]

*Ресурсы* связываются с внешними системами посредством *стрелок с описанием*:

image::resource-impls.png[]

==== Связь ресурсов со сторонними компонентами

*Ресурс* может быть связан со сторонним компонентом, работающим в том же процессе.

Ресурс, обладающий эффектом вызова операции системы, связывается со сторонним компонентом с помощью утолщённой прерывистой линии со стрелкой:

image::resource-component.png[]

Если ресурс не обладает таким эффектом, то он связывается со сторонним компонентом обычной линией со стрелкой.

== Приложение 1. Инструментарий

Диаграмма эффектов основана на визуальном языке модели C4, поэтому для её построения можно использовать https://c4model.com/#Tooling[любой инструмент с поддержкой C4].

== Приложение 2. Реализация концептуальной модели в коде

Все элементы, описанные в концептуальной модели, транслируются непосредственно в код: события и операции — в методы, ресурсы — в классы, эффекты — в вызовы методов.

*Операции* всегда транслируются в методы классов слоя сервисов приложения, т.е. в методы, определяющие публичный интерфейс модуля.
При реализации этих методов желательно сохранить взаимосвязь эффектов и операций, представленную на диаграмме: методы должны содержать в себе столько же вызовов методов классов-ресурсов, сколько стрелок у соответствующей операции на диаграмме.

*Ресурсы* превращаются в структуру данных и коллекцию методов работы с ней. Это могут быть классы Spring Data агрегата и репозитория, классы события и интерфейса ApplicationEventPublisher (или обёртки вокруг него), классы REST API модели и клиента и т.п.

В контексте бэкендов информационных систем самыми распространёнными видами ресурсов являются:

* любые постоянные коллекции данных — таблицы в реляционной СУБД, коллекции в документной СУБД и т.д.;
* REST API внешних сервисов;
* любые очереди сообщений и шины событий;
* изменяемые структуры данных, доступные через глобальные переменные.

*События* превращаются в методы, передаваемые фреймворку для последующего вызова. Например, в метод класса контроллера (RestController в Spring), слушателю (EventListener в Swing), в реализацию Runnable для таймера и т.д.

В контексте бэкендов информационных систем самыми распространёнными видами событий являются:

* получение запроса по сети (@RestController + @*Mapping в случае разработки на Spring).
  Сейчас популярностью пользуется протокол запросов в REST-стиле, но SOAP, gRPC, CORBA и т.п. также попадают в эту категорию;
* появление сообщения в очереди (@JmsListener);
* доменное событие или событие приложения (@EventListener);
* наступление определённого момента времени (@Scheduled). Два основных типа таких событий:
** наступление заранее известного момента времени (например, полночь вторника);
** истечение определённого времени с момента в прошлом (например, истечение суток с момента создания предыдущего бэкапа).

== Приложение 3. Философия эффекта

Эффект в программировании — это всегда *действие* по изменению состояния какого-то транзистора.

В *эффекте чтения* состояние транзистора памяти внешнего устройства через несколько промежуточных этапов попадает в регистр процессора, который, в свою очередь, является группой транзисторов.

В *эффекте записи* наоборот: состояние регистра процессора переносится в транзистор внешнего устройства.
На этом эффект может быть завершён (например, в случае жёсткого диска), либо это состояние может быть «аналогизировано» — превращено в физический процесс (например, световую волну или движение ноги робота). Так эффект работы программы становится наблюдаемым поведением.

Высокоуровневый эффект может проходить через несколько этапов переноса посредством чтения и записи.
Например, эффект «Отправить пуш уведомление» пройдёт такой путь: сначала информация переносится через кеши из процессора в память программы, потом в память ОС, потом в память сетевой карты, потом через память нескольких роутеров и серверов в память сетевой карты другого компьютера (смартфона), затем обратно в память программы, а оттуда, опять же через несколько слоёв, в память экрана, где состояние транзистора «аналогизируется» в свечение пикселей в «шторке» смартфона.
И где-то попутно этот эффект заодно осядет на транзисторах диска БД пуш-сервиса.

С такой позиции «неэффектов» не существует — любое действие в программе выражается в изменении состояния транзисторов. Это справедливо по крайней мере в
 https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0[архитектуре фон Неймана].

При этом существует функциональная парадигма программирования, которая характеризуется акцентом на функциях без эффектов.
Но в современном компьютере даже идеально чистая вызывающая функция записывает данные в память, выделенную для стека, и ожидает, что идеально чистая вызываемая функция их считает, а потом запишет свой результат.

Я ни разу не встречал формального определения того, что считается эффектом, а что «неэффектом».
Но, по-видимому, общепринятое мнение таково, что изменение регистра процессора и стека программы эффектами не считается, а любые изменения, начиная с кучи программы и далее — считаются.
То есть разница между эффектом и «неэффектом» заключается в области видимости.
Или, другими словами, в количестве наблюдателей поведения.
