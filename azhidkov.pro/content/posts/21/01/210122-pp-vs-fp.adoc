---
title: "Красная или синяя?"
date: 2021-01-22T13:25:37+07:00
draft: false
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font

*Статья не отредактирована после переезда с телеграфа. https://telegra.ph/Krasnaya-ili-sinyaya-01-26[Оригинал]*

_Привет!_ _Чёт ~эта неделька опять выдалась сложная~ я прокрастинирую
пост о грязных функциях и сайд эффектах, потому что там кой-чего не
схоидтся._ _Поэтому сёня пост в бок с хейтом мейнстримного ``ООП'' -
почитывал на досуге код на кложуре, и меня опять малёха бомбануло._

Меня тут осенило. Возьмём вот такой кусочек кода на кложуре (чисто
функциональном языке):
image:channel/ergo/drafts/210122-pp-vs-fm/fp.png[Сброс пароля в ФП
стиле]

[source,clojure]
----
(my-app.users/reset-password user)
----

Здесь вызываюется функция `reset-password` из неймспейса `my-app.users`
с параметром `user`.

А потом сделаем несколько трансформаций.

Вжух, переносим скобку:

....
my-app.users/reset-password (user)
....

Вжух, меняем кебаб на камел кейс:

....
my_app.use  rs/resetPassword (user)
....

Вжух, меняем неймспейс на объект:

[source,kotlin]
----
val users = my_app.UserService()
users.resetPassword(user)
----

И вишенка, на торте, чтобы по СОЛИДнее было:

[source,kotlin]
----
val userService: UserService = UserServiceImpl(getDb())
userService.resetPassword(user)
----

Знакомый код? Если у вас бэк на спринге, то готов поставить тыщу, что у
вас где-то есть `com.my_company.my_app.services.UserService`:)

____
Пока этот пост отлёживался случайно наткнулся на очередное подтверждение
повсеместности такого подхода:
image:images/2021/01/случай-из-жизни.png[Случай из жизни]
____

При том > OO makes code understandable by encapsulating moving parts. >
> FP makes code understandable by minimizing moving parts.

____
Объектно-ориентированный подход делает код понимаемым (прим. ред.:
поддерживаемым) по средствам инкапсуляции движущихся частей (прим. ред.:
изменяемого состояния).
____

____
Функциональное программирование делает код поддерживаемым по средствам
минимизации изменяемого состояния.

https://twitter.com/mfeathers/status/29581296216?lang=en,
____

Это цитата Майкла Фэзерса, автора
https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052[Working
Effectively with Legacy Code] и чувака придумавшего акроним SOLID:)

А такой стиль не является ОО, т.к. не инкапсулирует ``двигающиеся
части'' (состояние, структуру User в данном случае).

ООПный код был бы примерно такой:

[source,kotlin]
----
val rs = usersTable.findUser(id)
val user = User(rs)
user.resetPassword()
user.saveTo(db)
----

____
И на самом деле это не наша вина - тръу ООП нарушает SRP (в любой
интерпретации), loose coupling/high cohesion и вообще заточено под
масштабирование кол-ва типов данных в системе, а не фич реализуемых на
основе этих типов. А софт, как привило, всё таки обрастает новыми фичами
поверх старых данных, а не новыми данными для старых фич. Поэтому у
девеолперов был только один разумный выбор, чтобы хоть как-то выжить -
дефакто отказаться от ООП.

Справедливости ради масштабироваться ещё наследованием. Но, во-первых,
оно вроде уже повсеместно признано не удачной затеей. А, во вторых, не
понятно кто от кого должен наследоваться в случае RelationalUser (работа
с БД) и JsonUser ((де)сериализация Json). Что будет если пойти этим
путём можно посмотреть у
https://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html[Егора
Бугаенко].

Но вместе с водой выкинули и младенца - ООД.
____

Поэтому единственный способ сделать такой код поддерживамым - это ФП (а
дизайн - ООД).

И положа руку на сердце, ваши сервисы - это неймспейсы чистых функций,
или пакеты процедур с побочками? Мои всё ещё как правило - пакеты
процедур. Где-то гайдлайн такой, где-то инфраструктуры нет, а где-то это
тупо быстрее и привычнее.

Но в последнее время проекты с удачно сложившимися звёздами, мне удаётся
сделать в ФП-стиле. И оно того стоит.

А какую таблетку выбираете вы?:)
