---
title: "Почему следует избегать использование JPA/Hibernate"
description: Как дизайн JPA/Hibernate ведёт к созданию медленных приложений с большим плохим дизайном
date: 2021-04-03T13:25:37+07:00

draft: true
---
:source-highlighter: rouge
:rouge-theme: github
:icons: font

== Введение

Мои отношения с Хибернейтом (JPA тогда ещё не было) не сложились с самого начала - в далёком то ли 2005, то ли 2007, на собеседовании у меня спросили как замапить отношение 1-N в Хибернейте.
А я ответил "Я не знаю, что такое JPA".

Затем в чуть менее далёком 2008 году я устроился в Софтэйдж на какой-то проект на Swing и Hibernate.
Коммерческого опыта ни с тем ни с другим у меня на тот момент не было, поэтому мне казалось что работал я плохо, я сильно парился на эту тему недели две-три, а потом под этим предлогом и уволился.
И судя по тому, что Сергей Бражник, который был ПМом того проекта, не сильно возражал - я действительно плохо работал.

С тех пор я ненавижу Хибернейт, считаю JPA самой большой ошибкой платформы Java и намеренно избегаю изучения этой технологии:)

В общем на объективность я не претендую:)
Однако, избежать JPA Java-разработчику практически не реально, поэтому и мне пришлось испить эту чашу до дна, раскопать гору багов и проблем, порождённых стилем программирования ей насаждаемым и попутно всё-таки разобраться как она работает в общих чертах.

Поэтому я изложу факты, а как их интерпретировать, решайте сами.

== Философия JPA

Моя вольная интерпретация философии JPA: "Забудьте про базу данных - просто объявите свою объектную модель и работайте с ней, как будто она вся в памяти, а мы позаботимся о сохранении объектов в БД".

== Упрощённая модель работы Hibernate

.Упрощённая модель работы Hibernate
image::/posts/21/04/jpa-model.svg[]

Для обеспечения обещания "работайте как будто у вас все объекты в памяти" Hibernate работает примерно так:

. Приложение начинает транзакцию через `entityManager.getTransaction().begin()` (https://en.wikipedia.org/wiki/Software_transactional_memory[транзакции бывают и в памяти] и это не противоречит философии JPA)
. Приложение загружает данные через entityManager
.. entityManager формирует запросы и получает строки таблиц через JDBC-Driver
.. ORM на основе строк формирует прокси объектов сущностей
.. перед тем как отдать приложению, entityManager сохраняет все объекты в Persistence Context
. приложение как-то мутирует объекты через сеттеры
.. но т.к. это прокси, то сеттеры заодно помечают объекты "грязными"
. приложение коммитит транзакцию через `entityManager.getTransaction().commit()`
.. в этот момент entityManager просматривает Persistence Context, сохраняет/обновляет в БД все "грязные" и новые объекты

Казалось бы, всё прекрасно - "Смотри, мам! Никакого шаблонного кода работы с БД!".
Всё настолько легко и просто, что можно дать задачу свеже испечённому выпускнику курсов "стань Java-разработчиком за три месяца" и он сразу начнёт давать результат.
Но это только пока вы делаете первую версию простой системы, которую одновременно используете вы и тестировщик.
А когда система попадает под нагрузку и начинает меняться, это дизайн начинает показывать своё [line-through]#дьявольское рыло# недостатки.

== Достоинства JPA

У всего есть свои плюсы и минусы и надо признать, что плюсы есть даже у JPA:)

Это безусловно самая распространённая технология работы с БД на платформе Java.
Из этого вытекает ещё три достоинства:

. По JPA огромное количество материалов всех видов и на любой вкус.
Если использовать JPA идиоматично то любые проблемы и решения гуглятся моментально;
. Нанять разработчика, знающего JPA не проблема - берёте с любого с рынка и с вероятностью 99% имееть хоть какой-то опыт работы с JPA;
. JPA поддержано везде, где его можно поддержать.
В Котлине, например, сделали специальный https://kotlinlang.org/docs/no-arg-plugin.html[плагин] ломающий принципы дизайна языка в угоду совместимости с JPA.

JPA предлагает знакомую всем модель программирования в ООП-стиле.
Опять же, берёте любого программиста с рынка и он знает как работать с JPA.
Кроме того эта модель действительно легкая в использовании и позволяет очень быстро решать задачи в моменте.

С изолированной задачей сохранения и загрузки графов объектов в БД JPA справляется без каких-либо нареканий.

Ещё одна задача с которой JPA справляется достаточно хорошо - это сокрытие разницы в диалектах SQL, в случае если проект должен поддерживать несколько различных СУБД.
Однако это работает только до тех пор, пока вам удаётся обойтись "наибольшим общим делителем" фич SQL-диалектов ваших СУБД, но полезные для производительности фичи обычно скрываются в уникальных частях диалектов.

Наконец, именно с точки зрения реализации, это очень надёжное решение - я не помню чтобы сталкивался с багами в реализации Hibernate.

Но у всего есть и свои минусы и в JPA их тоже хватает.

== Проблемы JPA

Корень проблем JPA лежит не в технической, а парадигмальной плоскости.
JPA пытается создать иллюзию отсутствия базы данных, в частности спрятать от программиста необходимость отражения изменений в памяти в БД.
Поэтому, в силу природы баз данных (управление изменяемым состоянием), у неё нет другого выбора, кроме как использовать императивную модель программирования - это единственный способ отдать программе "POJO", а потом отследить изменения его состояния.
И в погоне за этой химерой, у JPA опять же нет другого выбора, кроме как исключить более эргономичную декларативную модель программирования.

=== Конструктор по умолчанию

[quote, JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class", https://github.com/javaee/jpa-spec/blob/master/jsr338-MR/JavaPersistence.pdf]
____
The entity class must have a no-arg constructor.
____
В то время как конструкторы по умолчанию являются анти-паттерном и бомбой замедленного действия - они поваляют создавать объекты, нарушающие инварианты, и создают link:++{{<ref "/posts/21/01/210119-effects#_временная_связность">}}++[временнУю связанность].
Своего поста на эту тему я ещё не написал, поэтому сошлюсь на https://blog.ploeh.dk/2011/05/30/DesignSmellDefaultConstructor/[чужой]:)

Эту проблему можно частично обойти, сделав конструктор по умолчанию package private и пометив его @Deprecated.
Но я не видел, чтобы кто-то кроме меня следовал этой практике.

=== Классы должны быть открытыми для наследования

[quote, JSR 338: JavaTM Persistence API; Version 2.2; "2.1 The Entity Class"]
____
The entity class must not be final
____

А классы должны быть либо спроектированы и задокументированы для наследования, либо запрещать его.
Тут уже сошлюсь совсем на классику: https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997[Effective Java], глава "Item 19:  Design and document for inheritance or else prohibit it".

При том проектирование класса для наследования требует намного больших усилий, чем определение структуры данных с несколькими полями и геттерами и сеттерами для них.
Тут всё таки добавлю немного субъективизма - ни разу не видел JPA Entity спроектированную для наследования.
С другой стороны, справедливости ради, с проблемами вызванными наследованием сущностей JPA я так же не сталкивался.

=== Изменяемые объекты

JPA не может работать с неизменяемым объектами "By Design".
Если же у вас вся модель изменяемая, то вы в полный рост начинаете получять все проблемы, связанные с:

. link:++{{<ref "/posts/21/01/210119-effects#_временная_связность">}}++[ всё той же временной связанностью]
. link:++{{<ref "/posts/21/01/210119-effects#_нелокальность_рассуждений">}}++[нелокальностью рассуждений]
. link:++{{<ref "/posts/21/01/210119-effects#_конкурентное_программирование">}}++[конкурентным программированием]

И для этой проблемы уже нет никакого решения, в силу философии и дизайна JPA.
Для того чтобы минимизировать протечки иллюзии отсутствия БД, JPA необходимо обеспечить строгое соответствие одного объекта в памяти одной строке в БД.
Соотвественно, если вы вместо мутации объекта создадите новый экземпляр с обновлённым состоянием, для JPA это будет новый

Это можно частично обойти, сделав сущности всё-таки неизменяемыми, а обновления выполнять через UPDATE-запросы.
Но это будет хорошо работать, только пока вам надо обновить один объект.
Если же вам надо обновить граф неизменяемых объектов, то вам придётся руками написать запросы для всех типов и руками же обойти этот граф и позвать UPDATE-ы.

=== Select for update

Та же самая проблема возникает, если вы хотите обновить сущность данными, полученными из вне (в HTTP-запросе например).
Оставив в стороне проблемы с сеттерами тут у вас два варианта:

. Выполнить лишний SELECT только для того чтобы поместить объект в PersistenceContext;
. Снова воспользоваться UPDATE-ом.

Первый вариант не удачный с точки зрения производительности.
Второй начинает попахивать постоянной битвой с собственным фреймворком, который вроде бы должен упрощать жизнь.

=== Выборка ссылаемой сущности для вставки ссылающейся

Ещё одна проблема из той же серии вставка новой сущности, которая ссылает на существующую с известным ИДом.
И снова у вас два варианта: либо делать дополнительный запрос, жертвуя производительностью, или бороться с JPA.

=== Кэширование

Кэшировать сущности так же нельзя.

Если они у вас с сеттерами, то их уже нельзя кэшировать, потому вы не сможете синхронизировать к ним конкурентный доступ.

Дополнительно, в случае JPA, закэшированная сущность превратится в тыкву, как только закроется транзакция, в которой она была загружена.
Прочитать из неё данные ещё можно, но вот сослаться на неё уже нельзя.

Наконец, если у сущности есть ленивые поля, то рано или поздно стрельнет LazyLoadingException.

=== LazyLoading

JPA активно продвигает ленивую загрузку - это вариант по умолчанию для отношений OneToMany и ManyToMany.

И я не удивлюсь, если ленивая загрузка ответственна за 1% мирового потребления электроэнергии - нет большего врага производительности, чем ленивая загрузка.

С ленивой загрузкой надо быть постоянно начеку, и каждый раз написав что-то в духе `entity.getXXXs` надо задуматься - не случиться ли здесь https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping[N+1 запрос].
Лично мне не хватает дисциплины на это.

Ну и печально известный LazyLoadingException, куда уж без него.
Я всё ещё продолжаю встречать его в продакшене с завидной регулярностью.

Специфичной для JPA проблемой является то, что оно не предоставляет средств для динамического управления ленивой загрузкой.
Где-то можно использовать `NamedEntityGraph`, но из-за его многословности слишком высок соблазн откатиться к ленивой загрузке.

---

Я уверен, что этот список будет и дальше расти - сейчас я выписал только то, что сходу в голову пришло.

Получается, что теоретически JPA можно использовать, не жертвуя качеством дизайна и производительностью.
Но тогда придётся пожертвовать идиоматичностью использования JPA, а в след за ней уходят и все остальные достоинства JPA - материалов по такому подходу уже нет от слова совсем, в поддержке начинают вылазить острые углы, разработчики этот подход уже не знают и т.п.

Возникает вопрос - стоит ли игра свеч, если качество дизайна и производительность являются для приоритетными качественными атрибутами системы?
И чем воспользоваться, если ответ - "нет"?

== Альтернативы JPA

Все выше перечисленные проблемы не являются неотъемлемыми проблемами объектно-реляционного маппинга.
Это проблемы одного конкретного подхода к ОРМу, вызванные его стремлением сэмулировать работу с объектами в памяти.
Поэтому существует огромное количество решений, даже очень близких к JPA, в которых идиоматичное использование хотя бы не вынуждает жертвовать дизайном и производительностью.

=== Spring Data Jdbc/R2dbc

https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#reference[docs.spring.io/spring-data/jdbc]

Сейчас я предпочитаю работать с БД по средствам Spring Data Jdbc/R2dbc (SDJ).

Эта технология обладает многими достоинствами специфичными для JPA:

. Значительная часть материалов по Spring Data JPA, так же валидна и для SDJ;
. программисты знакомые со Spring Data JPA и смогут довольно быстро подхватить SDJ;
. это "надёжное решение от проверенного вендора" - его легко продать заказчику или СТО.

Это всё та же всеми любимая технология Spring Data, которая автомагически генерирует реализации методов вида `findByName(name: String)`.

При всём при этом SDJ имеет эргономичную философию:
[quote, Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.why]
____
Spring Data JDBC aims to be much simpler conceptually, by embracing the following design decisions:

* If you load an entity, SQL statements get run. Once this is done, you have a completely loaded entity. No lazy loading or caching is done.

* If you save an entity, it gets saved. If you do not, it does not. There is no dirty tracking and no session.

* There is a simple model of how to map entities to tables. It probably only works for rather simple cases. If you do not like that, you should code your own strategy. Spring Data JDBC offers only very limited support for customizing the strategy with annotations.
____

И чуть ниже:
[quote, Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#mapping.general-recommendations]
____

* Try to stick to immutable objects — Immutable objects are straightforward to create as materializing an object is then a matter of calling its constructor only. Also, this avoids your domain objects to be littered with setter methods that allow client code to manipulate the objects state. If you need those, prefer to make them package protected so that they can only be invoked by a limited amount of co-located types. Constructor-only materialization is up to 30% faster than properties population.

* Provide an all-args constructor — Even if you cannot or don’t want to model your entities as immutable values, there’s still value in providing a constructor that takes all properties of the entity as arguments, including the mutable ones, as this allows the object mapping to skip the property population for optimal performance.
____

Более того, хотя

> All Spring Data modules are inspired by the concepts of “repository”, “aggregate”, and “aggregate root” from Domain Driven Design.
> -- Spring Data JDBC Reference Documentation, https://docs.spring.io/spring-data/jdbc/docs/2.1.7/reference/html/#jdbc.domain-driven-design

В моей практике проекты на Spring Data JPA игнорируют и DDD и здравый смысл, создают по репозиторию на таблицу и строят полносвязный двунаправленный граф всех сущностей.
С этим согласны и авторы SDJ:

> These are possibly even more important for Spring Data JDBC, because they are, to some extent, contrary to normal practice when working with relational databases.
> -- Spring Data JDBC Reference Documentation

И "normal practice" - это просто кошмар с точки зрения дизайна, поддержки и производительности, хотя позволяет быстро решить задачу в моменте.

С SDJ же этот фокус не пройдёт из-за отсутствия ленивой загрузки и команде всё-таки придётся озадачиться дизайном модели данных и разбиением её на агрегаты.

Пока что я попробовал эти технологии (JDBC и R2DBC) только в двух небольших проектах, но результатами я пока что восхищён.

=== jooq

https://www.jooq.org/[jooq.org]

Вторая (а в хронологическом порядке первая) технология, с которой у меня есть успешный коммерческий опыт.

В основе jooq-а лежит Java DSL для написания SQL запросов, но автор так же напилил и довольно мощьную инфраструктру исполнения запросов и генерации DAO для CRUD операций.

Основных недостатка два - генерация исходного кода отдельным шагом, и платная лицензия для работы с платными базами данных.

=== Ebean

https://ebean.io/docs/[ebean.io]

Наконец, последняя альтернативная технология, с которой у меня есть более-менее удачный коммерческий опыт.

Эта технология наиболее близка к JPA, но не накладывает её ограничений на дизайн, и намного более производительная по умолчанию.

Однако по Ebean довольно мало документации, а странности в поведении всё-таки встречались.
Плюс Ebean использует препроцессор аннотаций, который заметно тормозит сборку и не всегда корректно работает с Идеей.

Тем не менее, проект сдан, сильно больших проблем с ним не было.

=== MyBatis

https://mybatis.org/mybatis-3/[mybatis.org]

MyBatis я в коммерческих проектах не трогал, но вроде бы тоже относительно популярная альтернатива JPA.

== Когда применение JPA уместно

По моему мнению, применение JPA уместно, когда минимизация стоимости разработки первых нескольких версий системы важнее производительности самой системы и команды разработки в длительной перспективе.
То есть применение JPA уместно в двух случаях:

. Быстрое прототипирование;
. Разработка небольших внутренних информационных систем на пару десятков таблиц и столько же пользователей.

== Заключение

[logo]#image:/images/logo.svg[]#
