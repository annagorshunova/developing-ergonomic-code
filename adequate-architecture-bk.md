# Адекватная архитектура

Эта концепция находится в разработке, поэтому в ней есть белые пятна, и само слово "архитектура" в её названии не самое удачное и возможно будет изменено. В этой концепции я хочу представить один из вариантов концептуального устройства (стратегию) ПО и ряд практик программирования (тактику), призванных обезопасить это устройство от скатывания в больше месиво в результате ежедневной работы.

## Мотивация

## Релейтед ворк

В адекватной архитектуре нет ничего принципиально нового и она по сути основывается на идеях из следующих следующих хорошо известных (в узких кругах) докладах и статьях:
1) Simple Made Easy
2) Layered architecture
3) Functional core, imperative shell
4) Clean architecture
5) Hexagonal architecture
6) Railway oriented programming
7) Data, Context, interaction architecture

### Simple Made Easy
[Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/), ([краткий пересказ на русском](https://tonsky.livejournal.com/243192.html)).

Из этого доклада я взял то, что "просто" != "легко" и что простые вещи выгоднее в длительной перспективе.

Например, для того чтобы сбросить весь надо следовать двум простым правилам - "меньше жрать", "больше двигаться". Выполнять эти правила сложно, но если сумеете, то решите проблему с весом на всегда. Есть простой путь - липоскакция. Но этот путь даёт временный результат и не решает прочих проблем вызванных "легким" образом жизни.

Не взял я из этого доклада clojure, ядрёную функциональщину; идею того, что типы и тесты не особо уменьшают количество багов; и полный отказ от ОРМов.

### Layered architecture
[Layered architecture](https://dzone.com/articles/layered-architecture-is-good), [слоистая архитектура](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0) - на самом деле никогда не занимался изучением этого вопроса, поэтому взял две первые ссылки в гугле, если подскажите ссылку на хорошую статью посвщяённую этой теме - буду очень благодарен.

Адекватная архитектура в принципе является вариантом слоистой, за исключением того, что убирает зависимость слоя бизнес логики от слоя инфраструктуры/персистанса и поднимает этот слой на один уровень со слоем бизнес логики.

### Functional core, imperative shell (FCIS)
[Boundaries](https://www.youtube.com/watch?v=yTkzNHF6rMs), версии на русском я не нашёл.

Из этого доклада я взял всё. А именно - идеи разделения логики и ввода вывода и использования структур данных в качестве интерфейса между этими частями.

### Clean architecture
[Оригинальная статья](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html), [хорошее пояснение на русском](https://habr.com/ru/company/mobileup/blog/335382/), [оригинальная книга](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164), [книга на русском](https://www.ozon.ru/context/detail/id/144499396/).

Наверное самая известная из идей. Из чистой архитектуры я взял идеи того, что зависимости должны быть направлены в строну более стабильных модулейш; доменная модель и бизнеслогика не должны зависеть ни от чего; фреймворк является деталью, которая должна быть задвинута на задворки. Так же, в том числе и от сюда, я взял понятие юз кейса (интерактора).

Не стал я брать из чистой архитектуры границы в виде интерфейсов между всеми слоями по дефолту и утверждение, что база данных и тип гуя являются незначительными деталями.

Так же дядюшке Бобу над отдать должное за [Screaming architecture](https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html). На мой взгляд архитектура это слишком громкое слово, но я включаю этот принцип в тактические приёмы.

### Hexagonal (Ports&Adapters) architecture
[Оригинальная статья 2005 года](http://web.archive.org/web/20051208100950/http://alistair.cockburn.us/crystal/articles/hpaaa/hexagonalportsandadaptersarchitecture.htm), [описание на русском](https://habr.com/ru/post/267125/).

Я думаю это первая публикация из серии архитектур крайне схожих архитектур - hexagonal, clean & onion (да FCIS, тоже примерно про тоже). По сути все эти архитектуры призывают к одному - отделить логику от ввода-вывода, для того чтобы её было легко тестировать.

Отсюда (помимо общей идеи) я позаимствовал термины Порт и Адаптер. Но я их использую в другом смысле:) А до идеи событий приходящих из внешнего мира я додумался сам, когда уже забыл детали этой статьи:)

Не взял я из Hexagonal architecture церемонии с набором порт-интерфейс-адаптер на каждое взаимодействие с платформой и идею о том, что логика приложения окружена "однотипными" портами.

### Railway oriented programming  
[Оригинальная статья](https://fsharpforfunandprofit.com/rop/)

Серия статей о функциональном подходе к обработке ошибок.

Взял идею параллельных рельс для "основного" пути и "ошибочного экспресса". Суть в том, что юз кейс начинается на основном пути, в случае успеха идёт по нему и там же и заканчивается, но с основного пути есть съезды на "ошибочный экспресс", который ведёт сразу к завершению юз кейса. Плюс за то, чтобы заменять исключения на возвращаемые значения, там где это уместно.

Не стал брать, монады и весь абстрактный ад второго порядка с ними связанный.

### Data, Context, interaction architecture
[Оригинальная статья](https://www.artima.com/articles/dci_vision.html).

На эту идею я наткнулся не давно и ещё её изучаю. Суть в том, чтобы объединять "тупые" доменные объекты с поведением по юз кейсно, с помощью трейтов и тайп классов. Если язык не поддерживает тайп классы и трейты, но поддерживает экстеншн функции, то на них, я думаю, можно будет смастерить чё-нить юзабельное. Я думаю это может стать хорошей техникой реализации юз кейсов и логики.

## Адекватная архитектура

В адекватной архитектуре программа рассматривается как набор юз кейсов, которые состоят из следующих частей:
1. Платформа (Обозначена синей поверхностью с технологическими отверстиями на диаграмме)
2. Порты (Обозначен фиолетовым квадратом на диаграмме)
3. Адаптеры (Обозначены малиновым трапециями на диаграмме)
4. Юз кейс (Обозначен голубыми и красными рельсами на диагрмме)
5. Логика (Обозначена зелёными кругами на диаграмме)

![Устройство юз кейса](images/aa-use-case.JPG)

### Платформа
В платформу я включаю всё, что не является непосредственной функцией приложения - начиная от железа, продолжая осью, библиотеками ввода-вывода, мидлварем, фреймворками и заканчивая вашим инфраструктурным кодом. Платформа отвечает за взаимодействие с внешним миром и у этого взаимодействия, по сути, есть только два варианта - понять что наступило какое-то событие (пришёл пакет по сети, пользователь кликнул мышью, истёк таймаут) и обменяться массивами байт. Юз кейс связывается с платформой через порты для получения событий и через адаптеры для обмена байтами.

<details>
<summary>Spring</summary>
В случае спринга платформой будет практически всё. Единственное, что если вы руками делаете сервер поллинг, то эта логика уйдёт в платформу и при получении данных будет вызывать юзкейсы.
</details>

### Порты

### Юз кейсы

- Персистентные
- Взаимодействующие с гуём (диалог подтверждения операции)

### Адаптеры

- ДСЛ

### Логика

## Послабления

## Преминимость
 - ГУЙ
 - Низкоуровневое прграммирование
 - Встраиваемая БД
 - микросервисы
 - консольный уй
 - рекативность
 - Плагины билд систем
 - Распределённые кластеры
 - Отчёты тредс
 - Факторизация кубита

## Заключение
